<!-- -*- indent-tabs-mode: nil -*- -->
<!doctype html>
<meta charset="utf8">
<title>Shared memory and atomics specification</title>
<link rel="stylesheet" href="https://bterlson.github.com/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">

<h1>Shared memory and atomics specification</h1>

<emu-intro id="intro">
<h1>Introduction</h1>
<p>
This proposal adds shared memory types and atomic operations to ECMAScript.
</p>
<p>
This document is organized in terms of where changes would be made to the ES6 spec. Although ecmarkup generates numbering at the beginning of headers, these won't correspond to the numbering within the existing ECMA spec, so I've included a matching numbering in parentheses afterwards, referring to the ES6 spec.
</p>
<p>This document is in spec order, not written for direct readability.</p>
<p>Changelog:</p>
<ul>
</ul>
</emu-intro>

<emu-clause id="Overview">
  <h1>Overview (ES6 4)</h1>
  <emu-clause id="Overview.Terms">
    <h1>Terms and Definitions (ES6 4.3)</h1>
    <emu-clause id="Overview.Terms.Agent">
      <h1>Agent</h1>
      <p> The combination of an instance of an ECMAScript execution environment and the ECMAScript programs running within that environment. </p>
      <emu-note>
        <p>Agents whose lifetimes overlap and who are able to share a Shared Data Block can communicate by means of certain operations on that Shared Data Block.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="DataTypesValues">
  <h1>ECMAScript Data Types and Values (ES6 6)</h1>
  <emu-clause id="DataTypesValues.SpecTypes">
    <h1>ECMAScript Specification Types (ES6 6.2)</h1>
    <emu-clause id="DataTypesValues.SpecTypes.DataBlocks">
      <h1>Data blocks (ES6 6.2.6)</h1>
      <p> AMEND: Insert the following paragraph after the third: </p>
      <p> A data block that resides in memory that is shareable between concurrent agents is designated a Shared Data Block. </p>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes">
        <h1>CopyDataBlockBytes(toBlock, toIndex, fromBlock, fromIndex, count) (ES6 6.2.6.2)</h1>
        <p> AMEND: In step 1, allow also a Shared Data Block. </p>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock">
        <h1>CreateSharedByteDataBlock( size )</h1>
        <p>When the abstract operation CreateSharedByteDataBlock is called with integer argument size, the following steps are taken:</p>
        <emu-alg>
          1. Assert: _size_ >= 0.
          1. Let _db_ be a new Shared Data Block value consisting of size bytes. If it is impossible to create such a Shared Data Block, throw a ~RangeError~ exception.
          1. Set all of the bytes of _db_ to 0.
          1. Return _db_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID" aoid="SharedDataBlockID">
        <h1>SharedDataBlockID( block )</h1>
        <p>When the abstract operation SharedDataBlockID is called with shared data block argument _block_, the following steps are taken:</p>
        <emu-alg>
          1. Let _G_ be an address-free identifier for _block_.  _G_ has the same value in every agent.
          1. Return _G_.
        </emu-alg>
        <emu-note>
          <p>The Shared Data Block ID is used by the futex mechanism and names _block_ independently of any virtual addresses it may be mapped to in any particular agent.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="IndexedCollections">
  <h1>Indexed Collections (ES6 22)</h1>
  <emu-clause id="TypedArray">
    <h1>TypedArray Objects (ES6 22.2)</h1>
    <p>FIXME: Modifications to TypedArray to allow the use of SharedArrayBuffer.  These may be extensive.  SharedArrayBuffer stores its internal data in slots that ave other names than ArrayBuffer, this will cause some churn. </p>
  </emu-clause>
</emu-clause>

<emu-clause id="StructuredData">
  <h1>Structured Data (ES6 24)</h1>
  <emu-clause id="StructuredData.SharedArrayBuffer">
    <h1>SharedArrayBuffer Objects</h1>

    <emu-clause id="StructuredData.SharedArrayBuffer.abstract">
      <h1>Abstract Operations for SharedArrayBuffer</h1>
      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer">
        <h1>AllocateSharedArrayBuffer ( constructor, byteLength )</h1>
        <p> The abstract operation AllocateSharedArrayBuffer with arguments constructor and byteLength is used to create a SharedArrayBuffer object. It performs the following steps:</p>

        <emu-alg>
          1. Let obj be OrdinaryCreateFromConstructor(constructor, "%SharedArrayBufferPrototype%", «‍[[SharedArrayBufferData]], [[SharedArrayBufferByteLength]]» ).
          1. ReturnIfAbrupt(obj).
          1. Assert: byteLength is a positive integer.
          1. Let block be CreateSharedByteDataBlock(byteLength).
          1. ReturnIfAbrupt(block).
          1. Set obj’s [[SharedArrayBufferData]] internal slot to block.
          1. Set obj’s [[SharedArrayBufferByteLength]] internal slot to byteLength.
          1. Return obj.
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.GetValueFromSharedBuffer" aoid="GetValueFromSharedBuffer">
        <h1>GetValueFromSharedBuffer ( arrayBuffer, byteIndex, type )</h1>
        <P> This is the same as ArrayBuffer's GetValueFromBuffer (ES6 24.1.1.5) except that: </p>
        <ul>
          <li> The _arrayBuffer_ parameter is a SharedArrayBuffer
          <li> There is no _isLittleEndian_ parameter, it is "not present". The implementation must determine the same value for _isLittleEndian_ in all agents that can communicate through shared memory (see Atomics.isLockFree for more precise wording, for now)
          <li> There is no detachment check (step 1)
          <li> Use the [[SharedArrayBufferData]] internal slot (step 4)
        </ul>
      </emu-clause>
      
      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.SetValueInSharedBuffer" aoid="SetValueInSharedBuffer">
        <h1>SetValueInSharedBuffer ( arrayBuffer, byteIndex, type, value )</h1>
        <P> This is the same as ArrayBuffer's SetValueInBuffer (ES6 24.1.1.6) except that: </p>
        <ul>
          <li> The _arrayBuffer_ parameter is a SharedArrayBuffer
          <li> There is no _isLittleEndian_ parameter, it is "not present".
          <li> There is no detachment check (step 1)
          <li> Use the [[SharedArrayBufferData]] internal slot (step 5)
        </ul>
      </emu-clause>
      
    </emu-clause>

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor">
      <h1>The SharedArrayBuffer Constructor</h1>
      <p> The SharedArrayBuffer constructor is the %SharedArrayBuffer% intrinsic object and the initial value of the SharedArrayBuffer property of the global object. When called as a constructor it creates and initializes a new SharedArrayBuffer object. SharedArrayBuffer is not intended to be called as a function and will throw an exception when called in that manner. </p>

      <p> The SharedArrayBuffer constructor is designed to be subclassable. It may be used as the value of an extends clause of a class definition. Subclass constructors that intend to inherit the specified SharedArrayBuffer behaviour must include a super call to the SharedArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support the SharedArrayBuffer.prototype built-in methods. </p>
      
      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.withLength">
        <h1>SharedArrayBuffer ( length )</h1>
        <p> SharedArrayBuffer called with argument length performs the following steps: </p>
        <emu-alg>
          1. If NewTarget is undefined, throw a ~TypeError~ exception.
          1. Let _numberLength_ be ToNumber(_length_).
          1. ReturnIfAbrupt(_numberLength_).
          1. Let _byteLength_ be ToLength(_numberLength_).
          1. ReturnIfAbrupt(_byteLength_).
          1. If SameValueZero(_numberLength_, _byteLength_) is false, throw a ~RangeError~ exception.
          1. Return AllocateSharedArrayBuffer(NewTarget, _byteLength_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties">
      <h1>Properties of the SharedArrayBuffer constructor</h1>
      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.isView">
        <h1>SharedArrayBuffer.isView ( arg )</h1>
        <p>The isView function takes one argument arg, and performs the following steps are taken:</p>
        <emu-alg>
          1. If Type(_arg_) is not ~Object~, return ~false~.
          1. If _arg_ has a [[ViewedArrayBuffer]] internal slot, return ~true~.
          1. Return ~false~.
        </emu-alg>
        <emu-note>
          <p> This function is identical to ArrayBuffer.isView, since TypedArrays use the [[ViewedArrayBuffer]] internal slot to hold both unshared and shared views. </p>
        </emu-note>
      </emu-clause>
      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.prototype">
        <h1>SharedArrayBuffer.prototype</h1>
        <p> The initial value of SharedArrayBuffer.prototype is the intrinsic object %SharedArrayBufferPrototype% (q.v.).</P>
        <p> This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</p>
      </emu-clause>
      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.get_species">
        <h1>get SharedArrayBuffer [ @@species ]</h1>
        <P>`SharedArrayBuffer[@@species]` is an accessor property whose set accessor function is ~undefined~. Its get accessor function performs the following steps:</P>
        <emu-alg>
          1. Return the this value.
        </emu-alg>
        <P> The value of the name property of this function is "`get [Symbol.species]`".</P>
      </emu-clause>
    </emu-clause>

    <emu-clause id="StructuredData.SharedArrayBuffer.prototype">
      <h1>Properties of the SharedArrayBuffer prototype object</h1>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.get_byteLength">
        <h1>get SharedArrayBuffer.prototype.byteLength</h1>

        <p> SharedArrayBuffer.prototype.byteLength is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: </P>

        <emu-alg>
          1. Let _O_ be the ~this~ value.
          1. If Type(_O_) is not ~Object~, throw a ~TypeError~ exception.
          1. If _O_ does not have a [[SharedArrayBufferData]] internal slot, throw a ~TypeError~ exception.
          1. Let length be the value of _O_’s [[SharedArrayBufferByteLength]] internal slot.
          1. Return length.
        </emu-alg>
      </emu-clause>

      <emu-clause id="SharedArrayBuffer_prototype_constructor">
        <h1>SharedArrayBuffer.prototype.constructor</h1>
        <p> The initial value of `SharedArrayBuffer.prototype.constructor` is the intrinsic object %SharedArrayBuffer%. </p>
      </emu-clause>

      <emu-clause id="SharedArrayBuffer_prototype_slice">
        <h1>SharedArrayBuffer.prototype.slice ( start, end )</h1>
        <p> The following steps are taken: </p>
        <emu-alg>
          1. Let _O_ be the ~this~ value.
          1. If Type(_O_) is not ~Object~, throw a ~TypeError~ exception.
          1. If _O_ does not have a [[SharedArrayBufferData]] internal slot, throw a ~TypeError~ exception.
          1. Let _len_ be the value of _O_’s [[SharedArrayBufferByteLength]] internal slot.
          1. Let _relativeStart_ be ToInteger(_start_).
          1. ReturnIfAbrupt(_relativeStart_).
          1. If _relativeStart_ &lt; 0, let first be max((_len_ + _relativeStart_),0); else let first be min(_relativeStart_, _len_).
          1. If _end_ is ~undefined~, let _relativeEnd_ be _len_; else let _relativeEnd_ be ToInteger(_end_).
          1. ReturnIfAbrupt(_relativeEnd_).
          1. If _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_),0); else let _final_ be min(_relativeEnd_, _len_).
          1. Let _newLen_ be max(_final_-_first_,0).
          1. Let _ctor_ be SpeciesConstructor(_O_, %SharedArrayBuffer%).
          1. ReturnIfAbrupt(_ctor_).
          1. Let _new_ be Construct(_ctor_, «newLen»).
          1. ReturnIfAbrupt(_new_).
          1. If _new_ does not have a [[SharedArrayBufferData]] internal slot, throw a ~TypeError~ exception.
          1. If SameValue(_new_, _O_) is true, throw a ~TypeError~ exception.
          1. If the value of _new_’s [[SharedArrayBufferByteLength]] internal slot &lt; _newLen_, throw a ~TypeError~ exception.
          1. Let _fromBuf_ be the value of _O_’s [[SharedArrayBufferData]] internal slot.
          1. Let _toBuf_ be the value of _new_’s [[SharedArrayBufferData]] internal slot.
          1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_).
          1. Return _new_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="SharedArrayBuffer_prototype_toString">
        <h1>SharedArrayBuffer.prototype[ @@toStringTag ]</h1>
        <p> The initial value of the @@toStringTag property is the String value `"SharedArrayBuffer"`.</p>

        <p>This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="SharedArrayBuffer_instances">
      <h1>Properties of the SharedArrayBuffer instances</h1>

      <p> SharedArrayBuffer instances inherit properties from the SharedArrayBuffer prototype object. SharedArrayBuffer instances each have a [[SharedArrayBufferData]] internal slot and a [[SharedArrayBufferByteLength]] internal slot. </p>

      <emu-note>
        <p> SharedArrayBuffer instances, unlike ArrayBuffer instances, are never detached. </p>
      </emu-note>
    </emu-clause>

  </emu-clause>
</emu-clause>

<emu-clause id="AtomicsObject">
  <h1>The Atomics Object</h1>
  
  <emu-clause id="AtomicsObjectValueProps">
    <h1>Value Properties of the Atomics Object</h1>
    <emu-clause id="Atomics.OK">
      <h1>Atomics.OK</h1>
      <p>The value 0.</p>
    </emu-clause>
    <emu-clause id="Atomics.NOTEQUAL">
      <h1>Atomics.NOTEQUAL</h1>
      <p>The value -1.</p>
    </emu-clause>
    <emu-clause id="Atomics.TIMEDOUT">
      <h1>Atomics.TIMEDOUT</h1>
      <p>The value -2.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="AtomicsObjectFunctionProps">
    <h1>Function Properties of the Atomics Object</h1>

    <p> In the algorithms below, the algorithm step 'With atomic access to (_buffer_, _indexedPosition_, _elementSize_)' means the following:</p>
    <ul>
      <li> If several agents are claiming atomic access to exactly the same _elementSize_ memory cells then these atomic sections are serialized, each agent executes all its dependent steps while the other agents are waiting
      <li> FIXME: Well-defined atomic sections are globally ordered
      <li> FIXME: It's possible to create ill-defined behavior with overlapping
      <li> FIXME: Conflicts are implementation dependent and can change over time (eg, moving from a spinlock to an atomic can change behavior)
    </ul>

    <p> In the algorithms below, the algorithm step 'Within the futex critical section' means the following:</p>
    <ul>
      <li> There is a critical section for the futex operations that is shared among all agents that can communicate through shared memory.
      <li> The phrase 'within the futex critical section' acquires that section exclusively; any return from the dependent statements releases the section.
    </ul>

    <emu-clause id="Atomics.ValidateSharedIntegerTypedArray" aoid="ValidateSharedIntegerTypedArray">
      <h1>Runtime semantics: ValidateSharedIntegerTypedArray(_ta_, [onlyInt32])</h1>
      <p> FIXME: This section probably belongs somewhere else </p>
      <emu-alg>
        1. If Type(_ta_) is not Object, throw a ~TypeError~ exception.
        1. Let _typeName_ be the value of _ta_'s [[TypedArrayName]] internal slot
        1. If _onlyInt32_ is ~true~ then
          1. If _typeName_ is not "Int32Array" then throw a ~TypeError~ exception
        1. Else
          1. If _typeName_ is not "Int8Array", "Uint8Array", "Int16Array", "Uint16Array", "Int32Array", or "Uint32Array" then throw a ~TypeError~ exception
        1. If _ta_ does not have a [[ViewedArrayBuffer]] internal slot, throw a ~TypeError~ exception.
        1. Let _buffer_ be the value of _ta_’s [[ViewedArrayBuffer]] internal slot.
        1. If Type(_buffer_) is not Object, throw a ~TypeError~ exception.
        1. If _buffer_ does not have a [[SharedArrayBufferData]] internal slot, throw a ~TypeError~ exception.
        1. Return _buffer_
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.ValidateAtomicAccess" aoid="ValidateAtomicAccess">
      <h1>Runtime semantics: ValidateAtomicAccess(_ta_, _index_)</h1>
      <P> FIXME: Flesh this out; the original spec uses ToLength here but it may be more complicated </P>
      <P> FIXME: This section probably belongs somewhere else </p>
      <emu-alg>
        1. If _index_ can be interpreted as a nonnegative index _i_ within _ta_ then return _i_.
        1. Throw a RangeError exception
      </emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.add">
      <h1>Atomics.add ( ta, index, value )</h1>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_ta_)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _ta_, _index_ )
        1. ReturnIfAbrupt(_i_)
        1. Let _v_ be ToNumber(_value_)
        1. ReturnIfAbrupt(_value_).
        1. Let _arrayTypeName_ be the value of _ta_'s [[TypedArrayName]] internal slot
        1. Let _elementSize_ be the Number value of the Element Size value specified in Table 49 for arrayTypeName.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for arrayTypeName.
        1. Let _offset_ be the value of _ta_’s [[ByteOffset]] internal slot.
        1. Let _indexedPosition_ be (_i_ * _elementSize_) + _offset_
        1. With atomic access to ( _buffer_, _indexedPosition_, _elementSize_ ), do:
          1. Let _r_ be the result of GetValueFromSharedBuffer( _buffer_, _indexedPosition_, _elementType_ )
          1. Compute: Let _w_ be _r_ + _v_
          1. Call SetValueInSharedBuffer( _buffer_, _indexedPosition_, _elementType_, _w_ )
        1. Return _r_
      </emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.and">
      <h1>Atomics.and ( ta, index, value )</h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let _w_ be _r_ &amp; _v_.</p>
    </emu-clause>
    
    <emu-clause id="Atomics.compareExchange">
      <h1>Atomics.compareExchange ( ta, index, expectedValue, replacementValue )</h1>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_ta_)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _ta_, _index_ )
        1. ReturnIfAbrupt(_i_)
        1. Let _expected_ be ToNumber(_expectedValue_)
        1. ReturnIfAbrupt(_expected_)
        1. Let _replacement_ be ToNumber(_replacedValue_)
        1. ReturnIfAbrupt(_replacement_)
        1. Let _arrayTypeName_ be the value of _ta_'s [[TypedArrayName]] internal slot
        1. Let _elementSize_ be the Number value of the Element Size value specified in Table 49 for arrayTypeName.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for arrayTypeName.
        1. Let _offset_ be the value of _ta_’s [[ByteOffset]] internal slot.
        1. Let _indexedPosition_ be (_i_ * _elementSize_) + _offset_
        1. With atomic access to ( _buffer_, _indexedPosition_, _elementType_ ), do:
          1. Let _r_ be the result of GetValueFromSharedBuffer( _buffer_, _indexedPosition_, _elementType_ )
          1. If _r_ equals _expected_ then:
            1. Call SetValueInSharedBuffer( _buffer_, _indexedPosition_, _elementType_, _replacement_ )
        1. Return _r_
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.exchange">
      <h1>Atomics.exchange ( ta, index, value )</h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let _w_ be _v_.</p>
    </emu-clause>

    <emu-clause id="Atomics.futexWait">
      <h1>Atomics.futexWait ( ta, index, value, timeout )</h1>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_ta_, ~true~)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _ta_, _index_ )
        1. ReturnIfAbrupt(_i_)
        1. Let _v_ be the result of ToInt32(_value_).
        1. ReturnIfAbrupt(_v_)
        1. If _timeout_ is not provided or is ~undefined~ then let _t_ be +Infinity.  Otherwise:
          1. Let _q_ be the result of ToNumber(_timeout_)
          1. If _q_ is NaN then let _t_ be +Infinity, otherwise let _t_ be max(0,_q_).
        1. Let _bufferVal_ be the value of the internal [[SharedArrayBufferData]] property of _buffer_.
        1. Let _G_ be SharedDataBlockID(_bufferVal_)
        1. Within the futex critical section do:
          1. Let _w_ be Atomics.load(_ta_, _i_)
          1. If _v_ does not equal _w_ then return the original value of ~Atomics.NOTEQUAL~.
          1. Record that the agent is waiting on (_G_, _i_), assigning it a wait ID that is the next available element from a monotonically increasing sequence of wait IDs for (_G_, _i_).
          1. Suspend the calling agent for up to _t_ milliseconds.
          1. (The agent wakes up.  It may wake up either because the timeout expired or because it was woken explicitly, and not for other reasons.  It does not wake up for any kind of event delivery.  If there are system-internal ways in which the agent may spuriously awake it must suspend again, without re-checking the value of i32a[x], until the timeout expires or it is woken explicitly.)
          1. Un-record that the agent is waiting on (_G_, _i_).
        1. If the suspension in 9(d) was broken by another agent with a call on ~Atomics.futexWake~ or ~Atomics.futexWakeOrRequeue~ then return the original value of ~Atomics.OK~.
        1. Return the original value of ~Atomics.TIMEDOUT~.
      </emu-alg>

      <P> FIXME: The data needed for waiting could be structured better so that we don't have to keep talking about "the wait ID of x" all over the place. </p>

      <emu-note>
        <p> The name "futex" comes from Linux, where it means "fast user-space mutex".  Linux has wait/wake system calls with names and functionality similar to what's defined here. The mechanism described here is however not Linux-dependent in any way. </p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.futexWake">
      <h1>Atomics.futexWake ( ta, index, count )</h1>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_ta_, ~true~)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _ta_, _index_ )
        1. ReturnIfAbrupt(_i_)
        1. Let _c_ be max(+0,ToInteger(_count_)).
        1. Let _bufferVal_ be the value of the internal [[SharedArrayBufferData]] property of _buffer_.
        1. Let _G_ be SharedDataBlockID(_bufferVal_)
        1. Let _n_ = 0
        1. Within the futex critical section do:
          1. Let _S_ be the list of agents waiting on (_G_,_i_) sorted in ascending wait ID order
          1. While _c_ &gt; 0 and _S_ is not the empty list:
            1. Let _W_ be the first agent in _S_
            1. Remove _W_ from the front of _S_
            1. Wake _W_
            1. Subtract 1 from _c_
            1. Add 1 to _n_
        1. Return _n_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.futexWakeOrRequeue">
      <h1>Atomics.futexWakeOrRequeue ( ta, index1, count, index2, value )</h1>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_ta_, ~true~)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _ta_, _index1_ )
        1. Let _c_ be max(+0,ToInteger(_count_))
        1. ReturnIfAbrupt(_i_)
        1. Let _j_ be ValidateAtomicAccess( _ta_, _index2_ )
        1. ReturnIfAbrupt(_j_)
        1. Let _v_ be ToInt32(_value_)
        1. Let _bufferVal_ be the value of the internal [[SharedArrayBufferData]] property of _buffer_
        1. Let _G_ be SharedDataBlockID(_bufferVal_)
        1. Let _n_ = 0
        1. Within the futex critical section do:
          1. Let _w_ be Atomics.load(_ta_, _i_)
          1. If _v_ does not equal _w_ then return the original value of ~Atomics.NOTEQUAL~
          1. Let _S_ be the list of agents waiting on (_G_, _i_) sorted in ascending wait ID order
          1. While _c_ &gt; 0 and _S_ is not the empty list:
            1. Let _W_ be the first agent in _S_
            1. Remove _W_ from the front of _S_
            1. Wake _W_
            1. Subtract 1 from _c_
            1. Add 1 to _n_
          1. While _S_ is not the empty list:
            1. Let _W_ be the first agent in _S_
            1. Remove _W_ from the front of _S_
            1. Assign _W_ a new wait ID that is the next available element from a monotonically increasing sequence of wait IDs for (_G_, _j_)
            1. Unrecord that _W_ is waiting on (_G_, _i_)
            1. Record that _W_ is waiting on (_G_, _j_)
        1. Return _n_.
      </emu-alg>        

      <emu-note>
        <p> Atomics.futexWaitOrRequeue is an optimization that helps programs avoid a "thundering herd" problem when many threads are woken and compete for a lock (as in a broadcast). </p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.isLockFree">
      <h1>Atomics.isLockFree ( size )</h1>

      <p> An atomic operation on a range of locations (_sab_, _offset_, _size_) is said to be _lock-free_ if the algorithm section of the operation that is labeled 'With atomic access to (_sab_, _offset_, _size_)' is implemented in a way that does not require a lock outside the specified data locations to be acquired. </p>

      <emu-alg>
        1. Let _n_ be ToInteger(_size_)
        1. ReturnIfAbrupt(_n_)
        1. If _n_ is not the initial value of the BYTES_PER_ELEMENT property of some TypedArray then return ~false~
        1. If an atomic operation (compareExchange, load, store, add, sub, and, or, xor, or exchange) on a datum of size _n_ bytes will be performed in a lock-free manner in the calling agent then return ~true~
        1. Return ~false~
      </emu-alg>

      <p>If Atomics.isLockFree(k) returns v in some agent then every subsequent invocation of Atomics.isLockFree(k) in that environment must return v.  Furthermore, any invocation of Atomics.isLockFree(k) in any other agent that can (assuming arbitrary code) reference (in the past, currently, or in the future) any of the same shared memory that the first environment references must also return v.</p>

      <emu-note>
        <p> Atomics.isLockFree is an optimization primitive. High-performance algorithms will use it to determine whether to use locks or atomic operations in critical sections.  If an atomic primitive is not lock-free then it is often more efficient for an algorithm to provide its own locking.</P>
      </emu-note>

      <emu-note>
        <p>The return value for a given argument is not necessarily a constant on a given piece of hardware, but also reflects implementation choices that can vary over time and across engines.  The specification requires that if a SharedArrayBuffer can be communicated from one agent to another even in principle, for unrestricted agent types (web workers, service workers, ...) and unrestricted communication channels (postMessage or other mechanisms that might exist), then the two agents must agree on the values returned from isLockFree.</p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.load">
      <h1>Atomics.load ( ta, index )</h1>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_ta_)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _ta_, _index_ )
        1. ReturnIfAbrupt(_i_)
        1. Let _arrayTypeName_ be the value of _ta_'s [[TypedArrayName]] internal slot
        1. Let _elementSize_ be the Number value of the Element Size value specified in Table 49 for arrayTypeName.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for arrayTypeName.
        1. Let _offset_ be the value of _ta_’s [[ByteOffset]] internal slot.
        1. Let _indexedPosition_ be (_i_ * _elementSize_) + _offset_
        1. With atomic access to ( _buffer_, _indexedPosition_, _elementSize_ ), do:
          1. Let _r_ be the result of GetValueFromSharedBuffer( _buffer_, _indexedPosition_, _elementType_ )
        1. Return _r_
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.or">
      <h1>Atomics.or ( ta, index, value )</h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let _w_ be _r_ | _v_.</p>
    </emu-clause>
    
    <emu-clause id="Atomics.store">
      <h1>Atomics.store ( ta, index, value )</h1>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_ta_)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _ta_, _index_ )
        1. ReturnIfAbrupt(_i_)
        1. Let _v_ be ToNumber(_value_)
        1. ReturnIfAbrupt(_v_)
        1. Let _arrayTypeName_ be the value of _ta_'s [[TypedArrayName]] internal slot
        1. Let _elementSize_ be the Number value of the Element Size value specified in Table 49 for arrayTypeName.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for arrayTypeName.
        1. Let _offset_ be the value of _ta_’s [[ByteOffset]] internal slot.
        1. Let _indexedPosition_ be (_i_ * _elementSize_) + _offset_
        1. With atomic access to ( _buffer_, _indexedPosition_, _elementSize_ ), do:
          1. Call SetValueInSharedBuffer( _buffer_, _indexedPosition_, _elementType_, _v_ )
        1. Return _v_
      </emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.sub">
      <h1>Atomics.sub ( ta, index, value )</h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let _w_ be _r_ - _v_.</p>
    </emu-clause>
    
    <emu-clause id="Atomics.xor">
      <h1>Atomics.xor ( ta, index, value )</h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let _w_ be _r_ ^ _v_.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

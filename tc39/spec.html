<!-- -*- indent-tabs-mode: nil -*-

     Process this file with ../format.sh to produce shmem.html.  See comments in that file.
-->
<!doctype html>
<meta charset="utf8">
<pre class=metadata>
  title: ECMAScript Shared Memory and Atomics
  stage: 2
  contributors: Mozilla, Inc.
</pre>
<script src="https://bterlson.github.io/ecmarkup/ecmarkup.js"></script>
<link rel="stylesheet" href="https://bterlson.github.io/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">

<p>Some algorithms and semantics in this proposal are presented as modifications to existing ES262 algorithms and semantics.  The base revision of ES262 for the modifications (here denoted "ES7") is currently f35248729043089b47ccf29e4c47559386f5f6fd (2016-06-29).  At the moment, ES7 (ES2016) section numbering differs from ES6 (ES2015) only for TypedArrays (section 22.2).</p>

<emu-intro id="intro">
<h1>Introduction</h1>

<p>This proposal adds a simple form of shared memory to ECMAScript.
Shared memory is being exposed in the form of a new SharedArrayBuffer
type; the existing TypedArray and DataView types are adapted in such a way
that they can be used to create views on shared memory.  The new
global Atomics object provides atomic operations on shared memory
locations, including operations that can be used to create blocking
synchronization primitives.  Though not a part of this specification,
we intend for the role of "threads" to be played by Web Workers in web
browser environments.<p>

<p>At this time the proposal adds only low-level primitives to
ECMAScript; we expect the developer community to put together
abstractions that are useful in specific domains.</p>

<p>The work has been driven by the following use cases: <p>

<ul>
  <li>Support for threaded code in programs written in other
  languages that are translated to asm.js or plain JS or a combination
  of the two, notably C and C++ but also other, safe, languages.

  <li>Support for hand-written JS or JS+asm.js that makes use of
  multiprocessing facilities for select tasks, such as image
  processing, asset management, or game AI.
</ul>

<p>The proposal makes only very basic assumptions about the required
hardware and should be broadly implementable with good performance.
Prototype implementations of the API are available in Firefox and in
Google Chrome.</p>

<p>This specification constitutes a restatement and formalization of
an earlier
work, <a href="https://github.com/tc39/ecmascript_sharedmem/blob/master/historical/Spec_JavaScriptSharedMemoryAtomicsandLocks.pdf">the
spec document for which</a> also contains additional rationale,
background information, discussions, implementation notes, and
comments.</p>

<p>Changelog:</p>
<ul>
  <li>2016-07-22 -- Editorial fixes.
  <li>2016-07-21 -- Replace [[SharedArrayBufferData]] and [[SharedArrayBufferByteLength]] with [[ArrayBufferData]] and [[ArrayBufferByteLength]]; remove specialization that was based on the removed properties and instead use type checks with IsSharedArrayBuffer in ArrayBuffer, SharedArrayBuffer, and Atomics methods; spec that Shared Data Blocks are distinguishable (by unspecified means) from regular Data Blocks and use this to defined IsSharedArrayBuffer.
  <li>2016-07-20 -- Editorial fix: clarify the operator passed to AtomicFetchOp.
  <li>2016-07-13 -- Editorial fixes.
  <li>2016-07-11 -- Rewrote the memory model section, which introduced separate access functions for shared memory, and caused many other changes.
  <li>2016-07-05 -- Rewrote (and shrunk) the informative Web Browser Embedding section so that it only addresses the requirements of this spec, not how HTML ought to evolve.
  <li>2016-07-05 -- Rephrased the wait/wake mutual exclusion in terms of critical sections named by (G,i), as the old specification was too strong.
  <li>2016-06-30 -- Algorithms that are modified relative to their ES262 forms include more context and are more clearly marked, and there's a defined ES262 base revision for those modifications.  Updated section references to reference that revision.
  <li>(Older changelog removed)
</ul>

</emu-intro>

<emu-clause id="Overview">
  <h1>Overview (<a href="https://tc39.github.io/ecma262/#sec-overview">ES7 4</a>)</h1>
  <emu-clause id="Overview.Overview">
    <h1>ECMAScript Overview (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-overview">ES7 4.2</a>)</h1>
    <p>In the third paragraph, include <b>SharedArrayBuffer</b> after <b>ArrayBuffer</b>.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="DataTypesValues">
  <h1>ECMAScript Data Types and Values (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">ES7 6</a>)</h1>

  <emu-clause id="DataTypesValues.LanguageTypes">
    <h1>ECMAScript Language Types (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-language-types">ES7 6.1</a>)</h1>
    <emu-clause id="DataTypesValues.LanguageTypes.Number">
      <h1>The Number Type (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-language-types-number-type">ES7 6.1.6</a>)</h1>
      <p>In the NOTE, include <b>SharedArrayBuffer</b> along with <b>ArrayBuffer</b>.</p>
    </emu-clause>
    <emu-clause id="DataTypesValues.LanguageTypes.Object">
      <h1>The Object Type (<a href="https://tc39.github.io/ecma262/#sec-object-type">ES7 6.1.7</a>)</h1>
      <emu-clause id="DataTypesValues.LanguageTypes.Object.Intrinsic">
        <h1>Well-Known Intrinsic Objects (<a href="https://tc39.github.io/ecma262/#sec-well-known-intrinsic-objects">ES7 6.1.7.4</a>)</h1>
        <p>In table 7, include rows for %Atomics%, %SharedArrayBuffer%, and %SharedArrayBufferPrototype% in the manner of the row for ArrayBuffer.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="DataTypesValues.SpecTypes">
    <h1>ECMAScript Specification Types (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-specification-types">ES7 6.2</a>)</h1>
    <emu-clause id="DataTypesValues.SpecTypes.DataBlocks">
      <h1>Data blocks (<a href="https://tc39.github.io/ecma262/#sec-data-blocks">ES7 6.2.6</a>)</h1>
      <p>Insert the following paragraph after the third:</p>

      <p>A data block that resides in memory that can be referenced from multiple agents concurrently is designated a <dfn>Shared Data Block</dfn>.  A Shared Data Block has an identity (for the purposes of equality testing Shared Data Block values) that is <em>address-free</em>: it is tied not to the virtual addresses the block is mapped to in any process, but to the set of locations in memory that the block represents.  Shared Data Blocks can also be distinguished from Data Blocks.</p>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes" aoid="CopyDataBlockBytes">
        <h1>CopyDataBlockBytes ( _toBlock_, _toIndex_, _fromBlock_, _fromIndex_, _count_ ) (<a href="https://tc39.github.io/ecma262/#sec-copydatablockbytes">ES7 6.2.6.2</a>)</h1>
        <p>This algorithm is modified as follows:</p>
        <p>When the abstract operation CopyDataBlockBytes is called, the following steps are taken:</p>
        <emu-alg>
          1. Assert: _fromBlock_ and _toBlock_ are distinct Data Block <ins>or Shared Data Block</ins> values.
          1. Assert: _fromIndex_, _toIndex_, and _count_ are integer values &ge; 0.
          1. Let _fromSize_ be the number of bytes in _fromBlock_.
          1. Assert: _fromIndex_+_count_ &le; _fromSize_.
          1. Let _toSize_ be the number of bytes in _toBlock_.
          1. Assert: _toIndex_+_count_ &le; _toSize_.
          1. Repeat, while _count_&gt;0
            1. <del>Set _toBlock_[_toIndex_] to the value of _fromBlock_[_fromIndex_].</del><br><ins>If _fromBlock_ is a Shared Data Block  then let _byte_ be NonAtomicRead(_fromBlock_, _fromIndex_, *false*, *1*), otherwise let _byte_ be _fromBlock_[_fromIndex_].</ins>
            1. <ins>If _toBlock_ is a Shared Data Block then perform NonAtomicWrite(_toBlock_, _toIndex_, *false*, *1*, _byte_), otherwise set _toBlock_[_toIndex_] to _byte_.</ins>
            1. Increment _toIndex_ and _fromIndex_ each by 1.
            1. Decrement _count_ by 1.
          1. Return NormalCompletion(~empty~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock" aoid="CreateSharedByteDataBlock">
        <h1>CreateSharedByteDataBlock( _size_ )</h1>
        <p>When the abstract operation CreateSharedByteDataBlock is called with integer argument size, the following steps are taken:</p>
        <emu-alg>
          1. Assert: _size_ >= 0.
          1. Let _db_ be a new Shared Data Block value consisting of _size_ bytes. If it is impossible to create such a Shared Data Block, throw a *RangeError* exception.
          1. Set all of the bytes of _db_ to 0 as if by calls to NonAtomicWrite(_db_, _i_, *false*, *1*, *0*) for each index _i_ in _db_.
          1. Return _db_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="ExecutableCodeAndContexts">
  <h1>Executable Code and Execution Contexts (<a href="https://tc39.github.io/ecma262/#sec-executable-code-and-execution-contexts">ES7 8</a>)</h1>
  <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues">

    <h1>Jobs and Job Queues (<a href="https://tc39.github.io/ecma262/#sec-jobs-and-job-queues">ES7 8.4</a>)</h1>
    <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues.Progress">
      <h1>Forward Progress Guarantees</h1>
      <p>The forward progress guarantee is provided by <a href="https://github.com/tc39/ecma262/pull/522">PR 522 on ES262</a>.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="ExecutableCodeAndContexts.AgentCluster">
    <h1>Agents (AMENDMENTS)</h1>

    <p>Add the following properties to the <dfn>Agent Record</dfn> (which is provided by <a href="https://github.com/tc39/ecma262/pull/522">PR 522 on ES262</a>):</p>

    <emu-table id="table-agent-record" caption="Agent Record Fields">
      <table>
        <tbody>
          <tr>
            <th>Field name</th>
            <th>Value</th>
            <th>Meaning</th>
         </tr>
          <tr>
            <td>[[Signifier]]</td>
            <td>A value that admits equality testing</td>
            <td>Uniquely identifies the agent within its agent cluster.</td>
         </tr>
          <tr>
            <td>[[IsLockFree1]]</td>
            <td>Boolean</td>
            <td>True if and only if atomic operations on one-byte values are lock-free.</td>
         </tr>
          <tr>
            <td>[[IsLockFree2]]</td>
            <td>Boolean</td>
            <td>True if and only if atomic operations on two-byte values are lock-free.</td>
         </tr>
       </tbody>
     </table>
    </emu-table>

    <p>Once the values of [[Signifier]], [[IsLockFree1]], and
    [[IsLockFree2]] have been observed by any agent in the agent
    cluster they cannot change.</p>

    <emu-note>
      <p>The values of [[IsLockFree1]] and [[IsLockFree2]] are not
        necessarily determined by the hardware, but may also reflect
        implementation choices that can vary over time and between
        ECMAScript implementations.</p>

      <p>There is no [[IsLockFree4]] property: 4-byte atomic
        operations are always lock-free.</p>

      <p>Formally, atomic operations are lock-free if, infinitely
        often, some atomic operation finishes in a finite number of
        program steps.  In practice, if an atomic operation is
        implemented with any type of lock the operation is not
        lock-free.  Lock-free does not imply wait-free: there is no
        upper bound on how many machine steps may be required to
        complete a lock-free atomic operation.</p>

      <p>That an atomic access of size <em>n</em> is lock-free does
        not imply anything about the (perceived) atomicity of
        non-atomic accesses of size <em>n</em>, specifically,
        non-atomic accesses may still be performed as a sequence of
        several separate memory accesses.  See the memory model
        section for details.</p>
    </emu-note>

  </emu-clause>

  <emu-clause id="ExecutableCodeAndContexts.AgentCluster">
    <h1>Agent Clusters (NEW)</h1>

    <p>An <em>agent cluster</em> is a maximal set of agents that can
      communicate by operating on shared memory.</p>

    <emu-note>
      <p>Programs within different agents may share memory by
        unspecified means.  At a minimum, the backing memory for
        SharedArrayBuffer objects can be shared among the agents in
        the cluster.</p>

      <p>There may be agents that can communicate by message passing
	that cannot share memory; they are never in the same
	cluster.</p>
    </emu-note>

    <p>Every agent belongs to exactly one agent cluster.</p>

    <emu-note>
      <p>The agents in a cluster need not all be alive at some
	particular point in time.  If agent <b>A</b> creates another
	agent <b>B</b>, after which <b>A</b> terminates and <b>B</b>
	creates agent <b>C</b>, the three agents are in the same
	cluster if <b>A</b> could share some memory with <b>B</b>
	and <b>B</b> could share some memory with <b>C</b>.</p>
    </emu-note>

    <p>All agents within a cluster must have the same value for
      the [[LittleEndian]] property in their respective Agent Records.</p>

    <emu-note>
      <p>If different agents within an agent cluster have different
        values of [[LittleEndian]] it becomes hard to use shared
        memory for multi-byte data.</p>
    </emu-note>

    <p>All agents within a cluster must have the same values for
      the [[IsLockFree1]] property in their respective Agent Records; similarly for
      the [[IsLockFree2]] property.</p>

    <p>All agents within a cluster must have different values for
      the [[Signifier]] property in their respective Agent Records.</p>

    <p>An agent cluster is a specification mechanism and need not correspond to
      any particular artefact of an ECMAScript implementation.</p>

    <p>An embedding may deactivate (stop forward progress) or
      activate (resume forward progress) an agent without the agent's
      knowledge or cooperation.  If the embedding does so, it must not
      leave some agents in the cluster active while other agents in
      the cluster are deactivated indefinitely.</p>

    <emu-note>
      <p>The purpose of the preceding restriction is to avoid a
        situation where an agent deadlocks or starves because another
        agent has been suspended.  For example, if a DOM SharedWorker
        shares memory with a regular worker, and the regular worker is
        suspended while it holds a lock (because the web page the
        regular worker is in is pushed into the window history), and
        the SharedWorker tries to acquire the lock, then the
        SharedWorker will be blocked until the regular worker wakes up
        again, if ever.  Meanwhile other workers trying to access the
        SharedWorker from other web pages will starve.</p>

      <p>The implication of the restriction is that it will not be
        possible to share memory between agents that don't belong to
        the same suspend/wake collective within the embedding.</p>
    </emu-note>

    <p>An embedding may terminate an agent without any of the agent's
      cluster's other agents' prior knowledge or cooperation.  If an
      agent is terminated not by programmatic action of its own or of
      another agent in the cluster but by forces external to the
      cluster, then the embedding must choose one of two strategies:
      Either terminate all the agents in the cluster, or provide
      reliable APIs that allow the agents in the cluster to coordinate
      so that at least one remaining member of the cluster will be
      able to detect the termination, with the termination data
      containing enough information to identify the agent that was
      terminated.</p>

    <emu-note>
      <p>Examples of that type of termination are: operating systems
        or users terminating agents that are running in separate
        processes; the embedding itself terminating an agent that is
        running in-process with the other agents when per-agent
        resource accounting indicates that the agent is runaway.</p>
    </emu-note>

    <emu-note>
      <p>This proposal additionally suggests (see later text) that if
        termination is signaled then the signal creates a
        synchronizes-with edge in the memory ordering.</p>
    </emu-note>

  </emu-clause> <!-- agent cluster -->

</emu-clause>

<!-- es6num="9" -->
<emu-clause id="sec-ordinary-and-exotic-objects-behaviours">
  <h1>Ordinary and Exotic Objects Behaviours (<a href="https://tc39.github.io/ecma262/#sec-ordinary-and-exotic-objects-behaviours">ES7 9</a>)</h1>

  <!-- es6num="9.4" -->
  <emu-clause id="sec-built-in-exotic-object-internal-methods-and-slots">
    <h1>Built-in Exotic Object Internal Methods and Slots (<a href="https://tc39.github.io/ecma262/#sec-built-in-exotic-object-internal-methods-and-slots">ES7 9.4</a>)</h1>

    <!-- es6num="9.4.5" -->
    <emu-clause id="sec-integer-indexed-exotic-objects">
      <h1>Integer Indexed Exotic Objects (<a href="https://tc39.github.io/ecma262/#sec-integer-indexed-exotic-objects">ES7 9.4.5</a>)</h1>

      <!-- es6num="9.4.5.8" -->
      <emu-clause id="sec-integerindexedelementget" aoid="IntegerIndexedElementGet">
        <h1>IntegerIndexedElementGet ( _O_, _index_ ) (<a href="https://tc39.github.io/ecma262/#sec-integerindexedelementget">ES7 9.4.5.8</a>)</h1>

        <p>This algorithm is modified as follows:</p>

        <p>In the call to GetValueFromBuffer, pass *true* as the fourth argument to indicate that the operation is performed on a TypedArray.</p>
      </emu-clause>

      <!-- es6num="9.4.5.9" -->
      <emu-clause id="sec-integerindexedelementset" aoid="IntegerIndexedElementSet">
        <h1>IntegerIndexedElementSet ( _O_, _index_, _value_ ) (<a href="https://tc39.github.io/ecma262/#sec-integerindexedelementset">ES7 9.4.5.9</a>)</h1>

        <p>This algorithm is modified as follows:</p>

        <p>In the call to SetValueInBuffer, pass *true* as the fourth argument to indicate that the operation is performed on a TypedArray.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="GlobalObject">
  <h1>The Global Object (<a href="https://tc39.github.io/ecma262/#sec-global-object">ES7 18</a>)</h1>
  <emu-clause id="GlobalObject.ConstructorProps">
    <h1>Constructor Properties of the Global Object (<a href="https://tc39.github.io/ecma262/#sec-constructor-properties-of-the-global-object">ES7 18.3</a>)</h1>
    <emu-clause id="GlobalObject.ConstructorProps.SharedArrayBuffer">
      <h1>SharedArrayBuffer</h1>
      <p>Add a new subsection for SharedArrayBuffer, pointing to the appropriate new section (below).</p>
    </emu-clause>
    <emu-clause id="GlobalObject.ConstructorProps.Atomics">
      <h1>Atomics</h1>
      <p>Add a new subsection for Atomics, pointing to the appropriate new section (below).</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<!--
AllocateTypedArray only allocates an ArrayBuffer if length is specified.
These call AllocateTypedArray with a specified length:
  TypedArrayFrom (twice)
   called from:
     %TypedArray% ( object )
     %TypedArray%.from ( source [,mapFn [,thisArg]] )
  %TypedArray%.of ( ...items )
  %TypedArray%.prototype.filter ( callbackFn [, thisArg] )
  %TypedArray%.prototype.slice ( start, end )
  %TypedArray% ()
  %TypedArray% (length)
  -->

<emu-clause id="IndexedCollections">
  <h1>Indexed Collections (<a href="https://tc39.github.io/ecma262/#sec-indexed-collections">ES7 22</a>)</h1>
  <emu-clause id="IndexedCollections.TypedArray">
    <h1>TypedArray Objects (<a href="https://tc39.github.io/ecma262/#sec-typedarray-objects">ES7 22.2</a>)</h1>

    <emu-clause id="IndexedCollections.TypedArray.prototype">
      <h1>Properties of the %TypedArrayPrototype% object (<a href="https://tc39.github.io/ecma262/#sec-properties-of-the-%typedarrayprototype%-object">ES7 22.2.3</a>)</h1>
      <emu-clause id="IndexedCollections.TypedArray.prototype.set">
        <h1>%TypedArray%.prototype.set( _overloaded_ [ , _offset_ ] ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-overloaded-offset">ES7 22.2.3.23</a>)</h1>

        <emu-clause id="IndexedCollections.TypedArray.prototype.setFromTypedArray">
          <h1>%TypedArray%.prototype.set( _array_ [, _offset_ ] ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-array-offset">ES7 22.2.3.23.1</a>)</h1>
          <p>This algorithm is modified as follows:</p>

          <p>In the call to SetValueInBuffer, pass *true* as the fourth argument to indicate that the operation is performed on a TypedArray.</p>
        </emu-clause>

        <emu-clause id="IndexedCollections.TypedArray.prototype.setFromTypedArray">
          <h1>%TypedArray%.prototype.set( _typedArray_ [, _offset_ ] ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-typedarray-offset">ES7 22.2.3.23.2</a>)</h1>
          <p>This algorithm is modified as follows:</p>
          <p>Sets multiple values in this _TypedArray_, reading the values from the _typedArray_ argument object. The optional _offset_ value indicates the first element index in this _TypedArray_ where values are written. If omitted, it is assumed to be 0.</p>
          <emu-alg>
            1. Assert: _typedArray_ has a [[TypedArrayName]] internal slot. If it does not, the definition in <emu-xref href="#sec-%typedarray%.prototype.set-array-offset"></emu-xref> applies.
            1. Let _target_ be the *this* value.
            1. If Type(_target_) is not Object, throw a *TypeError* exception.
            1. If _target_ does not have a [[TypedArrayName]] internal slot, throw a *TypeError* exception.
            1. Assert: _target_ has a [[ViewedArrayBuffer]] internal slot.
            1. Let _targetOffset_ be ? ToInteger(_offset_).
            1. If _targetOffset_ &lt; 0, throw a *RangeError* exception.
            1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].
            1. If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.
            1. Let _targetLength_ be _target_.[[ArrayLength]].
            1. Let _srcBuffer_ be _typedArray_.[[ViewedArrayBuffer]].
            1. If IsDetachedBuffer(_srcBuffer_) is *true*, throw a *TypeError* exception.
            1. Let _targetName_ be the String value of _target_.[[TypedArrayName]].
            1. Let _targetType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _targetName_.
            1. Let _targetElementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _targetName_.
            1. Let _targetByteOffset_ be _target_.[[ByteOffset]].
            1. Let _srcName_ be the String value of _typedArray_.[[TypedArrayName]].
            1. Let _srcType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _srcName_.
            1. Let _srcElementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _srcName_.
            1. Let _srcLength_ be _typedArray_.[[ArrayLength]].
            1. Let _srcByteOffset_ be _typedArray_.[[ByteOffset]].
            1. If _srcLength_ + _targetOffset_ &gt; _targetLength_, throw a *RangeError* exception.
            1. <ins>If both IsSharedArrayBuffer(_srcBuffer_) and IsSharedArrayBuffer(_targetBuffer_) are *true*, then let _same_ be *true* if _srcBuffer_.[[ArrayBufferData]] equals _targetBuffer_.[[ArrayBufferData]]; otherwise let _same_ be SameValue(_srcBuffer_, _targetBuffer_).</ins>
            1. <del>If SameValue(_srcBuffer_, _targetBuffer_)</del> <ins>_same_</ins> is *true*, then
              1. Let _srcBuffer_ be ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, _srcLength_, %ArrayBuffer%).
              1. NOTE: %ArrayBuffer% is used to clone _srcBuffer_ because is it known to not have any observable side-effects.
              1. Let _srcByteIndex_ be 0.
            1. Else, let _srcByteIndex_ be _srcByteOffset_.
            1. Let _targetByteIndex_ be _targetOffset_ &times; _targetElementSize_ + _targetByteOffset_.
            1. Let _limit_ be _targetByteIndex_ + _targetElementSize_ &times; _srcLength_.
            1. If SameValue(_srcType_, _targetType_) is *true*, then
              1. NOTE: If _srcType_ and _targetType_ are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.
              1. Repeat, while _targetByteIndex_ &lt; _limit_
                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, `"Uint8"`, <ins>*true*</ins>).
                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, `"Uint8"`, <ins>*true*</ins>, _value_).
                1. ...
            1. Else,
              1. Repeat, while _targetByteIndex_ &lt; _limit_
                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, _srcType_, <ins>*true*</ins>).
                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, <ins>*true*</ins>, _value_).
                1. ...
            1. Return *undefined*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="IndexedCollections.TypedArray.prototype.slice">
          <h1>%TypedArray%.prototype.slice( _start_, _end_ ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice">ES7 22.2.3.24</a>)</h1>
          <p>This algorithm is modified as follows:</p>

          <p>In the calls to GetValueFromBuffer and SetValueInBuffer, pass *true* as the fourth argument to indicate that the operations are
            performed on a TypedArray.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="IndexedCollections.TypedArray.constructors">
      <h1>The %TypedArray% constructors (<a href="https://tc39.github.io/ecma262/#sec-typedarray-constructors">ES7 22.2.4</a>)</h1>

      <!-- es6num="22.2.1.3" -->
      <emu-clause id="sec-typedarray-typedarray">
        <h1>_TypedArray_ ( _typedArray_ ) (<a href="https://tc39.github.io/ecma262/#sec-typedarray-typedarray">ES7 22.2.4.3</a>)</h1>

        <p>This algorithm is modified as follows:</p>

        <p>In the calls to GetValueFromBuffer and SetValueInBuffer, pass *true* as the fourth argument to indicate that the operations are performed on a TypedArray.</p>
      </emu-clause>

    </emu-clause> <!-- intrinsic object -->

  </emu-clause>
</emu-clause>

<emu-clause id="StructuredData">
  <h1>Structured Data (<a href="https://tc39.github.io/ecma262/#sec-structured-data">ES7 24</a>)</h1>

  <emu-clause id="StructuredData.ArrayBuffer">
    <h1>ArrayBuffer Objects (<a href="https://tc39.github.io/ecma262/#sec-arraybuffer-objects">ES7 24.1</a>)</h1>

    <emu-clause id="StructuredData.ArrayBuffer.abstract">
      <h1>Abstract Operations for ArrayBuffer (<a href="https://tc39.github.io/ecma262/#sec-abstract-operations-for-arraybuffer-objects">ES7 24.1.1</a>)</h1>

      <emu-clause id="sec-detacharraybuffer" aoid="DetachArrayBuffer">
        <h1>DetachArrayBuffer ( _arrayBuffer_ ) (<a href="https://tc39.github.io/ecma262/#sec-detacharraybuffer">ES7 24.1.1.3</a>)</h1>
        <p>This algorithm is modified as follows:</p>
        <p>The abstract operation DetachArrayBuffer with argument _arrayBuffer_ performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_arrayBuffer_) is Object and it has [[ArrayBufferData]] and [[ArrayBufferByteLength]] internal slots.
          1. <ins>Assert: IsSharedArrayBuffer(_arrayBuffer_) is *false*.</ins>
          1. ...
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" aoid="GetValueFromBuffer">
        <h1>GetValueFromBuffer( _arrayBuffer_, _byteIndex_, _type_, <ins>_isTypedArray_,</ins> _isLittleEndian_ ) (<a href="https://tc39.github.io/ecma262/#sec-getvaluefrombuffer">ES7 24.1.1.5</a>)</h1>
        <p>This algorithm is modified as follows:</p>
        <p>The abstract operation GetValueFromBuffer takes <del>four</del><ins>five</ins> parameters, an ArrayBuffer <ins>or SharedArrayBuffer</ins> _arrayBuffer_, an integer _byteIndex_, a String _type_, <ins>a Boolean _isTypedArray_,</ins> and optionally a Boolean _isLittleEndian_. This operation performs the following steps:</p>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Assert: _byteIndex_ is an integer value &ge; 0.
          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
          1. <del>Let _rawValue_ be a List of _elementSize_ containing, in order, the _elementSize_ sequence of bytes starting with _block_[_byteIndex_].</del><br><ins>If IsSharedArrayBuffer(_arrayBuffer_) is *true* then:</ins>
            1. <ins>Let _accessAtomic_ be *true* if _isTypedArray_ is *true* and _type_ is `"Int8"`, `"Uint8"`, `"Int16"`, `"Uint16"`, `"Int32"`, or `"Uint32"`, otherwise *false*.</ins>
            1. <ins>Let _rawValue_ be NonAtomicRead(_block_, _byteIndex_, _accessAtomic_, _elementSize_).</ins>
            1. <ins>Assert: _rawValue_ is a List of size _elementSize_.</ins>
          1. <ins>Else, let _rawValue_ be a List containing, in order, the _elementSize_ sequence of bytes starting with _block_[_byteIndex_].</ins>
          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to <del>either *true* or *false*. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the SetValueInBuffer abstract operation</del> <ins>the value of the [[LittleEndian]] internal slot of the surrounding agent's Agent Record</ins>.
          1. ...
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.SetValueInBuffer" aoid="SetValueInBuffer">
        <h1>SetValueInBuffer( _arrayBuffer_, _byteIndex_, _type_, <ins>_isTypedArray_,</ins> _value_, _isLittleEndian_ ) (<a href="https://tc39.github.io/ecma262/#sec-setvalueinbuffer">ES7 24.1.1.6</a>)</h1>
        <p>This algorithm is modified as follows:</p>
        <p>The abstract operation SetValueInBuffer takes <del>five</del><ins>six</ins> parameters, an ArrayBuffer <ins>or SharedArrayBuffer</ins> _arrayBuffer_, an integer _byteIndex_, a String _type_, <ins>a Boolean _isTypedArray_,</ins> a Number _value_, and optionally a Boolean _isLittleEndian_. This operation performs the following steps:</p>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Assert: _byteIndex_ is an integer value &ge; 0.
          1. Assert: Type(_value_) is Number.
          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Assert: _block_ is not *undefined*.
          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to <del>either *true* or *false*. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the GetValueFromBuffer abstract operation</del> <ins>the value of the [[LittleEndian]] internal slot of the surrounding agent's Agent Record</ins>.
          1. If _type_ is `"Float32"`, then
            1. ...
          1. Else if _type_ is `"Float64"`, then
            1. ...
          1. Else,
            1. ...
          1. <del>Store the individual bytes of _rawBytes_ into _block_, in order, starting at _block_[_byteIndex_].</del><br><ins>If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then:</ins>
            1. <ins>Let _accessAtomic_ be *true* if _isTypedArray_ is *true* and _type_ is `"Int8"`, `"Uint8"`, `"Int16"`, `"Uint16"`, `"Int32"`, or `"Uint32"`, otherwise *false*.</ins>
            1. <ins>Perform NonAtomicWrite(_block_, _byteIndex_, _accessAtomic_, _elementSize_, _rawBytes_).</ins>
          1. <ins>Else, Store the individual bytes of _rawBytes_ into _block_, in order, starting at _block_[_byteIndex_].</ins>
          1. Return NormalCompletion(*undefined*).
        </emu-alg>
      </emu-clause>

    </emu-clause> <!-- abstract -->

    <emu-clause id="sec-properties-of-the-arraybuffer-prototype-object">
      <h1>Properties of the ArrayBuffer Prototype Object (<a href="https://tc39.github.io/ecma262/#sec-properties-of-the-arraybuffer-prototype-object">ES7 24.1.4</a>)</h1>

      <emu-clause id="sec-get-arraybuffer.prototype.bytelength">
        <h1>get ArrayBuffer.prototype.byteLength (<a href="https://tc39.github.io/ecma262/#sec-get-arraybuffer.prototype.bytelength">ES7 24.1.4.1</a>)</h1>
        <p>This algorithm is modified as follows:</p>
        <p>`ArrayBuffer.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. If _O_ does not have an [[ArrayBufferData]] internal slot, throw a *TypeError* exception.
          1. <ins>If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.</ins>
          1. ...
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.slice">
        <h1>ArrayBuffer.prototype.slice ( _start_, _end_ ) (<a href="https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice">ES7 24.1.4.3</a>)</h1>
        <p>This algorithm is modified as follows:</p>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. If _O_ does not have an [[ArrayBufferData]] internal slot, throw a *TypeError* exception.
          1. <ins>If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.</ins>
          1. ...
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause> <!-- ArrayBuffer -->

  <emu-clause id="StructuredData.DataView">
    <h1>DataView Objects (<a href="https://tc39.github.io/ecma262/#sec-dataview-objects">ES7 24.2</a>)</h1>

    <!-- es6num="24.2.1" -->
    <emu-clause id="sec-abstract-operations-for-dataview-objects">
      <h1>Abstract Operations For DataView Objects (<a href="https://tc39.github.io/ecma262/#sec-abstract-operations-for-dataview-objects">ES7 24.2.1</a>)</h1>

      <!-- es6num="24.2.1.1" -->
      <emu-clause id="sec-getviewvalue" aoid="GetViewValue">
        <h1>GetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_ ) (<a href="https://tc39.github.io/ecma262/#sec-getviewvalue">ES7 24.2.1.1</a>)</h1>
        <p>This algorithm is modified as follows:</p>

        <p>In the call to GetValueFromBuffer, pass *false* as the fourth argument to indicate that the operation is performed on a DataView.</p>
      </emu-clause>

      <!-- es6num="24.2.1.2" -->
      <emu-clause id="sec-setviewvalue" aoid="SetViewValue">
        <h1>SetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_, _value_ ) (<a href="https://tc39.github.io/ecma262/#sec-setviewvalue">ES7 24.2.1.2</a>)</h1>
        <p>This algorithm is modified as follows:</p>

        <p>In the call to SetValueInBuffer, pass *false* as the fourth argument to indicate that the operation is performed on a DataView.</p>
      </emu-clause>

    </emu-clause>
  </emu-clause> <!-- DataView -->

  <emu-clause id="StructuredData.SharedArrayBuffer">
    <h1>SharedArrayBuffer Objects</h1>

    <emu-clause id="StructuredData.SharedArrayBuffer.abstract">
      <h1>Abstract Operations for SharedArrayBuffer</h1>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer">
        <h1>AllocateSharedArrayBuffer( _constructor_, _byteLength_ )</h1>
        <p>The abstract operation AllocateSharedArrayBuffer with arguments _constructor_ and _byteLength_ is used to create a SharedArrayBuffer object. It performs the following steps:</p>

        <emu-alg>
          1. Let _obj_ be ? OrdinaryCreateFromConstructor(constructor, "%SharedArrayBufferPrototype%", «‍[[ArrayBufferData]], [[ArrayBufferByteLength]]» ).
          1. Assert: _byteLength_ is a nonnegative integer.
          1. Let _block_ be ? CreateSharedByteDataBlock(_byteLength_).
          1. Set _obj_.[[ArrayBufferData]] to _block_.
          1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer" aoid="IsSharedArrayBuffer">
        <h1>IsSharedArrayBuffer( _obj_ )</h1>
        <p>IsSharedArrayBuffer tests whether an object that is an ArrayBuffer, a SharedArrayBuffer, or a subtype of either is a SharedArrayBuffer or a subtype of it.  It performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_obj_) is Object and it has an [[ArrayBufferData]] internal slot.
          1. Let _bufferData_ be _obj_.[[ArrayBufferData]].
          1. If _bufferData_ is *null* or *undefined* then return *false*.
          1. If _bufferData_ is a Data Block then return *false*.
          1. Assert: _bufferData_ is a Shared Data Block.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor">
      <h1>The SharedArrayBuffer Constructor</h1>
      <p>The SharedArrayBuffer constructor is the %SharedArrayBuffer% intrinsic object and the initial value of the `SharedArrayBuffer` property of the global object. When called as a constructor it creates and initializes a new SharedArrayBuffer object.  The SharedArrayBuffer constructor is not intended to be called as a function and will throw an exception when called in that manner.</p>

      <p>The SharedArrayBuffer constructor is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified SharedArrayBuffer behaviour must include a `super` call to the SharedArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support the `SharedArrayBuffer.prototype` built-in methods.</p>

      <emu-note>
        <p>Unlike an ArrayBuffer, a SharedArrayBuffer cannot become detached, and its internal [[ArrayBufferData]] slot is never *null* or *undefined*.</p>
      </emu-note>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.withLength">
        <h1>SharedArrayBuffer( _length_ )</h1>
        <p>SharedArrayBuffer called with argument _length_ performs the following steps:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _numberLength_ be ? ToNumber(_length_).
          1. Let _byteLength_ be ToLength(_numberLength_).
          1. If SameValueZero(_numberLength_, _byteLength_) is *false*, throw a *RangeError* exception.
          1. Return AllocateSharedArrayBuffer(NewTarget, _byteLength_).
        </emu-alg>
      </emu-clause>
    </emu-clause> <!-- constructor -->

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties">
      <h1>Properties of the SharedArrayBuffer constructor</h1>

      <p>The value of the [[Prototype]] internal slot of the SharedArrayBuffer constructor is the intrinsic object %FunctionPrototype% (q.v.).</p>

      <p>Besides its `length` property (whose value is 1), the SharedArrayBuffer constructor has the following properties:</p>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.prototype">
        <h1>SharedArrayBuffer.prototype</h1>
        <p>The initial value of SharedArrayBuffer.prototype is the intrinsic object %SharedArrayBufferPrototype% (q.v.).</P>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.get_species">
        <h1>get SharedArrayBuffer [ @@species ]</h1>
        <p>`SharedArrayBuffer[@@species]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the name property of this function is "`get [Symbol.species]`".</p>
      </emu-clause>
    </emu-clause> <!-- properties -->

    <emu-clause id="StructuredData.SharedArrayBuffer.prototype">
      <h1>Properties of the SharedArrayBuffer prototype object</h1>

      <p>The SharedArrayBuffer prototype object is the intrinsic object %SharedArrayBufferPrototype%. The value of the [[Prototype]] internal slot of the SharedArrayBuffer prototype object is the intrinsic object %ObjectPrototype% (19.1.3). The SharedArrayBuffer prototype object is an ordinary object. It does not have an [[ArrayBufferData]] or [[ArrayBufferByteLength]] internal slot.</p>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.get_byteLength">
        <h1>get SharedArrayBuffer.prototype.byteLength</h1>

        <p>SharedArrayBuffer.prototype.byteLength is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>

        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. If _O_ does not have a [[ArrayBufferData]] internal slot, throw a *TypeError* exception.
          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
          1. Let _length_ be _O_.[[ArrayBufferByteLength]].
          1. Return _length_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.constructor">
        <h1>SharedArrayBuffer.prototype.constructor</h1>
        <p>The initial value of `SharedArrayBuffer.prototype.constructor` is the intrinsic object %SharedArrayBuffer%.</p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.slice">
        <h1>SharedArrayBuffer.prototype.slice( _start_, _end_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. If _O_ does not have an [[ArrayBufferData]] internal slot, throw a *TypeError* exception.
          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
          1. Let _len_ be _O_.[[ArrayBufferByteLength]].
          1. Let _relativeStart_ be ? ToInteger(_start_).
          1. If _relativeStart_ &lt; 0, let first be max((_len_ + _relativeStart_), 0); else let first be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToInteger(_end_).
          1. If _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_), 0); else let _final_ be min(_relativeEnd_, _len_).
          1. Let _newLen_ be max(_final_ - _first_, 0).
          1. Let _ctor_ be ? SpeciesConstructor(_O_, %SharedArrayBuffer%).
          1. Let _new_ be ? Construct(_ctor_, «newLen»).
          1. If _new_ does not have an [[ArrayBufferData]] internal slot, throw a *TypeError* exception.
          1. If SameValue(_new_, _O_) is *true*, throw a *TypeError* exception.
          1. If _new_.[[ArrayBufferByteLength]] &lt; _newLen_, throw a *TypeError* exception.
          1. Let _fromBuf_ be _O_.[[ArrayBufferData]].
          1. Let _toBuf_ be _new_.[[ArrayBufferData]].
          1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_).
          1. Return _new_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.toString">
        <h1>SharedArrayBuffer.prototype[ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"SharedArrayBuffer"`.</p>

        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause> <!-- prototype -->

    <emu-clause id="StructuredData.SharedArrayBuffer.instances">
      <h1>Properties of the SharedArrayBuffer instances</h1>

      <p>SharedArrayBuffer instances inherit properties from the SharedArrayBuffer prototype object. SharedArrayBuffer instances each have an [[ArrayBufferData]] internal slot and a [[ArrayBufferByteLength]] internal slot.</p>

      <emu-note>
        <p>SharedArrayBuffer instances, unlike ArrayBuffer instances, are never detached.</p>
      </emu-note>
    </emu-clause> <!-- instances -->

  </emu-clause> <!-- SharedArrayBuffer -->
</emu-clause> <!-- Structured data -->

<emu-clause id="AtomicsObject">
  <h1>The Atomics Object</h1>

  <p>The Atomics object is the <dfn>%Atomics%</dfn> intrinsic object and the initial value of the `Atomics` property of the global object. The Atomics object is a single ordinary object.</p>
  <p>The Atomics object provides functions that operate indivisibly (atomically) on shared memory array cells as well as functions that let agents wait for and dispatch primitive events.  When used with discipline, the Atomics functions allow multi-agent programs that communicate through shared memory to execute in a well-understood order even on parallel CPUs.  The rules that govern shared-memory communication are provided by the <dfn>memory model</dfn>, defined below.</p>

  <p>The value of the [[Prototype]] internal slot of the Atomics object is the intrinsic object %ObjectPrototype%.</p>

  <p>The Atomics object is not a function object. It does not have a [[Construct]] internal method; it is not possible to use the Atomics object as a constructor with the `new` operator. The Atomics object also does not have a [[Call]] internal method; it is not possible to invoke the Atomics object as a function.</p>

  <emu-clause id="AtomicsObjectFunctionProps.semantics">
    <h1>Runtime semantics</h1>

    <emu-clause id="AtomicsObject.MemoryModel">
      <h1>Memory model</h1>

      <p>The memory model determines when a particular read from shared memory may observe a particular write to shared memory.  Programs <em>synchronize</em> to ensure that reads and writes to shared memory happen in a meaningful order.  Synchronization happens chiefly by means of <em>atomic accesses</em> to shared memory wherein an atomic read observes the value written by an atomic write.</p>

      <p>ECMAScript shared memory obeys very weak type discipline, in that the byte array of a Shared Data Block can be aliased by TypedArrays of different types and accessed without natural alignment via DataViews, and also in that atomic accesses are applied to cells that are also accessed non-atomically.  For atomic accesses to be useful for synchronization they must not be interfered with by incompatible atomic accesses or by non-atomic accesses, and this specification therefore describes the conditions under which memory accesses interfere (in an execution) as well as the observable effects of interfering and non-interfering accesses.</p>

      <p>Non-interfering atomic accesses (later called <em>viable</em>) are executed in a well-defined order, and that order will allow programmers to reason about program synchronization, causality, and data races in a conventional way.</p>

      <emu-note>
        <p>(Programming advice)  As a rule of thumb, if the program accesses locations used for synchronization only with atomic operations and always with the same data width, then its atomic operations will be non-interfering.  The program can safely initialize the memory for the atomic locations using non-atomic operations so long as other synchronization in the program is used to ensure that initialization is finished before the program uses the memory for synchronization.</p>
      </emu-note>

      <emu-clause id="AtomicsObjectFundamentals">
        <h1>Fundamentals</h1>

        <p>Shared memory access is always performed by designated <dfn>memory operations</dfn>: the <dfn>atomic operations</dfn> AtomicRead, AtomicWrite, AtomicReadModifyWrite, and AtomicCompareExchange, and the <dfn>non-atomic operations</dfn> NonAtomicRead and NonAtomicWrite.  The memory operations never perform non-shared-memory access.</p>

        <p>The <em>access range</em> of a memory operation comprises the memory cells read or written by the operation.  These cells are always consecutive and within a single Shared Data Block.</p>

        <p>An atomic operation to some access range is <dfn>viable</dfn> (in an execution) only if all other memory operations that intersect with that access range while the atomic operation is being performed are atomic operations on the same access range, in a manner that is made precise in the following.</p>

        <emu-note>
          <p>(Spec draft note)</p>

          <p>Below, we provide a precise operational definition of viability that is based on transactions on a shared state; each memory operation has distinct start and end points, allowing us to discuss interference and to state clearly when an atomic operation is viable.</p>

          <p>The eventual purpose here is to define the synchronization order of an execution, which is a total order of the viable atomic operations of the execution.  In selecting the viable atomic operations we have to consider the following interacting problems:</p>

          <ul>
            <li> <b>Cells that are not exclusively atomic:</b> Instead of having typed atomic cells that are disjoint from non-atomic cells, we allow atomic and non-atomic operations to operate on the same cells, and it is possible to have simultaneous atomic and non-atomic operations on the same cell.

            <li> <b>Aliasing:</b> The TypedArray system allows one-byte, two-byte, and four-byte cells to overlap, and it is possible to have simultaneous memory operations on (say) a two-byte cell and the four-byte cell it aliases.

            <li> <b>Non-atomic initialization of memory:</b> In practice, programs translated from C, and from C++ with low-level atomics, will assume that it's legal to perform an atomic read from memory that was initialized with non-atomic writes, so long as the read is properly ordered after the writes by some other mechanism.

            <li> <b>Lock-free and non-lock-free atomics:</b> Lock-free and non-lock-free atomics do not use compatible mutual exclusion mechanisms, so even if hardware can be relied on to properly order different-sized lock-free atomic operations on aliased memory, it may not be counted on to also order lock-free and non-lock-free atomic operations on aliased memory.
          </ul>

          <p>In the semantics, the difference between lock-free and non-lock free is not visible, but some of the choices in the semantics are a consequence of having to deal with both implementation strategies.</p>

          <p>For example, suppose an eight-byte non-lock-free atomic write operation E attempts to interact with the memory system at the same time as a four-byte lock-free atomic write operation F, and that the access ranges overlap.  (We don't have eight-byte atomics at present but we may have them in the future, and there are 32-bit platforms, such as MIPS, that do not have 64-bit atomics.)  E acquires a lock, then writes the data bytes in some arbitrary order, then releases the lock.  While E holds the lock, F interacts directly with the memory system to write its four bytes as a unit.  The result may easily be that some of the bytes written for E are written before the four bytes of F, and some after.  As a result, the bytes in memory at the location of F may be a jumble of the two values, contrary to the desire that atomic operations execute atomically.</p>

          <p>(In the case of a non-lock-free atomic in a practical implementation, the lock and unlock operations may themselves not be atomic operations in the sense used here; the only requirement is that the combination of the lock and the unlock should enter into the global atomic order on behalf of the non-lock-free atomic access.)</p>

          <p>The idea of viability is therefore to describe conditions under which the implementation of atomic operations <em>need not concern</em> itself with the problems listed above, ie, we do not wish to order the operations in the example above, but rather to make it plain that there are no atomicity or ordering guarantees when the atomic operations are non-viable.</p>

          <p>Ours is a lightweight notion of viability in that it is strictly per atomic operation.  If what is syntactically a single atomic operation in the program is executed more than once, the operation can be viable in one case and non-viable in another.  It is also per execution: even if two programs execute the same atomic operations in the same order, an operation may be viable in one execution and not in another.  We also do not consider the provenance of the bytes read by an atomic read -- they could have been written by an atomic write to the access range, an atomic write to a larger access range, a non-atomic write, or a combination of those.  A stronger notion of viability could require a viable atomic read to see only a value that was written by a single atomic write to the same access range (but would then need to add some mechanism for dealing with non-atomic initializing writes).</p>

          <p>The term "viable" is used in preference to e.g. "non-racy" since we want to preserve the term "data race" for the conventional notion of operations unordered by the happens-before relation, see later.</p>
        </emu-note>

        <p>Inter-agent communication actions that are not memory operations (such as Atomics.wake and Atomics.wait, or host-specific communication actions) are in the following considered to be memory operations, with an AtomicWrite (to some hidden location in shared memory, with an arbitrary value) occuring as part of the action that sends a communication and an AtomicRead (to the same location) occuring as part of the action that receives a communication.  These synthesized atomic operations are viable, by construction.</p>

        <emu-note>
          <p>Examples of host-specific inter-agent communication actions are: sending a SharedArrayBuffer from one agent and receiving it in another (e.g., by `postMessage` in a web browser), starting and stopping agents, and communicating within the agent cluster via channels other than shared memory.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="AtomicsObjectFormalization">
        <h1>Formalization framework</h1>

        <p>We use the following semantic data structures to determine viability of atomic operations and to express the ordering of viable atomic operations.</p>

        <p>The memory system for the agent cluster comprises a byte-addressable shared memory and a critical section (the <dfn>Memory Critical Section</dfn>) that protects a generator of timestamps and a transaction set.  The critical section is a specification device that exists outside the program-visible shared memory; it does not have effects beyond mutual exclusion.</p>

        <p>The semantic operations BeginAtomic, EndAtomic, BeginNonAtomic, and EndNonAtomic operate on the memory system and denote the start and end of atomic and non-atomic operations, respectively.  The memory operations are defined in terms of these abstract operations and of the memory access primitives ReadSharedMemory and WriteSharedMemory.</p>

        <p>A <dfn>transaction</dfn> on shared memory is a quintuple (_id_, _op_, _block_, _byteIndex_, _elementSize_).  The transaction set stores transactions.  The _id_ is a value from the stream of timestamps, or a sentinel.  The _op_ is a string, denoting the operation. An <dfn>atomic transaction</dfn> is a whose operation is `"Atomic"` or `"Invalid"`. A <dfn>non-atomic transaction</dfn> is one whose operation is `"Read"` or `"Write"`. *InvalidTimestamp* is a timestamp value that does not mach any value obtained from the timestamp stream.  Additionally, *InvalidBlock* is a Shared Data Block value that is not confused with any actual data block.</p>

        <p>The initial value of the transaction set is the empty set. To <em>invalidate</em> the transaction set for atomics means for each atomic transaction (_id_, _op_, _block_, _byteIndex_, _elementSize_) in the transaction set, replace it with a transaction (_id_, `"Invalid"`, _block_, _byteIndex_, _elementSize_).

        <p>Two memory transactions (_x_, _opx_, _block1_, _byteIndex1_, _elementSize1_) and (_y_, _opy_, _block2_, _byteIndex2_, _elementSize2_) are said to <dfn>overlap</dfn> if _block1_ and _block2_ are the same, and the sequence [_byteIndex1_, _byteIndex1_+1, ..., _byteIndex1_+_elementSize1_-1] overlaps with but is not equal to the sequence [_byteIndex2_, _byteIndex2_+1, ..., _byteIndex2_+_elementSize2_-1].  Two transactions are said to <dfn>match</dfn> if their _block_, _byteIndex_, and _elementSize_ fields are pairwise equal.</p>

        <p>Two memory operations that overlap or match are said to <dfn>conflict</dfn> if one operation's Begin step happens between the other's Begin and End steps (as determined by the order they enter the Memory Critical Section).  A memory operation A is said to <dfn>cover</dfn> another operation B if A's Begin step happens before B's Begin step and B's End step happens before A's End step.</p>

        <p>BeginAtomic, EndAtomic, BeginNonAtomic, and EndNonAtomic implement a state machine whose state is either either Clear, Atomic, or Invalid, with Clear the initial state. The machine is in the Clear state when there are no atomic transaction in the set; the Atomic state when there is exactly one atomic transaction in the set and it has an operation of `"Atomic"`; the Invalid state when there is an atomic transaction in the set and it has an operation of `"Invalid"`. When all atomic operations are viable, the machine alternates between Clear and Atomic states, but an event that makes an atomic operation non-viable will move the machine into an Invalid state. The machine transitions out of the Invalid state when all atomic events whose atomic transactions conflict with the invalidating event's atomic transaction have executed their End operations</p>

        <emu-note>
          <p>The state machine is conservative in that, when it is in the Atomic state, an overlapping (non-matching) BeginAtomic will move the machine into the Invalid state even if both atomic operations are reads.  This is deemed acceptable as the utility of allowing non-matching reading atomics to be viable is questionable.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="AtomicsObjectTransformations">
        <h1>Program transformations</h1>
      
        <p>Program transformations (by a compiler or the hardware) must not reorder an agent's atomic operations with its non-atomic operations, nor reorder its atomic operations with each other.</p>

        <emu-note>
          <p>In practice, the prohibition on reorderings forces a compiler to assume that every atomic operation is viable, which it would usually have to assume in the absence of inter-agent program analysis.</p>

          <p>Most intra-agent semantics-preserving program transformations remain valid so long as the reordering rule is obeyed (see below for exceptions).  Examples of transformations that remain valid are: merging multiple non-atomic reads from the same location, reordering non-atomic reads from different locations, introducing speculative non-atomic reads, merging multiple non-atomic writes to the same location, and reordering non-atomic writes to different locations.</p>

          <p>These transformations can be performed by a compiler or the hardware; in the latter case they take the form of speculative loads and buffered stores.</p>

          <p>Programs with data races (defined later) can often observe the effects of legal transformations.</p>
        </emu-note>

        <p>The following rules additionally restrict legal program transformations:</p>

        <ul>
          <li><b>Stable reads:</b> Any given shared memory read must only observe a single value.  (For example, if what is semantically a single read in the program is executed multiple times then the program is subsequently allowed to observe only one of the values read.)

          <li><b>Stable writes:</b> Any given shared memory read must only observe value changes in memory that follow from program semantics.  (For example, the compiler or hardware may not introduce certain observable writes, such as using read-modify-write operations on a larger location to write a smaller datum, writing a value to memory that the program could not have written, or spuriously writing a just-read value back to the location it was read from.  Note that byte interleavings resulting from races, described below, is within program semantics.)

          <li><b>Actual values:</b> Any given shared memory read must only observe values that have been produced by the program's execution.  (For example, the compiler or hardware may not speculate about a value and then use that value to justify the speculation.)
        </ul>

        <emu-note>
          <p>The restrictions apply only to shared memory accesses, so an implementation that knows the program is not accessing shared memory will not be affected by them.  In practice, the optimizations that are affected by the restrictions (rematerialization, certain local optimizations) are of limited value, and a practical implementation could avoid those optimizations even for non-shared memory without significant impact.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="AtomicsObjectProperties">
        <h1>Properties of the model</h1>

        <p>(This is not normative, but useful to have, at least for now.)</p>

        <p>The following properties of the memory operations hold (in the absence of other interfering operations).  For details, see the definitions of BeginAtomic, EndAtomic, BeginNonAtomic, EndNonAtomic, ReadSharedMemory, and WriteSharedMemory in the following sections.</p>

        <p>The system of memory operations always makes progress (does not deadlock).</p>

        <emu-note>
          <p>The only of the memory operations to wait is BeginAtomic, which waits while the atomic-reservation slot is occupied by an ongoing compatible atomic operation.  Since the transaction for the latter operation is stored into the slot after a possible wait, the ongoing atomic operation will be making progress and will reach its EndAtomic operation, unless an interfering operation starts first and changes the state to Invalid.  In either case the waiting operation is released from the wait.</p>
        </emu-note>

        <p>If a non-atomic write conflicts with an atomic operation then the atomic operation is not viable.</p>

        <emu-note>
          <p>Suppose the non-atomic operation starts first.  BeginAtomic will detect that there is a conflicting write in the transaction set and will add an `"Invalid"` atomic transaction.  Suppose the atomic operation starts first.  BeginNonAtomic will detect that there is an atomic transaction with operation `"Atomic"` and that the write overlaps with the atomic transaction, and will change the operation of the atomic transaction to `"Invalid"`.  In either case EndAtomic will see an `"Invalid"` operation for its transaction and return false, making the atomic non-viable.</p>
        </emu-note>

        <p>If a non-atomic read conflicts with an atomic operation then the atomic operation is viable.</p>

        <emu-note>
          <p>This is like the previous case, but since the non-atomic operation is a read, neither will BeginAtomic add an `"Invalid"` atomic transaction, nor will BeginNonAtomic invalidate any existing, overlapping atomic transactions.  Hence EndAtomic will see an `"Atomic"` operation for its transaction and return true.</p>
        </emu-note>

        <p>If two atomic operations conflict and match or don't overlap then they are both viable.</p>

        <emu-note>
          <p>The BeginAtomic calls are totally ordered by the Memory Critical Section.  The first will leave the critical section having added an `"Atomic"` transaction and having asserted that it is now the only atomic transaction in the set.  The second call will enter the critical section and determine that there is exactly one `"Atomic"` transaction and that is matching or not overlapping, and enter a wait until the set of atomic transactions changes (leaving the critical section).  Meanwhile the first agent makes progress and eventually calls EndAtomic, which removes its `"Atomic"` transaction and returns true (indicating viability).  That breaks the wait for the second atomic, which now is alone, and therefore trivially viable.</p>
        </emu-note>

        <p>If two atomic operations don't conflict then they are both viable.</p>

        <emu-note>
          <p>The first of the operations calls BeginAtomic and EndAtomic before the second calls BeginAtomic.  Hence both EndAtomic calls return true, indicating viability.</p>
        </emu-note>

        <p>If two atomic operations conflict and overlap then neither is viable.</p>

        <emu-note>
          <p>The first BeginAtomic adds an `"Atomic"` transaction, after which it is the only atomic transaction in the set. The second BeginAtomic will not wait (because the operations overlap) and will discover that it overlaps an existing transaction whose operation is not `"Read"`.  It will then invalidate all atomic transactions and add its own `"Invalid"` transaction.  Now either the first operation calls EndAtomic first or the second operation does.  In both cases, since the second BeginAtomic altered both atomic transactions to `"Invalid"`, EndAtomic will see an operation of `"Invalid"` for its transaction, returning *false* for both operations, making neither viable. This generalizes trivially to multiple conflicting atomic operations.</p>

          <p>ALSO WORTH NOTING: The above is true even if both operations are reads.  This is touched upon above in the Framework section but can be reiterated here.</p>
        </emu-note>

        <p>Viable atomic operations are executed in a total order.</p>

        <emu-note>
          <p>Suppose the operations don't conflict.  The Memory Critical Section orders BeginAtomic and EndAtomic calls, thus ordering the operations.  Suppose the operations do conflict.  Then they either match, overlap, or neither; see previous cases?  (Not quite, probably.)</p>
        </emu-note>

        <p>If two candidate atomic operations conflict and one is not viable then the other is also not viable.</p>

        <emu-note>
          <p>TODO: TBD, though isn't this the same as the "neither is viable" case above?</p>
        </emu-note>

        <p>TODO: Surely there are more properties to prove, notably about three accesses.</p>

        <p>TODO: A major concern (in some sense) is whether our notion of viability is sufficient for synchronization.</p>
      </emu-clause>

      <emu-clause id="AtomicsObject.EventsAndSync">
        <h1>Events, synchronization, data races, and sequential consistency</h1>

        <p>An <em>event</em> in an agent is either a <em>synchronizing event</em> (a viable atomic operation or the communication action it represents) or a <em>non-synchronizing event</em> (a non-viable atomic operation or a non-atomic operation).</p>

        <p>A <em>program order</em> of an agent is a total ordering of the agent's events that is consistent with the semantics of the ECMAScript program running in that agent.</p>

        <emu-note>
          <p>There are usually many possible legal program orders for a program, representing legal transformations of the program.  Note that transformations may be dynamic, and multiple executions of a program fragment may give rise to different sequences of events.</p>
        </emu-note>

        <p>An <em>execution</em> of an agent cluster is a partial ordering of the agents' events that is consistent with each agent's program order.</p>

        <p>Synchronizing events in an execution will be performed in a total order -- known as the <em>synchronization order</em> for the execution -- that is consistent with each agent's program order.</p>

        <emu-note>
          <p>The total order exists by construction: viable atomic operations are executed in a total order, and only viable atomic operations are part of the synchronization order.</p>
        </emu-note>

        <p>The synchronization order induces a <em>synchronized-with</em> relation on events for the execution: A viable atomic write of a location synchronizes-with all subsequent (later in the synchronization order) viable atomic reads of that location.</p>

        <p>An event A <em>happens before</em> another event B in an execution if either:</p>

        <ul>
          <li>A precedes B in an agent's program order,
          <li>A synchronizes-with B, or
          <li>A happens before C and C happens before B (transitivity).
        </ul>

        <p>Executions must be such that <em>happens before</em> is irreflexive (acyclic).</p>

        <p>Two memory operations constitute a <em>data race</em> if neither happens before the other, at least one of them is a write, and either they overlap, or they match but are not both viable atomic operations.</p>

        <emu-note>
          <p>Two accesses can be in a data race without actually conflicting during any particular execution.  In particular, viable atomic accesses can be in a data race if they overlap but one just happens to be executed before the other.</p>

          <p>Viable atomic operations that are in a data race can be used for synchronization (in that execution).  Consider two racing atomic writes, which will be executed in some order.  If an atomic read happen after both writes have finished (in the synchronization order) and reads the memory written by the writes, then the read is ordered after the writes in the happens-before relation.  In some other execution, though, the two writes may actually conflict, and though the read may still be executed after both writes, the writes, being non-viable, will not happen-before the read.</p>

          <p>An execution that is free of data races will also be free of conflicts (except conflicts between matching atomic operations, all of which will be viable) and will appear to be sequentially consistent.</p>
        </emu-note>

        <p>If every execution of an agent cluster is free of data races then the agent cluster will appear to be sequentially consistent.</p>

        <emu-note>
          <p>If the agent cluster appears sequentially consistent it is not necessary for the programmer to reason about program transformations.</p>

          <p>Data races expose non-intuitive and platform-specific effects of program transformations performed by the compiler or the hardware.  ECMAScript programs with data races are safe (races cannot subvert the language implementation, they affect only the memory locations in Shared Data Blocks), but the values resulting from a program with a data race are often hard to predict.  The effects of data races include observing values that, within limits, appear to come from the past (because they should have been written before other values, which have not been seen) or from the future (because they should have been written after other values, which have not been seen), or which should not exist at all (because conflicting writes may interleave the bytes being written).</p>
        </emu-note>
      </emu-clause>

    </emu-clause>

    <emu-clause id="Atomics.ReadSharedMemory" aoid="ReadSharedMemory">
      <h1>ReadSharedMemory(_block_, _byteIndex_, _accessAtomic_, _numBytes_)</h1>

      <p>ReadSharedMemory takes four arguments, a Shared Data Block _block_, a nonnegative integer _byteIndex_, a Boolean _accessAtomic_, and a nonnegative integer _numBytes_, and returns a List of length _numBytes_ containing bytes, as follows.</p>

      <emu-alg>
        1. Assert: If _accessAtomic_ is true then _byteIndex_ modulo _numBytes_ is zero.
        1. Assert: The length of _block_ is at least _byteIndex_+_numBytes_.
        1. If the read conflicts only with writes that all match the read (and optionally conflicts with arbitrary other reads), and _accessAtomic_ is *true* for the read and for all the writes that conflict, then:
          1. Wait for some arbitrary number of the conflicting writes to complete, one after the other.
        1. Otherwise, the read may conflict with any number of writes (and with arbitrary reads), and the bytes that are returned from ReadSharedMemory are selected individually in arbitrary order as follows:
          1. Wait for some arbitrary number of bytes to be written by the conflicting writes in some arbitrary order.
        1. Return the _numBytes_ bytes in memory starting at _block_[_byteIndex_], in order.
      </emu-alg>

      <emu-note>
        <p>The special provisions around _accessAtomic_ are present here and in WriteSharedMemory even for non-atomic accesses because all hardware supports the specialized behavior and because that behavior is valuable to programs in practice.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="Atomics.WriteSharedMemory" aoid="WriteSharedMemory">
      <h1>WriteSharedMemory(_block_, _byteIndex_, _accessAtomic_, _numBytes_, _rawBytes_)</h1>

      <p>WriteSharedMemory takes five arguments, a Shared Data Block _block_, a nonnegative integer _byteIndex_, a Boolean _accessAtomic_, a nonnegative integer _numBytes_, and a List _rawBytes_ of _numBytes_, and stores the individual bytes of _rawBytes_ into _block_, in order, starting at _block_[_byteIndex_], as follows.</p>

      <emu-alg>
        1. Assert: If _accessAtomic_ is true then _byteIndex_ modulo _numBytes_ is zero.
        1. Assert: The length of _block_ is at least _byteIndex_+_numBytes_.
        1. If the write conflicts only with writes that all match the write (and optionally conflicts with arbitrary reads), and _accessAtomic_ is *true* for all the writes, then:
          1. Each write writes all of its bytes before the next write occurs, with the writes occurring in some arbitrary order.
        1. Otherwise, the write may conflict with any number of writes (and optionally with arbitrary reads):
          1. Each write writes the bytes of its value individually in some arbitrary order, and the byte writes of all the writes are interleaved in some arbitrary order.
      </emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.BeginAtomic" aoid="BeginAtomic">
      <h1>BeginAtomic(_block_, _byteIndex_, _elementSize_)</h1>
      <p>TODO: Boilerplate.</p>
      <emu-alg>
        1. Enter the Memory Critical Section.
        1. Let _t_ be the next value from the timestamp stream; advance the stream.
        1. Let _atomicTxns_ be the set of all atomic transactions in the transaction set.
        1. While _atomicTxns_ is the singleton set containing an atomic transaction whose operation is `"Atomic"` and either matches or does not overlap (_block_, _byteIndex_, _elementSize_):
          1. Wait (leaving the critical section) until _atomicTxns_ changes.
          1. Let _atomicTxns_ be the set of all atomic transactions in the transaction set.
        1. If _atomicTxns_ contains a transaction who overlaps with (_block_, _byteIndex_, _elementSize_) and whose operation is not `"Read"` then:
          1. Invalidate the transaction set for atomics.
          1. Add (_t_, `"Invalid"`, *InvalidBlock*, 0, 0) to the transaction set.
          1. Leave the Memory Critical Section.
          1. Return _t_.
        1. Assert: _atomicTxns_ is the empty set.
        1. Add (_t_, `"Atomic"`, _block_, _byteIndex_, _elementSize_) to the transaction set.
        1. Leave the Memory Critical Section.
        1. Return _t_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.EndAtomic" aoid="EndAtomic">
      <h1>EndAtomic(_t_, _block_, _byteIndex_, _elementSize_)</h1>
      <p>TODO: Boilerplate.</p>
      <emu-alg>
        1. Enter the Memory Critical Section.
        1. Let _txn_ the transaction in the transaction set with timestamp _t_.
        1. Assert: _txn_ exists and is an atomic transaction.
        1. Remove _txn_ from the transaction set.
        1. Leave the Memory Critical Section.
        1. If the operation of _txn_ is `"Invalid"`, then:
          1. Return *false*.
        1. Assert: (_block_, _byteIndex_, _elementSize_) does not overlap or match any entry with a `"Write"` operation in the non-atomic-transaction set.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.BeginNonAtomic" aoid="BeginNonAtomic">
      <h1>BeginNonAtomic(_op_, _block_, _byteIndex_, _elementSize_)</h1>
      <p>TODO: Boilerplate.</p>
      <emu-alg>
        1. Enter the Memory Critical Section.
        1. Let _t_ be the next value from the timestamp stream; advance the stream.
        1. Add a transaction (_t_, _op_, _block_, _byteIndex_, _elementSize_) to the transaction set.
        1. Let _atomicTxns_ be the set of all atomic transactions in the transaction set.
        1. If _op_ equals `"Write"` and there exists an atomic transaction who overlaps (_block_, _byteIndex_, _elementSize_) then:
          1. Invalidate the transaction set for atomics.
        1. Leave the Memory Critical Section.
        1. Return _t_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.EndNonAtomic" aoid="EndNonAtomic">
      <h1>EndNonAtomic(_t_, _op_, _block_, _byteIndex_, _elementSize_)</h1>
      <p>TODO: Boilerplate.</p>
      <emu-alg>
        1. Enter the Memory Critical Section.
        1. Remove (_t_, _op_, _block_, _byteIndex_, _elementSize_) from the transaction set.
        1. Leave the Memory Critical Section.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.NonAtomicRead" aoid="NonAtomicRead">
      <h1>NonAtomicRead(_block_, _byteIndex_, _accessAtomic_, _elementSize_)</h1>

      <p>NonAtomicRead takes four arguments, a Shared Data Block _block_, a nonnegative integer _byteIndex_, a Boolean _accessAtomic_, and a nonnegative integer _elementSize_. The following steps are taken:</p>

      <emu-alg>
        1. Let _transaction_ be BeginNonAtomic(`"Read"`, _block_, _byteIndex_, _elementSize_).
        1. Let _rawValue_ be ReadSharedMemory(_block_, _byteIndex_, _accessAtomic_, _elementSize_).
        1. Perform EndNonAtomic(_transaction_, `"Read"`, _block_, _byteIndex_, _elementSize_).
        1. Assert: _rawValue_ is a List of size _elementSize_.
        1. Let _r_ be a Number constructed from _rawValue_ as for GetValueFromBuffer. (TODO: Elucidate.)
        1. Return _r_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.NonAtomicWrite" aoid="NonAtomicWrite">
      <h1>NonAtomicWrite(_block_, _byteIndex_, _accessAtomic_, _elementSize_, _rawBytes_)</h1>

      <p>NonAtomicWrite takes five arguments, a Shared Data Block _block_, a nonnegative integer _byteIndex_, a Boolean _accessAtomic_, a nonnegative integer _elementSize_, and a List _rawBytes_ of _elementSize_. The following steps are taken:</p>

      <emu-alg>
        1. Let _transaction_ be BeginNonAtomic(`"Write"`, _block_, _byteIndex_, _elementSize_).
        1. Perform WriteSharedMemory(_block_, _byteIndex_, _accessAtomic_, _elementSize_, _rawBytes_).
        1. Perform EndNonAtomic(_transaction_, `"Write"`, _block_, _byteIndex_, _elementSize_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.AtomicRead" aoid="AtomicRead">
      <h1>AtomicRead(_buffer_, _byteIndex_, _type_)</h1>

      <p>AtomicRead takes three arguments, a SharedArrayBuffer _buffer_, an integer _byteIndex_, and a String _type_.  The following steps are taken:</p>

      <emu-alg>
        1. Assert: _byteIndex_ is an integer value &ge; 0.
        1. Assert: There are sufficient bytes in _buffer_ starting at _byteIndex_ to represent a value of _type_.
        1. Let _block_ be _buffer_.[[ArrayBufferData]].
        1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
        1. Let _transaction_ be BeginAtomic(_block_, _byteIndex_, _elementSize_).
        1. Let _rawValue_ be ReadSharedMemory(_block_, _byteIndex_, *true*, _elementSize_).
        1. Let _success_ be EndAtomic(_transaction_, _block_, _byteIndex_, _elementSize_).
        1. Note: If _success_ is *true* then the AtomicRead is viable: it executed atomically in the cluster-wide total order.
        1. Assert: _rawValue_ is a List of size _elementSize_.
        1. Let _r_ be a Number constructed from _rawValue_ as for GetValueFromBuffer. (TODO: Elucidate.)
        1. Return _r_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.AtomicWrite" aoid="AtomicWrite">
      <h1>AtomicWrite(_buffer_, _byteIndex_, _type_, _v_)</h1>

      <p>AtomicWrite takes four arguments, a SharedArrayBuffer _buffer_, an integer _byteIndex_, a String _type_, and a Number _v_.  The following steps are taken:</p>

      <emu-alg>
        1. Assert: _byteIndex_ is an integer value &ge; 0.
        1. Assert: There are sufficient bytes in _buffer_ starting at _byteIndex_ to represent a value of _type_.
        1. Let _block_ be _buffer_.[[ArrayBufferData]].
        1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
        1. Let _rawBytes_ be a List of size _elementSize_ bytes constructed from _v_ as for SetValueInBuffer. (TODO: Elucidate.)
        1. Let _transaction_ be BeginAtomic(_block_, _byteIndex_, _elementSize_).
        1. Perform WriteSharedMemory(_block_, _byteIndex_, *true*, _elementSize_, _rawBytes_).
        1. Let _success_ be EndAtomic(_transaction_, _block_, _byteIndex_, _elementSize_).
        1. Note: If _success_ is *true* then the AtomicWrite is viable: it executed atomically in the cluster-wide total order.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.AtomicReadModifyWrite" aoid="AtomicReadModifyWrite">
      <h1>AtomicReadModifyWrite(_buffer_, _byteIndex_, _type_, _op_, _v_)</h1>

      <p>AtomicReadModifyWrite takes five arguments, a SharedArrayBuffer _buffer_, an integer _byteIndex_, a String _type_, a semantic function _op_, and a Number _v_.  The following steps are taken:</p>

      <emu-alg>
        1. Assert: _byteIndex_ is an integer value &ge; 0.
        1. Assert: There are sufficient bytes in _buffer_ starting at _byteIndex_ to represent a value of _type_.
        1. Let _block_ be _buffer_.[[ArrayBufferData]].
        1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
        1. Let _transaction_ be BeginAtomic(_block_, _byteIndex_, _elementSize_).
        1. Let _rawValue_ be ReadSharedMemory(_block_, _byteIndex_, *true*, _elementSize_).
        1. Assert: _rawValue_ is a List of size _elementSize_.
        1. Let _r_ be a Number constructed from _rawValue_ as for GetValueFromBuffer. (TODO: Elucidate.)
        1. Compute: Let _w_ be _op_(_r_, _v_).
        1. Let _rawBytes_ be a List of size _elementSize_ bytes constructed from _w_ as for SetValueInBuffer. (TODO: Elucidate.)
        1. Perform WriteSharedMemory(_block_, _byteIndex_, *true*, _elementSize_, _rawBytes_).
        1. Let _success_ be EndAtomic(_transaction_, _block_, _byteIndex_, _elementSize_).
        1. Note: If _success_ is *true* then the AtomicReadModifyWrite is viable: it executed atomically in the cluster-wide total order.
        1. Return _r_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.AtomicCompareExchange" aoid="AtomicCompareExchange">
      <h1>AtomicCompareExchange(_buffer_, _byteIndex_, _type_, _expected_, _replacement_)</h1>

      <p>AtomicCompareExchange takes five arguments, a SharedArrayBuffer _buffer_, an integer _byteIndex_, a String _type_, and two Numbers _expected_ and _replacement_.  The following steps are taken:</p>

      <emu-alg>
        1. Assert: _byteIndex_ is an integer value &ge; 0.
        1. Assert: There are sufficient bytes in _buffer_ starting at _byteIndex_ to represent a value of _type_.
        1. Let _block_ be _buffer_.[[ArrayBufferData]].
        1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
        1. Let _transaction_ be BeginAtomic(_block_, _byteIndex_, _elementSize_).
        1. Let _rawValue_ be ReadSharedMemory(_block_, _byteIndex_, *true*, _elementSize_).
        1. Assert: _rawValue_ is a List of size _elementSize_.
        1. Let _r_ be a Number constructed from _rawValue_ as for GetValueFromBuffer. (TODO: Elucidate.)
        1. If _r_ is the same as _expected_ then:
          1. Let _rawBytes_ be a List of size _elementSize_ bytes constructed from _replacement_ as for SetValueInBuffer. (TODO: Elucidate.)
          1. Perform WriteSharedMemory(_block_, _byteIndex_, *true*, _elementSize_, _rawBytes_).
        1. Let _success_ be EndAtomic(_transaction_, _block_, _byteIndex_, _elementSize_).
        1. Note: If _success_ is *true* then the AtomicCompareExchange is viable: it executed atomically in the cluster-wide total order.
        1. Return _r_
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.ValidateSharedIntegerTypedArray" aoid="ValidateSharedIntegerTypedArray">
      <h1>ValidateSharedIntegerTypedArray(_typedArray_ [, _onlyInt32_] )</h1>
      <emu-alg>
        1. If Type(_typedArray_) is not Object, throw a *TypeError* exception.
        1. If _typedArray_ does not have a [[TypedArrayName]] internal slot, throw a *TypeError* exception.
        1. Let _typeName_ be _typedArray_.[[TypedArrayName]].
        1. If _onlyInt32_ is *true* then
          1. If _typeName_ is not `"Int32Array"` then throw a *TypeError* exception.
        1. Else
          1. If _typeName_ is not `"Int8Array"`, `"Uint8Array"`, `"Int16Array"`, `"Uint16Array"`, `"Int32Array"`, or `"Uint32Array"` then throw a *TypeError* exception.
        1. If _typedArray_ does not have a [[ViewedArrayBuffer]] internal slot, throw a *TypeError* exception.
        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].
        1. If Type(_buffer_) is not Object, throw a *TypeError* exception.
        1. If _buffer_ does not have an [[ArrayBufferData]] internal slot, throw a *TypeError* exception.
        1. If IsSharedArrayBuffer(_buffer_) is *false*, throw a *TypeError* exception.
        1. Return _buffer_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.ValidateAtomicAccess" aoid="ValidateAtomicAccess">
      <h1>ValidateAtomicAccess( _typedArray_, _requestIndex_ )</h1>
      <p>Perform the following steps:</p>
      <emu-alg>
        1. Assert: _typedArray_ is an Object that has a [[ViewedArrayBuffer]] internal slot.
        1. Let _numberIndex_ be ? ToNumber(_requestIndex_).
        1. Let _accessIndex_ be ToInteger(_numberIndex_).
        1. If _numberIndex_ &ne; _accessIndex_, throw a *RangeError* exception.
        1. Let _length_ be _typedArray_.[[ArrayLength]].
        1. If _accessIndex_ &lt; 0 or _accessIndex_ &ge; _length_, throw a *RangeError* exception.
        1. Return _accessIndex_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.AgentSignifier" aoid="AgentSignifier">
      <h1>AgentSignifier( )</h1>
      <p>When AgentSignifier is called without arguments then the following steps are taken.</p>
      <emu-alg>
        1. Let _AR_ be the Agent Record of the <em>surrounding agent</em>.
        1. Let _W_ be _AR_.[[Signifier]].
        1. Return _W_.
      </emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.AgentCanSuspend" aoid="AgentCanSuspend">
      <h1>AgentCanSuspend( )</h1>
      <p>When AgentCanSuspend is called without arguments then the following steps are taken.</p>
      <emu-alg>
        1. Let _AR_ be the Agent Record of the <em>surrounding agent</em>.
        1. Let _B_ be _AR_.[[CanBlock]].
        1. Return _B_.
      </emu-alg>

      <emu-note>
        <p>In some environments it may not be reasonable for a given agent to suspend.  For example,
          in a web browser environment, it may be reasonable to disallow suspending a document's main event
          handling thread, while still allowing workers' event handling threads to suspend.</p>
      </emu-note>

    </emu-clause>

    <emu-clause id="GetWaiterList" aoid="GetWaiterList">
      <h1>GetWaiterList( _block_, _i_ )</h1>
      <p>A <dfn>WaiterList</dfn> is a semantic object that contains an ordered list of those agents that are waiting on a location (_block_, _i_) in shared memory; _block_ is a Shared Data Block and _i_ a byte offset into the memory of _block_.</p>
      <p>The agent cluster has a store of WaiterList objects; the store is indexed by (_block_, _i_).  WaiterLists are agent-independent: a lookup in the store of WaiterLists by (_block_, _i_) will result in the same WaiterList object in any agent in the agent cluster.</p>
      <p>Operations on a WaiterList -- adding and removing waiting agents, traversing the list of agents, suspending and waking agents on the list -- may only be performed by agents that have entered the WaiterList's critical section.</p>
      <p>When GetWaiterList is called with Shared Data Block _block_ and nonnegative integer _i_, then the following steps are taken.</p>
      <emu-alg>
        1. Assert: _block_ is a Shared Data Block.
        1. Assert: _i_ and _i_+3 are valid byte offsets within the memory of _block_.
        1. Assert: _i_ is divisible by 4.
        1. Return the WaiterList that is referenced by the pair (_block_, _i_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="EnterCriticalSection" aoid="EnterCriticalSection">
      <h1>EnterCriticalSection( _WL_ )</h1>
      <p>When EnterCriticalSection is called with WaiterList _WL_, then the following steps are taken.</p>
      <emu-alg>
        1. Assert: The calling agent is not in the critical section for any WaiterList.
        1. Wait until no agent is in the critical section for _WL_, then enter the critical section for _WL_ (without allowing any other agent to enter).
      </emu-alg>
    </emu-clause>

    <emu-clause id="LeaveCriticalSection" aoid="LeaveCriticalSection">
      <h1>LeaveCriticalSection( _WL_ )</h1>
      <p>When LeaveCriticalSection is called with WaiterList _WL_, then the following steps are taken.</p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_.
        1. Leave the critical section for _WL_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.AddWaiter" aoid="AddWaiter">
      <h1>AddWaiter( _WL_, _W_ )</h1>
      <p>When AddWaiter is called with WaiterList _WL_ and agent signifier _W_, then the following steps are taken.</p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_.
        1. Assert: _W_ is not on the list of waiters in any WaiterList.
        1. Add _W_ to the end of the list of waiters in _WL_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.RemoveWaiter" aoid="RemoveWaiter">
      <h1>RemoveWaiter( _WL_, _W_ )</h1>
      <p>When RemoveWaiter is called with WaiterList _WL_ and agent signifier _W_, then the following steps are taken.</p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_.
        1. Assert: _W_ is on the list of waiters in _WL_.
        1. Remove _W_ from the list of waiters in _WL_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.RemoveWaiters" aoid="RemoveWaiters">
      <h1>RemoveWaiters( _WL_, _c_ )</h1>
      <p>When RemoveWaiters is called with WaiterList _WL_ and nonnegative integer _c_, then the following steps are taken.</p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_.
        1. Let _L_ be the empty list.
        1. Let _S_ be a reference to the list of waiters in _WL_.
        1. While _c_ &gt; 0 and _S_ is not the empty list:
          1. Let _W_ be the first waiter in _S_.
          1. Add _W_ to the end of _L_.
          1. Remove _W_ from _S_.
          1. Subtract 1 from _c_.
        1. Return _L_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.Suspend" aoid="Suspend">
      <h1>Suspend( _WL_, _W_, _timeout_ )</h1>
      <p>When Suspend is called with WaiterList _WL_, agent signifier _W_, and nonnegative, non-*NaN* Number _timeout_, then the following steps are taken.</p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_.
        1. Assert: _W_ is equal to AgentSignifier().
        1. Assert: _W_ is on the list of waiters in _WL_.
        1. Assert: AgentCanSuspend() is equal to true.
        1. Perform LeaveCriticalSection(_WL_) and suspend _W_ for up to _timeout_ milliseconds, performing the combined operation in such a way that a wakeup that arrives after the critical section is exited but before the suspension takes effect is not lost.  _W_ can wake up either because the timeout expired or because it was woken explicitly by another agent calling WakeWaiter(_WL_, _W_), and not for any other reasons at all.
        1. Perform EnterCriticalSection(_WL_).
        1. If _W_ was woken explicitly by another agent calling WakeWaiter(_WL_, _W_), then return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.WakeWaiter" aoid="WakeWaiter">
      <h1>WakeWaiter( _WL_, _W_ )</h1>
      <p>When WakeWaiter is called with WaiterList _WL_ and agent signifier _W_, then the following steps are taken.</p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_.
        1. Assert: _W_ is on the list of waiters in _WL_.
        1. Wake the agent _W_.
      </emu-alg>

      <emu-note>
        <p>The embedding may delay waking _W_, eg for resource management reasons, but _W_ must eventually be woken in order to guarantee forward progress.</p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.FetchOp" aoid="AtomicFetchOp">
      <h1>AtomicFetchOp( _typedArray_, _index_, _value_, _op_ )</h1>
      <p>AtomicFetchOp is a semantic function that atomically loads a value, combines it with another value, and stores the result of the combination.  It returns the loaded value.  It is parameterized by the (pure) combining operation _op_ that takes two Number arguments and returns a Number.  The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. Let _v_ be ? ToInteger(_value_).
        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
        1. Let _elementSize_ be the Number value of the Element Size value specified in Table 49 for _arrayTypeName_.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for _arrayTypeName_.
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_.
        1. Let _r_ be AtomicReadModifyWrite(_buffer_, _indexedPosition_, _elementType_, _op_, _v_)
        1. Return _r_.
      </emu-alg>

      <emu-note>
        <p>The combining operation is restricted to addition, subtraction, bitwise and, or, and xor, and argument selection, and the element types are exclusively integer types.  The store in step 9.c truncates any overflowed result by discarding the overflowed bits.  The combined effect is that the computation in step 9.b is a simple integer operation with ignored overflow, and the entire atomic operation in step 9 can be executed with maximal efficiency on all platforms.</p>
    </emu-clause>
  </emu-clause> <!-- runtime semantics -->

  <emu-clause id="AtomicsObjectFunctionProps">
    <h1>Function Properties of the Atomics Object</h1>

    <emu-clause id="Atomics.add">
      <h1>Atomics.add( _typedArray_, _index_, _value_ )</h1>
      <p>Let `add` denote a semantic function of two Number arguments that applies the addition operation to the arguments and returns the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return AtomicFetchOp(_typedArray_, _index_, _value_, `add`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.and">
      <h1>Atomics.and( _typedArray_, _index_, _value_ )</h1>
      <p>Let `and` denote a semantic function of two Number arguments that converts both arguments to Int32 by the ToInt32 operation, then applies the bitwise-and operation to the converted values, and returns the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return AtomicFetchOp(_typedArray_, _index_, _value_, `and`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.compareExchange">
      <h1>Atomics.compareExchange( _typedArray_, _index_, _expectedValue_, _replacementValue_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. Let _expected_ be ? ToInteger(_expectedValue_).
        1. Let _replacement_ be ? ToInteger(_replacedValue_).
        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
        1. Let _convOp_ be the conversion operation specified in Table 49 for _arrayTypeName_.
        1. Let _x_ be _convOp_ (_expected_).
        1. Let _elementSize_ be the Number value of the Element Size value specified in Table 49 for _arrayTypeName_.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for _arrayTypeName_.
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_.
        1. Let _r_ be AtomicCompareExchange(_buffer_, _indexedPosition_, _elementType_, _x_, _replacement_)
        1. Return _r_.
      </emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.exchange">
      <h1>Atomics.exchange( _typedArray_, _index_, _value_ )</h1>
      <p>Let `second` denote a semantic function of two Number arguments that returns its second argument.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return AtomicFetchOp(_typedArray_, _index_, _value_, `second`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.isLockFree">
      <h1>Atomics.isLockFree( _size_ )</h1>

      <emu-alg>
        1. Let _n_ be ? ToInteger(_size_).
        1. Let _AR_ be the Agent Record of the <em>surrounding agent</em>.
        1. If _n_ equals 1 then return _AR_.[[IsLockFree1]].
        1. If _n_ equals 2 then return _AR_.[[IsLockFree2]].
        1. If _n_ equals 4 then return *true*.
        1. Return *false*.
      </emu-alg>

      <emu-note>
        <p>Atomics.isLockFree() is an optimization primitive.  The
          intuition is that if the atomic step of an atomic primitive
          (`compareExchange`, `load`, `store`, `add`, `sub`, `and`,
          `or`, `xor`, or `exchange`) on a datum of size _n_ bytes
          will be performed without the calling agent acquiring a lock
          outside the _n_ bytes comprising the datum, then
          Atomics.isLockFree(_n_) will return *true*.
          High-performance algorithms will use Atomics.isLockFree to
          determine whether to use locks or atomic operations in
          critical sections.  If an atomic primitive is not lock-free
          then it is often more efficient for an algorithm to provide
          its own locking.</p>

        <p>Atomics.isLockFree(4) always returns *true* as that can be
          supported on all known relevant hardware.  Being able to
          assume this will generally simplify programs.</p>

      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.load">
      <h1>Atomics.load( _typedArray_, _index_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
        1. Let _elementSize_ be the Number value of the Element Size value specified in Table 49 for _arrayTypeName_.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for _arrayTypeName_.
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_.
        1. Let _r_ be AtomicRead(_buffer_, _indexedPosition_, _elementType_).
        1. Return _r_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.or">
      <h1>Atomics.or( _typedArray_, _index_, _value_ )</h1>
      <p>Let `or` denote a semantic function of two Number arguments that converts both arguments to Int32 by the ToInt32 operation, then applies the bitwise-or operation to the converted values, and returns the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return AtomicFetchOp(_typedArray_, _index_, _value_, `or`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.store">
      <h1>Atomics.store( _typedArray_, _index_, _value_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. Let _v_ be ? ToInteger(_value_).
        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
        1. Let _elementSize_ be the Number value of the Element Size value specified in Table 49 for _arrayTypeName_.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for _arrayTypeName_.
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_.
        1. Perform AtomicWrite(_buffer_, _indexedPosition_, _elementType_, _v_).
        1. Return _v_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.sub">
      <h1>Atomics.sub( _typedArray_, _index_, _value_ )</h1>
      <p>Let `subtract` denote a semantic function of two Number arguments that applies the subtraction operation to the arguments and returns the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return AtomicFetchOp(_typedArray_, _index_, _value_, `subtract`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.wait">
      <h1>Atomics.wait( _typedArray_, _index_, _value_, _timeout_ )</h1>
      <p>Atomics.wait puts the calling agent in a wait queue and puts it to sleep until it is awoken or the sleep times out. The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_, *true*).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. Let _v_ be ? ToInt32(_value_).
        1. If _timeout_ is not provided or is *undefined* then let _t_ be *+&infin;*.  Otherwise:
          1. Let _q_ be ? ToNumber(_timeout_).
          1. If _q_ is *NaN* then let _t_ be *+&infin;*, otherwise let _t_ be max(0, _q_).
        1. Let _B_ be AgentCanSuspend().
        1. If _B_ is *false* then throw a *TypeError* exception.
        1. Let _bufferVal_ be _buffer_.[[ArrayBufferData]].
        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. Let _indexedPosition_ be (_i_ &times; 4) + _offset_.
        1. Let _WL_ be GetWaiterList(_block_, _indexedPosition_).
        1. Perform EnterCriticalSection(_WL_).
        1. Let _w_ be AtomicRead(_buffer_, _indexedPosition_, `"Int32"`).
        1. If _v_ does not equal _w_ then:
          1. Perform LeaveCriticalSection(_WL_).
          1. Return the string `"not-equal"`.
        1. Let _W_ be AgentSignifier().
        1. Perform AddWaiter(_WL_, _W_).
        1. Let awoken be Suspend(_WL_, _W_, _t_).
        1. Perform RemoveWaiter(_WL_, _W_).
        1. Perform LeaveCriticalSection(_WL_).
        1. If awoken is *true* then return the string `"ok"`.
        1. Return the string `"timed-out"`.
      </emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.wake">
      <h1>Atomics.wake( _typedArray_, _index_, _count_ )</h1>
      <p>Atomics.wake wakes up some agents that are sleeping in the wait queue.  The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_, *true*).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. If _count_ is not provided or is *undefined* then let _c_ be *+&infin;*.  Otherwise:
          1. Let _tmp_ be ? ToInteger(_count_).
          1. Let _c_ be max(*+0*, _tmp_).
        1. Let _bufferVal_ be _buffer_.[[ArrayBufferData]].
        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. Let _indexedPosition_ be (_i_ &times; 4) + _offset_.
        1. Let _WL_ be GetWaiterList(_block_, _indexedPosition_).
        1. Let _n_ be 0.
        1. Perform EnterCriticalSection(_WL_).
        1. Let _S_ be RemoveWaiters(_WL_, _c_).
        1. While _S_ is not the empty list:
          1. Let _W_ be the first agent in _S_.
          1. Remove _W_ from the front of _S_.
          1. Perform WakeWaiter(_WL_, _W_).
          1. Add 1 to _n_.
        1. Perform LeaveCriticalSection(_WL_).
        1. Return _n_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.xor">
      <h1>Atomics.xor( _typedArray_, _index_, _value_ )</h1>
      <p>Let `xor` denote a semantic function of two Number arguments that converts both arguments to Int32 by the ToInt32 operation, then applies the bitwise-xor operation to the converted values, and returns the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return AtomicFetchOp(_typedArray_, _index_, _value_, `xor`).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="WebBrowserEmbedding">
  <h1>Web browser embedding (informative)</h1>

  <p>This section outlines how the Shared Memory and Atomics
    specification fits into the current web ecosystem with the minimum
    amount of change to that ecosystem.  This section is not part of
    the proposal, it is informative only.</p>

  <p>In a web browser an <em>agent</em> is an HTML <em>event
    loop</em> <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">[here]</a>.
    The event loop is realized as either a main thread (which may be
    shared among tabs, as it is in Firefox) or some type of worker
    thread.  The event loops are running jobs in the sense of ES262,
    and the forward-progress requirement of this specification
    (section&nbsp;3.1.1) is generally met as long as each agent has
    its own dedicated operating system thread or shared-thread agents
    can't block.</p>

  <p>Browsers will typically let agents that run on the browser's
    main thread have [[CanBlock]] equal to *false*, to prevent blocking the
    UI and to allow the main thread to do work on behalf of other
    threads.</p>

  <p>Normal ("dedicated") `Worker`s must be supported as agents for
    this proposal to make much sense.</p>

  <p>Memory will be shared among agents by using `postMessage` to
    transmit SharedArrayBuffer objects or TypedArray objects that
    have SharedArrayBuffer buffers; this requires an extension to
    the Structured Clone mechanism.  There is agreement on the general
    syntax and semantics for that extension.</p>

  <p>Agent-to-agent communication extends the synchronizes-with relation
    of the program, as follows:</p>

  <ul>
    <li>The call to the `Worker` constructor in the parent
      synchronizes-with the execution of the main script in the worker.

    <li>(Worker termination is not directly observable in current
      browsers, but this is a moot point; see below.)

    <li>A `postMessage` to another agent synchronizes-with the event
      that fires in the agent.
 </ul>

  <p>So long as the browser does not allow a `ServiceWorker` or
    `SharedWorker` ("non-page worker") to share memory with a `Worker`
    it will not violate the suspend/wake cohort rule of this
    specification (section&nbsp;3.3).  The restriction on sharing
    memory can be implemented in the extension to the Structured Clone
    mechanism.  For example, a non-page worker may simply not be
    allowed to receive shared memory (leading to a null value or an
    error signal).  There is not yet any agreement on this point, but
    it is clear that the restriction must be on the receiving side of
    the communication, as the sender may be sending on a `MessagePort`
    that is not yet connected, but may in the future be connected to
    either a valid or invalid recipient.</p>

  <p>At the moment, I believe dedicated workers are in the same
    process as their owning tab in all browsers, so if the process
    crashes then the workers will crash too.  I also don't know any
    reason a browser should forcibly terminate a worker except when a
    tab is closed.  In sum, the termination signaling requirement of
    this specification (section&nbsp;3.3) is probably met by existing
    browsers.</p>

  <p>The web platform should evolve to serve the shared memory use
    case better: by incorporating inspectable worker state and worker
    lifecycle events, and by tightening the wording in the HTML spec
    (currently the browser is allowed to kill a worker at any time for
    any reason, which is not quite what we want).  WebIDL should
    evolve to allow Web APIs to be described as to when they can and
    cannot receive shared memory parameters.  However, only an
    extension to the Structured Clone algorithm is needed to support
    the Shared Memory and Atomics specification in practice on current
    browsers.</p>

</emu-clause>

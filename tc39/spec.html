<!-- -*- indent-tabs-mode: nil -*-

     Process this file with ../format.sh to produce shmem.html.  See comments in that file.
-->
<!doctype html>
<meta charset="utf8">
<title>ECMAScript Shared Memory and Atomics</title>
<script src="https://bterlson.github.io/ecmarkup/ecmarkup.js"></script>
<link rel="stylesheet" href="https://bterlson.github.io/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">

<h1>ECMAScript Shared Memory and Atomics</h1>
<p> Revised: 2016-07-05 </p>
<p> Some algorithms and semantics in this proposal are presented as modifications to existing ES262 algorithms and semantics.  The base revision of ES262 for the modifications (here denoted "ES7") is currently f35248729043089b47ccf29e4c47559386f5f6fd (2016-06-29).  At the moment, ES7 (ES2016) section numbering differs from ES6 (ES2015) only for TypedArrays (section 22.2).</p>

<emu-intro id="intro">
<h1>Introduction</h1>

<p> This proposal adds a simple form of shared memory to ECMAScript.
Shared memory is being exposed in the form of a new SharedArrayBuffer
type; the existing TypedArrays are adapted in such a way that they can
be used to create views on shared memory.  The new global Atomics
object provides atomic operations on shared memory locations,
including operations that can be used to create blocking
synchronization primitives.  Though not a part of this specification,
we intend for the role of "threads" to be played by Web Workers in web
browser environments.<p>

<p> At this time the proposal adds only low-level primitives to
ECMAScript; we expect the developer community to put together
abstractions that are useful in specific domains. </p>

<p> The work has been driven by the following use cases: <p>

<ul>
  <li> Support for threaded code in programs written in other
  languages that are translated to asm.js or plain JS or a combination
  of the two, notably C and C++ but also other safe languages.

  <li> Support for hand-written JS or JS+asm.js that makes use of
  multiprocessing facilities for select tasks, such as image
  processing, asset management, or game AI.
</ul>

<p> The proposal makes only very basic assumptions about the required
hardware and should be broadly implementable with good performance.
Prototype implementations of the API are available in Firefox and in
Google Chrome. </p>

<p>This specification constitutes a restatement and formalization of
an earlier
work, <a href="https://github.com/tc39/ecmascript_sharedmem/blob/master/historical/Spec_JavaScriptSharedMemoryAtomicsandLocks.pdf">the
spec document for which</a> also contains additional rationale,
background information, discussions, implementation notes, and
comments.</p>

<p> This specification is substantially complete.  However, the
  following aspects are still undergoing refinement.  The refinements
  are expected to have only local effects on the specification. </p>

<ul>
  <li> The memory model is being improved (Issues
    <a href="https://github.com/tc39/ecmascript_sharedmem/issues/22">22</a>,
    <a href="https://github.com/tc39/ecmascript_sharedmem/issues/37">37</a>, 
    <a href="https://github.com/tc39/ecmascript_sharedmem/issues/48">48</a>,
    <a href="https://github.com/tc39/ecmascript_sharedmem/issues/51">51</a>,
    <a href="https://github.com/tc39/ecmascript_sharedmem/issues/55">55</a>)
</ul>

<p>Changelog:</p>
<ul>
  <li> 2016-07-05 -- Rewrote (and shrunk) the informative Web Browser Embedding section so that it only addresses the requirements of this spec, not how HTML ought to evolve to bring maximum bliss.
  <li> 2016-07-05 -- Rephrased the wait/wake mutual exclusion in terms of critical sections named by (G,i), as the old specification was too strong.
  <li> 2016-07-05 -- Numerous minor editorial adjustments.
  <li> 2016-06-30 -- Modified algorithms include more context and are more clearly marked, and there's a defined ES262 base revision for those modifications.  Updated section references to reference that revision.
  <li> (Older changelog removed)
</ul>

</emu-intro>

<emu-clause id="Overview">
  <h1>Overview (ES7 4)</h1>
  <emu-clause id="Overview.Overview">
    <h1>ECMAScript Overview (ES7 4.2)</h1>
    <p>In the third paragraph, include <b>SharedArrayBuffer</b> after <b>ArrayBuffer</b>.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="DataTypesValues">
  <h1>ECMAScript Data Types and Values (ES7 6)</h1>
  
  <emu-clause id="DataTypesValues.LanguageTypes">
    <h1>ECMAScript Language Types (ES7 6.1)</h1>
    <emu-clause id="DataTypesValues.LanguageTypes.Number">
      <h1>The Number Type (ES7 6.1.6)</h1>
      <p>In the NOTE, include <b>SharedArrayBuffer</b> along with <b>ArrayBuffer</b>.</p>
    </emu-clause>
    <emu-clause id="DataTypesValues.LanguageTypes.Object">
      <h1>The Object Type (ES7 6.1.7)</h1>
      <emu-clause id="DataTypesValues.LanguageTypes.Object.Intrinsic">
        <h1>Well-Known Intrinsic Objects (ES7 6.1.7.4)</h1>
        <p>In table 7, include rows for %SharedArrayBuffer% and %SharedArrayBufferPrototype% in the manner of the rows for ArrayBuffer.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  
  <emu-clause id="DataTypesValues.SpecTypes">
    <h1>ECMAScript Specification Types (ES7 6.2)</h1>
    <emu-clause id="DataTypesValues.SpecTypes.DataBlocks">
      <h1>Data blocks (ES7 6.2.6)</h1>
      <p> Insert the following paragraph after the third: </p>

      <p> A data block that resides in memory that can be referenced from multiple agents concurrently is designated a <dfn>Shared Data Block</dfn>. </p>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes">
        <h1>CopyDataBlockBytes (_toBlock_, _toIndex_, _fromBlock_, _fromIndex_, _count_) (ES7 6.2.6.2)</h1>
        <p> This algorithm is modified as follows:</p>
        <p>When the abstract operation CopyDataBlockBytes is called, the following steps are taken:</p>
        <emu-alg>
          1. Assert: _fromBlock_ and _toBlock_ are distinct Data Block <ins>or Shared Data Block</ins> values.
          1. ...
        </emu-alg>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock">
        <h1>CreateSharedByteDataBlock( size )</h1>
        <p>When the abstract operation CreateSharedByteDataBlock is called with integer argument size, the following steps are taken:</p>
        <emu-alg>
          1. Assert: _size_ >= 0.
          1. Let _db_ be a new Shared Data Block value consisting of _size_ bytes. If it is impossible to create such a Shared Data Block, throw a *RangeError* exception.
          1. Set all of the bytes of _db_ to 0.
          1. Return _db_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID" aoid="SharedDataBlockID">
        <h1>SharedDataBlockID( block )</h1>
        <p>When the abstract operation SharedDataBlockID is called with Shared Data Block argument _block_, the following steps are taken:</p>
        <emu-alg>
          1. Let _G_ be an address-free identifier for _block_.  All agents in the same agent cluster must use the same value for _G_ for any given _block_.
          1. Return _G_.
        </emu-alg>
        <emu-note>
          <p>The <dfn>Shared Data Block ID</dfn> is used by the wait/wake mechanism and names _block_ independently of any virtual addresses it may be mapped to in any particular agent.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="ExecutableCodeAndContexts">
  <h1>Executable Code and Execution Contexts (ES7 8)</h1>
  <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues">

    <h1>Jobs and Job Queues (ES7 8.4)</h1>
    <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues.Progress">
      <h1>Forward Progress Guarantees</h1>
      <p> The forward progress guarantee is provided by <a href="https://github.com/tc39/ecma262/pull/522">PR 522 on ES262</a>. </p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="ExecutableCodeAndContexts.AgentCluster">
    <h1>Agents (AMENDMENTS)</h1>

    <p> Add the following properties to the <dfn>Agent Record</dfn> (which is provided by <a href="https://github.com/tc39/ecma262/pull/522">PR 522 on ES262</a>):</p>

    <emu-table id="table-agent-record" caption="Agent Record Fields">
      <table>
        <tbody>
          <tr>
            <th>
	      Field name
	    </th>
            <th>
	      Value
	    </th>
            <th>
	      Meaning
	    </th>
          </tr>
          <tr>
            <td> [[Signifier]] </td>
            <td> A value that admits equality testing </td>
            <td> Uniquely identifies the agent within its agent cluster. </td>
          </tr>
          <tr>
            <td> [[IsLockFree1]] </td>
            <td> Boolean </td>
            <td> True iff atomic operations on one-byte values are lock-free. </td>
          </tr>
          <tr>
            <td> [[IsLockFree2]] </td>
            <td> Boolean </td>
            <td> True iff atomic operations on two-byte values are lock-free. </td>
          </tr>
        </tbody>
      </table>
    </emu-table>

    <p> Once the values of [[Signifier]], [[IsLockFree1]], and
    [[IsLockFree2]] have been observed by any agent in the agent
    cluster they cannot change. </p>
    
    <emu-note>
      <p>The values of [[IsLockFree1]] and [[IsLockFree2]] are not
        necessarily determined by the hardware, but may also reflect
        implementation choices that can vary over time and between
        ECMAScript implementations.</p>

      <p>There is no [[IsLockFree4]] property: 4-byte atomic
        operations are always lock-free. </p>

      <p>Formally, atomic operations are lock-free if, infinitely
        often, some atomic operation finishes in a finite number of
        program steps.  In practice, if an atomic operation is
        implemented with any type of lock the operation is not
        lock-free.  Lock-free does not imply wait-free: there is no
        upper bound on how many machine steps may be required to
        complete a lock-free atomic operation. </p>

      <p>That an atomic access of size <em>n</em> is lock-free does
        not imply anything about the (perceived) atomicity of
        non-atomic accesses of size <em>n</em>, specifically,
        non-atomic accesses may still be performed as a sequence of
        several separate memory accesses. </p>
    </emu-note>

  </emu-clause>
  
  <emu-clause id="ExecutableCodeAndContexts.AgentCluster">
    <h1>Agent Clusters (NEW)</h1>

    <p> An <em>agent cluster</em> is a maximal set of agents that can
      communicate by operating on shared memory. </p>

    <emu-note>
      <p> Programs within different agents may share memory by
        unspecified means.  At a minimum, the backing memory for
        SharedArrayBuffer objects can be shared among the agents in
        the cluster. </p>

      <p> There may be agents that can communicate by message passing
	that cannot share memory; they are never in the same
	cluster. </p>
    </emu-note>

    <p> Every agent belongs to exactly one agent cluster. </p>

    <emu-note>
      <p> The agents in a cluster need not all be alive at some
	particular point in time.  If agent <b>A</b> creates another
	agent <b>B</b>, after which <b>A</b> terminates and <b>B</b>
	creates agent <b>C</b>, the three agents are in the same
	cluster if <b>A</b> could share some memory with <b>B</b>
	and <b>B</b> could share some memory with <b>C</b>. </p>
    </emu-note>

    <p> All agents within a cluster must have the same value for
      the [[LittleEndian]] property in their respective Agent Records. </p>

    <emu-note>
      <p> If different agents within an agent cluster have different
        values of [[LittleEndian]] it becomes hard to use shared
        memory for multi-byte data. </p>
    </emu-note>

    <p> All agents within a cluster must have the same values for
      the [[IsLockFree1]] property in their respective Agent Records; similarly for
      the [[IsLockFree2]] property. </p>

    <p> All agents within a cluster must have different values for
      the [[Signifier]] property in their respective Agent Records. </p>

    <p> An agent cluster is a specification mechanism and need not correspond to
      any particular artefact of an ECMAScript implementation. </p>

    <p> An embedding may suspend and wake an agent without the agent's
      knowledge or cooperation.  If the embedding does so, it must
      suspend and wake all agents in an agent cluster together. </p>

    <emu-note>
      <p> The purpose of the preceding restriction is to avoid a
        situation where an agent deadlocks or starves because another
        agent has been suspended.  For example, if a DOM SharedWorker
        shares memory with a regular worker, and the regular worker is
        suspended while it holds a lock (because the web page the
        regular worker is in is pushed into the window history), and
        the SharedWorker tries to acquire the lock, then the
        SharedWorker will be blocked until the regular worker wakes up
        again, if ever.  Meanwhile other workers trying to access the
        SharedWorker from other web pages will starve. </p>

      <p> The implication of the restriction is that it will not be
        possible to share memory between agents that don't belong to
        the same suspend/wake collective within the embedding. </p>
    </emu-note>

    <p> An embedding may terminate an agent without any of the agent's
      cluster's other agents' prior knowledge or cooperation.  If an
      agent is terminated not by programmatic action of its own or of
      another agent in the cluster but by forces external to the
      cluster, then the embedding must choose one of two strategies:
      Either terminate all the agents in the cluster, or provide
      reliable APIs that allow the agents in the cluster to coordinate
      so that at least one remaining member of the cluster will be
      able to detect the termination, with the termination data
      containing enough information to identify the agent that was
      terminated. </p>

    <emu-note>
      <p> Examples of that type of termination are: operating systems
        or users terminating agents that are running in separate
        processes; the embedding itself terminating an agent that is
        running in-process with the other agents when per-agent
        resource accounting indicates that the agent is runaway. </p>
    </emu-note>

    <emu-note>
      <p> This proposal additionally requires (see later text) that if
        termination is signaled then the signal creates a
        happens-before edge in the memory ordering. </p>

      <p> The web platform provides nothing at the moment to detect or
        signal termination, regardless of shared memory, and this is
        already a problem for developers.  However, in current web
        browsers dedicated workers are in-process and an agent cluster
        will normally terminate en masse, so the requirement is
        satisfied for now. </p>
    </emu-note>

  </emu-clause> <!-- agent cluster -->

</emu-clause>

<emu-clause id="GlobalObject">
  <h1>The Global Object (ES7 18)</h1>
  <emu-clause id="GlobalObject.ConstructorProps">
    <h1>Constructor Properties of the Global Object (ES7 18.3)</h1>
    <emu-clause id="GlobalObject.ConstructorProps.SharedArrayBuffer">
      <h1>SharedArrayBuffer</h1>
      <p> Add a new subsection for SharedArrayBuffer, pointing to the appropriate new section (below).</p>
    </emu-clause>
    <emu-clause id="GlobalObject.ConstructorProps.Atomics">
      <h1>Atomics</h1>
      <p> Add a new subsection for Atomics, pointing to the appropriate new section (below).</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<!--
AllocateTypedArray only allocates an ArrayBuffer if length is specified.
These call AllocateTypedArray with a specified length:
  TypedArrayFrom (twice)
   called from:
     %TypedArray% ( object )
     %TypedArray%.from ( source [,mapFn [,thisArg]] )
  %TypedArray%.of ( ...items ) 
  %TypedArray%.prototype.filter ( callbackFn [, thisArg] )
  %TypedArray%.prototype.slice ( start, end )
  %TypedArray% ()
  %TypedArray% (length)
  -->

<emu-clause id="IndexedCollections">
  <h1>Indexed Collections (ES7 22)</h1>
  <emu-clause id="IndexedCollections.TypedArray">
    <h1>TypedArray Objects (ES7 22.2)</h1>

    <emu-clause id="IndexedCollections.TypedArray.prototype">
      <h1>Properties of the %TypedArrayPrototype% object (ES7 22.2.3)</h1>
      <emu-clause id="IndexedCollections.TypedArray.prototype.set">
        <h1> %TypedArray%.prototype.set( overloaded [ , offset ] ) (ES7 22.2.3.23)</h1>
        <emu-clause id="IndexedCollections.TypedArray.prototype.setFromTypedArray">
          <h1>%TypedArray%.prototype.set( typedArray [, offset ] ) (ES7 22.2.3.23.2)</h1>
          <p>This algorithm is modified as follows:</p>
          <p>Sets multiple values in this _TypedArray_, reading the values from the _typedArray_ argument object. The optional _offset_ value indicates the first element index in this _TypedArray_ where values are written. If omitted, it is assumed to be 0.</p>
          <emu-alg>
            1. Assert: _typedArray_ has a [[TypedArrayName]] internal slot. If it does not, the definition in <emu-xref href="#sec-%typedarray%.prototype.set-array-offset"></emu-xref> applies.
            1. Let _target_ be the *this* value.
            1. If Type(_target_) is not Object, throw a *TypeError* exception.
            1. If _target_ does not have a [[TypedArrayName]] internal slot, throw a *TypeError* exception.
            1. Assert: _target_ has a [[ViewedArrayBuffer]] internal slot.
            1. Let _targetOffset_ be ? ToInteger(_offset_).
            1. If _targetOffset_ &lt; 0, throw a *RangeError* exception.
            1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].
            1. If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.
            1. Let _targetLength_ be _target_.[[ArrayLength]].
            1. Let _srcBuffer_ be _typedArray_.[[ViewedArrayBuffer]].
            1. If IsDetachedBuffer(_srcBuffer_) is *true*, throw a *TypeError* exception.
            1. Let _targetName_ be the String value of _target_.[[TypedArrayName]].
            1. Let _targetType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _targetName_.
            1. Let _targetElementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _targetName_.
            1. Let _targetByteOffset_ be _target_.[[ByteOffset]].
            1. Let _srcName_ be the String value of _typedArray_.[[TypedArrayName]].
            1. Let _srcType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _srcName_.
            1. Let _srcElementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _srcName_.
            1. Let _srcLength_ be _typedArray_.[[ArrayLength]].
            1. Let _srcByteOffset_ be _typedArray_.[[ByteOffset]].
            1. If _srcLength_ + _targetOffset_ &gt; _targetLength_, throw a *RangeError* exception.
            1. <ins>If Type(_x_) is SharedArrayBuffer, then let _same_ = SharedDataBlockID(_x_.[[SharedArrayBufferData]]) == SharedDataBlockID(_y_.[[SharedArrayBufferData]]); otherwise let _same_ = SameValue(_srcBuffer_, _targetBuffer_). </ins>
            1. <del>If SameValue(_srcBuffer_, _targetBuffer_)</del> <ins>_same_</ins> is *true*, then
              1. Let _srcBuffer_ be ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, _srcLength_, %ArrayBuffer%).
              1. NOTE: %ArrayBuffer% is used to clone _srcBuffer_ because is it known to not have any observable side-effects.
              1. Let _srcByteIndex_ be 0.
            1. Else, let _srcByteIndex_ be _srcByteOffset_.
            1. ...
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>
    
    <emu-clause id="IndexedCollections.TypedArray.constructors">
      <h1>The %TypedArray% constructors (ES7 22.2.4)</h1>

      <emu-clause id="IndexedCollections.TypedArray.intrinsic.constructFromObject">
        <h1>%TypedArray%( object ) (ES7 22.2.4.4)</h1>
        <p>This algorithm is modified as follows:</p>
        <p>This description applies only if the _TypedArray_ function is called with at least one argument and the Type of the first argument is Object and that object does not have either a [[TypedArrayName]] <del>or</del> <ins>,</ins> an [[ArrayBufferData]]<ins>, or a [[SharedArrayBufferData]]</ins> internal slot.</p>
        <p> ... </p>
      </emu-clause>

      <emu-clause id="IndexedCollections.TypedArray.intrinsic.constructFromBuffer">
        <h1>%TypedArray%( buffer [ , byteOffset [ , length ] ] ) (ES7 22.2.4.5)</h1>
        <p>This algorithm is modified as follows:</p>
        <p>This description applies only if the _TypedArray_ function is called with at least one argument and the Type of the first argument is Object and that object has an [[ArrayBufferData]] <ins>or [[SharedArrayBufferData]]</ins> internal slot.</p>
        <p>_TypedArray_ called with at least one argument _buffer_ performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_buffer_) is Object and _buffer_ has an [[ArrayBufferData]] <ins>or a [[SharedArrayBufferData]]</ins> internal slot.
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _constructorName_ be the String value of the Constructor Name value specified in <emu-xref href="#table-49"></emu-xref> for this <var>TypedArray</var> constructor.
          1. Let _O_ be ? AllocateTypedArray(_constructorName_, NewTarget, <code>"%<var>TypedArray</var>Prototype%"</code>).
          1. Let _constructorName_ be the String value of _O_.[[TypedArrayName]].
          1. Let _elementSize_ be the Number value of the Element Size value in <emu-xref href="#table-49"></emu-xref> for _constructorName_.
          1. Let _offset_ be ? ToIndex(_byteOffset_).
          1. If _offset_ modulo _elementSize_ &ne; 0, throw a *RangeError* exception.
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. <del>Let</del> <ins> If IsSharedMemory(_buffer_) then let _bufferByteLength_ be _buffer_.[[SharedArrayBufferByteLength]], otherwise let</ins> _bufferByteLength_ be _buffer_.[[ArrayBufferByteLength]].
          1. ...
        </emu-alg>
      </emu-clause>

    </emu-clause> <!-- intrinsic object -->

  </emu-clause>
</emu-clause>

<emu-clause id="StructuredData">
  <h1>Structured Data (ES7 24)</h1>

  <emu-clause id="StructuredData.ArrayBuffer">
    <h1>ArrayBuffer Objects (ES7 24.1)</h1>

    <emu-clause id="StructuredData.ArrayBuffer.abstract">
      <h1>Abstract Operations for ArrayBuffer (ES7 24.1.1)</h1>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.IsDetachedBuffer" aoid="IsDetachedBuffer">
        <h1>IsDetachedBuffer( arrayBuffer ) (ES7 24.1.1.2)</h1>
        <p> This algorithm is modified as follows: </p>
        <emu-alg>
          1. Assert: Type(_arrayBuffer_) is Object and it has an [[ArrayBufferData]] <ins>or a [[SharedArrayBufferData]]<ins> internal slot.
          1. If <ins>_arrayBuffer_ has an [[ArrayBufferData]] internal slot and</ins> _arrayBuffer_.[[ArrayBufferData]] is *null*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.CloneArrayBuffer" aoid="CloneArrayBuffer">
        <h1>CloneArrayBuffer( srcBuffer, srcByteOffset [, cloneConstructor] ) (ES7 24.1.1.4)</h1>
        <p>This algorithm is modified as follows:</p>
        <p> The abstract operation CloneArrayBuffer takes four parameters, an ArrayBuffer <ins>or SharedArrayBuffer</ins> _srcBuffer_, an integer offset _srcByteOffset_, an integer length _srcLength_, and optionally a constructor function _cloneConstructor_. It creates a new ArrayBuffer whose data is a copy of _srcBuffer_'s data over the range starting at _srcByteOffset_ and continuing for _srcLength_ bytes. This operation performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_srcBuffer_) is Object and it has an [[ArrayBufferData]] <ins>or [[SharedArrayBufferData]]</ins> internal slot.
          1. If _cloneConstructor_ is not present, then
            1. Let _cloneConstructor_ be ? SpeciesConstructor(_srcBuffer_, %ArrayBuffer%).
            1. If IsDetachedBuffer(_srcBuffer_) is *true*, throw a *TypeError* exception.
          1. Else, Assert: IsConstructor(_cloneConstructor_) is *true*.
          1. <del>Let</del> <ins>If IsSharedMemory(_srcBuffer_) then let _srcBlock_ be _srcBuffer_.[[SharedArrayBufferData]], else let</ins> _srcBlock_ be _srcBuffer_.[[ArrayBufferData]].
          1. ...
        </emu-alg>
      </emu-clause>
      
      <emu-clause id="StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" aoid="GetValueFromBuffer">
        <h1>GetValueFromBuffer( arrayBuffer, byteIndex, type, isLittleEndian ) (ES7 24.1.1.5)</h1>
        <p> This algorithm is modified as follows:</p>
        <p> The abstract operation GetValueFromBuffer takes four parameters, an ArrayBuffer <ins>or SharedArrayBuffer</ins> _arrayBuffer_, an integer _byteIndex_, a String _type_, and optionally a Boolean _isLittleEndian_. This operation performs the following steps:</p>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Assert: _byteIndex_ is an integer value &ge; 0.
          1. <del>Let</del> <ins>If IsSharedMemory(_arrayBuffer_) then let _block_ be _arrayBuffer_.[[SharedArrayBufferData]], else let</ins> _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
          1. Let _rawValue_ be a List of _elementSize_ containing, in order, the _elementSize_ sequence of bytes starting with _block_[_byteIndex_].
          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to <del>either *true* or *false*. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the SetValueInBuffer abstract operation</del> <ins>the value of the [[LittleEndian]] internal slot of the surrounding agent's Agent Record</ins>.
          1. ...
        </emu-alg>

        <emu-note>
          <p> If IsSharedMemory( _arrayBuffer_ ) is *true* then two consecutive calls to GetValueFromBuffer with the same arguments in the same agent may or may not return the same value even if there is no write to the buffer in that agent between the read calls: another agent may have written to the buffer. </p>
        </emu-note>

      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.SetValueInBuffer" aoid="SetValueInBuffer">
        <h1>SetValueInBuffer( arrayBuffer, byteIndex, type, value, isLittleEndian ) (ES7 24.1.1.6)</h1>
        <p> This algorithm is modified as follows:</p>
        <p> The abstract operation SetValueInBuffer takes five parameters, an ArrayBuffer <ins>or SharedArrayBuffer</ins> _arrayBuffer_, an integer _byteIndex_, a String _type_, a Number _value_, and optionally a Boolean _isLittleEndian_. This operation performs the following steps:</p>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Assert: _byteIndex_ is an integer value &ge; 0.
          1. Assert: Type(_value_) is Number.
          1. <del>Let</del> <ins>If IsSharedMemory(_arrayBuffer_) then let _block_ be _arrayBuffer_.[[SharedArrayBufferData]], else let</ins> _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Assert: _block_ is not *undefined*.
          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to <del>either *true* or *false*. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the GetValueFromBuffer abstract operation</del> <ins>the value of the [[LittleEndian]] internal slot of the surrounding agent's Agent Record</ins>.
          1. ...
        </emu-alg>

        <emu-note>
          <p> When SetValueInBuffer is called to set bytes in shared memory the implementation may set several bytes at a time (and that is the normal case), but it may not use read-modify-write on a larger datum, as that might introduce data races where the source program has none.  Data races are discussed in the section on the Atomics object. </p>
        </emu-note>
      </emu-clause>
      
    </emu-clause> <!-- abstract -->
  </emu-clause> <!-- ArrayBuffer -->

  <emu-clause id="StructuredData.DataView">
    <h1>DataView Objects (ES7 24.2)</h1>
    <emu-clause id="StructuredData.DataView.constructor">
      <h1>The DataView Constructor (ES7 24.2.2)</h1>
      <emu-clause id="StructuredData.DataView.constructor.detail">
        <h1>DataView( buffer [ , byteOffset [ , byteLength ] ] ) (ES7 24.2.2.1)</h1>
        <p> This algorithm is modified as follows: </p>
        <p>When the `DataView` is called with at least one argument _buffer_, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. If Type(_buffer_) is not Object, throw a *TypeError* exception.
          1. If _buffer_ does not have an [[ArrayBufferData]] <ins>or a [[SharedArrayBufferData]]</ins> internal slot, throw a *TypeError* exception.
          1. Let _offset_ be ? ToIndex(_byteOffset_).
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. <del>Let</del> <ins>If IsSharedMemory(_buffer_) then let _bufferByteLength_ be _buffer_.[[SharedArrayBufferByteLength]], else let</ins> _bufferByteLength_ be _buffer_.[[ArrayBufferByteLength]].
          1. ...
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause> <!-- DataView -->

  <emu-clause id="StructuredData.SharedArrayBuffer">
    <h1>SharedArrayBuffer Objects</h1>

    <emu-clause id="StructuredData.SharedArrayBuffer.abstract">
      <h1>Abstract Operations for SharedArrayBuffer</h1>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer">
        <h1>AllocateSharedArrayBuffer( constructor, byteLength )</h1>
        <p> The abstract operation AllocateSharedArrayBuffer with arguments _constructor_ and _byteLength_ is used to create a SharedArrayBuffer object. It performs the following steps:</p>

        <emu-alg>
          1. Let _obj_ be OrdinaryCreateFromConstructor(constructor, "%SharedArrayBufferPrototype%", «‍[[SharedArrayBufferData]], [[SharedArrayBufferByteLength]]» ).
          1. ReturnIfAbrupt(_obj_).
          1. Assert: _byteLength_ is a nonnegative integer.
          1. Let _block_ be CreateSharedByteDataBlock(_byteLength_).
          1. ReturnIfAbrupt(_block_).
          1. Set _obj_’s [[SharedArrayBufferData]] internal slot to block.
          1. Set _obj_’s [[SharedArrayBufferByteLength]] internal slot to _byteLength_.
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.IsSharedMemory" aoid="IsSharedMemory">
        <h1>IsSharedMemory( obj )</h1>
        <p> IsSharedMemory tests whether an object represents shared memory. </p>
        <emu-alg>
          1. Assert: Type(_obj_) is Object and it has an [[ArrayBufferData]] internal slot or a [[SharedArrayBufferData]] internal slot.
          1. If _obj_ has a [[SharedArrayBufferData]] internal slot then return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

    </emu-clause> <!-- abstract -->

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor">
      <h1>The SharedArrayBuffer Constructor</h1>
      <p> The SharedArrayBuffer constructor is the %SharedArrayBuffer% intrinsic object and the initial value of the `SharedArrayBuffer` property of the global object. When called as a constructor it creates and initializes a new SharedArrayBuffer object.  The SharedArrayBuffer constructor is not intended to be called as a function and will throw an exception when called in that manner. </p>

      <p> The SharedArrayBuffer constructor is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified SharedArrayBuffer behaviour must include a `super` call to the SharedArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support the `SharedArrayBuffer.prototype` built-in methods. </p>

      <emu-note>
        <p> Unlike an ArrayBuffer, a SharedArrayBuffer cannot become detached, and its internal [[SharedArrayBufferData]] slot is never *undefined*.</p>
      </emu-note>
      
      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.withLength">
        <h1>SharedArrayBuffer( length )</h1>
        <p> SharedArrayBuffer called with argument length performs the following steps: </p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _numberLength_ be ToNumber(_length_).
          1. Let _byteLength_ be ToLength(_numberLength_).
          1. ReturnIfAbrupt(_byteLength_).
          1. If SameValueZero(_numberLength_, _byteLength_) is *false*, throw a *RangeError* exception.
          1. Return AllocateSharedArrayBuffer(NewTarget, _byteLength_).
        </emu-alg>
      </emu-clause>
    </emu-clause> <!-- constructor -->

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties">
      <h1>Properties of the SharedArrayBuffer constructor</h1>

      <p>The value of the [[Prototype]] internal slot of the SharedArrayBuffer constructor is the intrinsic object %FunctionPrototype% (q.v.).</p>

      <p>Besides its `length` property (whose value is 1), the SharedArrayBuffer constructor has the following properties:</p>
      
      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.prototype">
        <h1>SharedArrayBuffer.prototype</h1>
        <p> The initial value of SharedArrayBuffer.prototype is the intrinsic object %SharedArrayBufferPrototype% (q.v.).</P>
        <p> This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.get_species">
        <h1>get SharedArrayBuffer [ @@species ]</h1>
        <P>`SharedArrayBuffer[@@species]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</P>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <P> The value of the name property of this function is "`get [Symbol.species]`".</P>
      </emu-clause>
    </emu-clause> <!-- properties -->

    <emu-clause id="StructuredData.SharedArrayBuffer.prototype">
      <h1>Properties of the SharedArrayBuffer prototype object</h1>

      <p>The SharedArrayBuffer prototype object is the intrinsic object %SharedArrayBufferPrototype%. The value of the [[Prototype]] internal slot of the SharedArrayBuffer prototype object is the intrinsic object %ObjectPrototype% (19.1.3). The SharedArrayBuffer prototype object is an ordinary object. It does not have a [[SharedArrayBufferData]] or [[SharedArrayBufferByteLength]] internal slot.</p>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.get_byteLength">
        <h1>get SharedArrayBuffer.prototype.byteLength</h1>

        <p> SharedArrayBuffer.prototype.byteLength is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps: </P>

        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. If _O_ does not have a [[SharedArrayBufferData]] internal slot, throw a *TypeError* exception.
          1. Let _length_ be the value of _O_’s [[SharedArrayBufferByteLength]] internal slot.
          1. Return _length_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.constructor">
        <h1>SharedArrayBuffer.prototype.constructor</h1>
        <p> The initial value of `SharedArrayBuffer.prototype.constructor` is the intrinsic object %SharedArrayBuffer%. </p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.slice">
        <h1>SharedArrayBuffer.prototype.slice( start, end )</h1>
        <p> The following steps are taken: </p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. If _O_ does not have a [[SharedArrayBufferData]] internal slot, throw a *TypeError* exception.
          1. Let _len_ be the value of _O_’s [[SharedArrayBufferByteLength]] internal slot.
          1. Let _relativeStart_ be ToInteger(_start_).
          1. ReturnIfAbrupt(_relativeStart_).
          1. If _relativeStart_ &lt; 0, let first be max((_len_ + _relativeStart_), 0); else let first be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ToInteger(_end_).
          1. ReturnIfAbrupt(_relativeEnd_).
          1. If _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_), 0); else let _final_ be min(_relativeEnd_, _len_).
          1. Let _newLen_ be max(_final_ - _first_, 0).
          1. Let _ctor_ be SpeciesConstructor(_O_, %SharedArrayBuffer%).
          1. ReturnIfAbrupt(_ctor_).
          1. Let _new_ be Construct(_ctor_, «newLen»).
          1. ReturnIfAbrupt(_new_).
          1. If _new_ does not have a [[SharedArrayBufferData]] internal slot, throw a *TypeError* exception.
          1. If SameValue(_new_, _O_) is *true*, throw a *TypeError* exception.
          1. If the value of _new_’s [[SharedArrayBufferByteLength]] internal slot &lt; _newLen_, throw a *TypeError* exception.
          1. Let _fromBuf_ be the value of _O_’s [[SharedArrayBufferData]] internal slot.
          1. Let _toBuf_ be the value of _new_’s [[SharedArrayBufferData]] internal slot.
          1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_).
          1. Return _new_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.toString">
        <h1>SharedArrayBuffer.prototype[ @@toStringTag ]</h1>
        <p> The initial value of the @@toStringTag property is the String value `"SharedArrayBuffer"`.</p>

        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause> <!-- prototype -->

    <emu-clause id="StructuredData.SharedArrayBuffer.instances">
      <h1>Properties of the SharedArrayBuffer instances</h1>

      <p> SharedArrayBuffer instances inherit properties from the SharedArrayBuffer prototype object. SharedArrayBuffer instances each have a [[SharedArrayBufferData]] internal slot and a [[SharedArrayBufferByteLength]] internal slot. </p>

      <emu-note>
        <p> SharedArrayBuffer instances, unlike ArrayBuffer instances, are never detached. </p>
      </emu-note>
    </emu-clause> <!-- instances -->

  </emu-clause> <!-- SharedArrayBuffer -->
</emu-clause> <!-- Structured data -->

<emu-clause id="AtomicsObject">
  <h1>The Atomics Object</h1>
  
  <emu-clause id="AtomicsObjectFunctionProps.semantics">
    <h1>Runtime semantics</h1>
    
    <emu-clause id="Atomics.WithAtomicAccessTo">
      <h1>With atomic access to shared memory</h1>
      
      <p> Let <em>atomic accesses</em> be those algorithm steps that
        are labeled "With atomic access to shared memory" in the
        algorithms below, ie, atomic load, atomic store, and the
        atomic read-modify-write operations add, sub, and, or, xor,
        exchange, and compareExchange.</p>

      <p> Let <em>data accesses</em> be those invocations of
        GetValueFromBuffer() and SetValueInBuffer() that are not part
        of atomic accesses, when those invocations' _arrayBuffer_
        argument is a SharedArrayBuffer. </p>
        
      <p> Let the <em>access range</em> of an atomic or data access be the
        memory cells read or written by the access. </p>

      <p> Atomic accesses that are <em>viable</em> are performed in a
        single total order (the <em>synchronization order</em>)
        consistent with each agent's program order.  An atomic access
        is not viable if its access range intersects with but is not
        equal to the access range of another atomic access from
        another agent that could be adjacent to it in the total order.
        (None of the accesses that intersect in that way are
        viable.) </p>

      <emu-note>
        <p> ECMAScript allows TypedArrays to alias each other and
          exposes atomic accesses directly on TypedArrays.  It is thus
          possible for atomic accesses of different size to partly
          overlapping access ranges to be performed concurrently.
          Requiring overlapping concurrent atomic accesses to be part
          of the total atomics order would impose significant run-time
          costs on some, possibly all, platforms.</p>

        <p> For example, on a platform such as MIPS32 that only has
          4-byte atomics, an 8-byte atomic access (eg for Int64) must
          be implemented with a lock, yet it is desirable to implement
          4-byte atomic accesses directly.  Requiring overlapping
          concurrent accesses to be part of the total atomics order
          would require all atomic accesses to use the lock. </p>

        <p> In a more general case, if we were to provide a method to
          (say) atomically compare-and-exchange a larger region of
          memory, such a primitive would have to use a lock on
          virtually all platforms, forcing all platforms to use locks
          even for smaller atomic accesses. </p>
      </emu-note>

      <p> In the following, "atomic access" refers only to viable
        atomic accesses, and "data access" refers also to non-viable
        atomic accesses. </p>
      
      <p> An <em>event</em> in an agent is an atomic access, a
        data access, the sending of a SharedArrayBuffer, the receipt
        of a SharedArrayBuffer, the action of waking up a sleeping
        agent, or a sleeping agent being woken up.  Events can also be
        embedding-specific. </p>

      <emu-note>
        <p> Examples of embedding-specific events are starting and stopping agents
          and communicating via other channels than shared memory. </p>
      </emu-note>

      <p> An event A <em>happens before</em> another event B if either:</p>
      <ol>
        <li> A precedes B in an agent's program order,
        <li> A is the sending of a SharedArrayBuffer and B is the
        receipt in another agent of that buffer,
        <li> A is the waking up a sleeping agent and B the agent being
          woken up,
        <li> A and B are paired embedding-specific events in separate
          agents where the embedding states that A happens before B,
        <li> A and B are both atomic accesses to identical access ranges,
          B follows A in the synchronization order, and B reads
          the value written by A, or
        <li> A happens before C and C happens before B (transitivity).
      </ol>

      <p> Executions must be such that <em>happens before</em> is
        irreflexive (acyclic). </p>

      <emu-note>
        <p> If a call to Atomics.wait returns `"not-equal"` then
          there is a happens-before relation between any atomic write
          that wrote the slot that is read by those functions, because
          those functions use an atomic read to read that slot. </p>
      </emu-note>

      <p> A data access read R only sees a write W that happens before
        R, where there is no write V such that V happens before R and
        W happens before V. </p>
      
      <p> An atomic read R sees either the last preceding (in
        synchronization order) atomic write U to the same location, or
        a non-atomic write W that happens before R, where there is no
        write V such that V happens before R and W happens before
        V. </p>

      <p> Two memory accesses whose access ranges intersect constitute
        a <em>data race</em> if neither happens before the other, at
        least one of them is not an atomic access, and at least one of
        them is a write. </p>

      <emu-note>
        <p> If the execution of an agent cluster has no data races, then
          the agent cluster behaves according to one of its sequentially
          consistent executions. </p>
      </emu-note>

      <p> The race affects the union of the access ranges involved in
        the race, for the duration of the race.  The race ends only
        when all the threads involved in the race have synchronized. </p>

      <emu-note>
        <p> (Spec draft note) The race starts after the last
          preceding synchronization, but do we need to specify that further? </p>
      </emu-note>
      
      <p> The access ranges involved in a race will contain
        unpredictable values for the duration of the race, according to the
        following rules: </p>

      <ol>
        <li> A read from shared memory always produces a value.
        <li> The shared memory will always honor a write, but if there
          is a race the memory can arbitrarily select bits from the
          operands of the racing writes and the previous memory contents
          at the racy written-to locations.
        <li> The values at racy locations are not stable
          until the race has ended.
      </ol>

      <emu-note>
        <p> Mainstream memories behave according to these rules, so
          the rules are really restrictions on the compiler: if there
          is a race, and the compiler can prove that there is a race,
          it still must not produce a completely arbitrary value (thus
          risking revealing a secret by eg reusing register contents),
          but must produce a value that could be a combination of some
          values written to memory. (It could produce the last value
          written by the thread executing the read.) </p>

        <p> The third rule precludes a so-called rematerialization
          optimization, where a read from shared memory can be
          performed multiple times in such a way that several
          different values are observed for what is a single value in
          the semantics.  If `mem` is some integer TypedArray the
          following program is not allowed to print 0: </p>
        <pre>
        let x = mem[n];
        if (x)
          print(x);
        </pre>
      </emu-note>

      <emu-note>
        <p> Although the rules above restrict the values that can be
          written to racy locations, races have highly unpredictable
          consequences: a racy -- ie largely unpredictable and
          non-portable -- value used in a condition can confuse the
          program and cause it to compute nonsensical or undesirable
          results which are then used in further computations. </p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.ValidateSharedIntegerTypedArray" aoid="ValidateSharedIntegerTypedArray">
      <h1>Runtime semantics: ValidateSharedIntegerTypedArray( typedArray [, onlyInt32] )</h1>
      <emu-alg>
        1. If Type(_typedArray_) is not Object, throw a *TypeError* exception.
        1. If _typedArray_ does not have a [[TypedArrayName]] internal slot, throw a *TypeError* exception.
        1. Let _typeName_ be the value of _typedArray_'s [[TypedArrayName]] internal slot
        1. If _onlyInt32_ is *true* then
          1. If _typeName_ is not "Int32Array" then throw a *TypeError* exception
        1. Else
          1. If _typeName_ is not "Int8Array", "Uint8Array", "Int16Array", "Uint16Array", "Int32Array", or "Uint32Array" then throw a *TypeError* exception
        1. If _typedArray_ does not have a [[ViewedArrayBuffer]] internal slot, throw a *TypeError* exception.
        1. Let _buffer_ be the value of _typedArray_’s [[ViewedArrayBuffer]] internal slot
        1. If Type(_buffer_) is not Object, throw a *TypeError* exception
        1. If _buffer_ does not have a [[SharedArrayBufferData]] internal slot, throw a *TypeError* exception
        1. Return _buffer_
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.ValidateAtomicAccess" aoid="ValidateAtomicAccess">
      <h1>Runtime semantics: ValidateAtomicAccess( typedArray, requestIndex )</h1>
      <P> Perform the following steps: </p>
      <emu-alg>
        1. Assert: _typedArray_ is an Object that has a [[ViewedArrayBuffer]] internal slot
        1. Let _numberIndex_ be ToNumber(_requestIndex_)
        1. ReturnIfAbrupt(_numberIndex_)
        1. Let _accessIndex_ be ToInteger(_numberIndex_)
        1. If _numberIndex_ &ne; _accessIndex_, throw a *RangeError* exception
        1. Let _length_ be the value of _typedArray_'s [[ArrayLength]] internal slot
        1. If _accessIndex_ &lt; 0 or _accessIndex_ &ge; _length_, throw a *RangeError* exception
        1. Return _accessIndex_
      </emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.AgentSignifier" aoid="AgentSignifier">
      <h1>Runtime semantics: AgentSignifier( )</h1>
      <p> When AgentSignifier is called without arguments then the following steps are taken.</p>
      <emu-alg>
        1. Let _W_ be the value of the [[Signifier]] property of the Agent Record of the <em>surrounding agent</em>.
        2. Return _W_.
      </emu-alg>

    </emu-clause>
    
    <emu-clause id="Atomics.AgentCanSuspend" aoid="AgentCanSuspend">
      <h1>Runtime semantics: AgentCanSuspend( )</h1>
      <p> When AgentCanSuspend is called without arguments then the following steps are taken.</p>
      <emu-alg>
        1. Let _B_ be the value of the [[CanBlock]] property of the Agent Record of the <em>surrounding agent</em>.
        2. Return _B_.
      </emu-alg>

      <emu-note>
        <p> In some environments it may not be reasonable for a given agent to suspend.  For example,
          in a web browser environment, it may be reasonable to disallow suspending a document's main event
          handling thread, while still allowing workers' event handling threads to suspend. </p>
      </emu-note>

    </emu-clause>
    
    <emu-clause id="GetWaiterList">
      <h1>Runtime semantics: GetWaiterList( G, i )</h1>
      <p> A <dfn>WaiterList</dfn> is a semantic object that contains an ordered list of those agents that are waiting on a location (_G_, _i_) in shared memory; _G_ is a Shared Data Block ID and _i_ a byte offset into the memory referenced by _G_. </p>
      <p> The agent cluster has a store of WaiterList objects; the store is indexed by (_G_, _i_).  WaiterLists are agent-independent: a lookup in the store of WaiterLists by (_G_, _i_) will result in the same WaiterList object in any agent in the agent cluster. </p>
      <p> Operations on a WaiterList -- adding and removing waiting agents, traversing the list of agents, suspending and waking agents on the list -- may only be performed by agents that have entered the WaiterList's critical section.  </p>
      <p> When GetWaiterList is called with Shared Data Block ID _G_ and nonnegative integer _i_, then the following steps are taken. </p>
      <emu-alg>
        1. Assert: _G_ is the Shared Data Block ID of some Shared Data Block
        1. Assert: _i_ and _i_+3 are valid byte offsets within the memory referenced by _G_
        1. Assert: _i_ is divisible by 4
        1. Return the WaiterList that is referenced by the pair (_G_, _i_)
      </emu-alg>
    </emu-clause>

    <emu-clause id="EnterCriticalSection">
      <h1>Runtime semantics: EnterCriticalSection( WL )</h1>
      <p> When EnterCriticalSection is called with WaiterList _WL_, then the following steps are taken. </p>
      <emu-alg>
        1. Assert: The calling agent is not in the critical section for any WaiterList
        1. Wait until no agent is in the critical section for _WL_, then enter the critical section for _WL_
      </emu-alg>
    </emu-clause>

    <emu-clause id="LeaveCriticalSection">
      <h1>Runtime semantics: LeaveCriticalSection( WL )</h1>
      <p> When LeaveCriticalSection is called with WaiterList _WL_, then the following steps are taken. </p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_
        1. Leave the critical section for _WL_
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.AddWaiter" aoid="AddWaiter">
      <h1>Runtime semantics: AddWaiter( WL, W )</h1>
      <p> When AddWaiter is called with WaiterList _WL_ and agent signifier _W_, then the following steps are taken. </p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_
        1. Assert: _W_ is not on the list of waiters in any WaiterList
        1. Add _W_ to the end of the list of waiters in _WL_
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.RemoveWaiter" aoid="RemoveWaiter">
      <h1>Runtime semantics: RemoveWaiter( WL, W )</h1>
      <p> When RemoveWaiter is called with WaiterList _WL_ and agent signifier _W_, then the following steps are taken. </p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_
        1. Assert: _W_ is on the list of waiters in _WL_
        1. Remove _W_ from the list of waiters in _WL_
      </emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.RemoveWaiters" aoid="RemoveWaiters">
      <h1>Runtime semantics: RemoveWaiters( WL, c )</h1>
      <p> When RemoveWaiters is called with WaiterList _WL_ and nonnegative integer _c_, then the following steps are taken. </p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_
        1. Let _L_ be the empty list
        1. Let _S_ be a reference to the list of waiters in _WL_
        1. While _c_ &gt; 0 and _S_ is not the empty list:
          1. Let _W_ be the first worker in _S_
          1. Add _W_ to the end of _L_
          1. Remove _W_ from _S_
          1. Subtract 1 from _c_
        1. Return _L_
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.Suspend" aoid="Suspend">
      <h1>Runtime semantics: Suspend( WL, W, timeout )</h1>
      <p> When Suspend is called with WaiterList _WL_, agent signifier _W_, and nonnegative number _timeout_, then the following steps are taken. </p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_
        1. Assert: The calling agent is on the list of waiters in _WL_
        1. Assert: _W_ is equal to AgentSignifier()
        1. Assert: AgentCanSuspend() is equal to true
        1. Call LeaveCriticalSection( _WL_ ) and suspend _W_ for up to _timeout_ milliseconds, performing the combined operation in such a way that a wakeup that arrives after the critical section is exited but before the suspension takes effect is not lost.  _W_ can wake up either because the timeout expired or because it was woken explicitly by another agent calling WakeWaiter(_WL_, _W_), and not for any other reasons at all.
        1. Call EnterCriticalSection( _WL_ )
        1. If _W_ was woken explicitly by another agent calling WakeWaiter(_WL_, _W_), then return *true*
        1. Return *false*
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.WakeWaiter" aoid="WakeWaiter">
      <h1>Runtime semantics: WakeWaiter( WL, W )</h1>
      <p> When WakeWaiter is called with WaiterList _WL_ and agent signifier _W_, then the following steps are taken. </p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_
        1. Assert: _W_ is on the list of waiters in _WL_
        1. Wake the agent _W_
      </emu-alg>

      <emu-note>
        <p> The embedding may delay waking _W_, eg for resource management reasons, but _W_ must eventually be woken in order to guarantee forward progress. </p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.FetchOp" aoid="AtomicFetchOp">
      <h1>Runtime semantics: AtomicFetchOp( typedArray, index, value, op )</h1>
      <p> AtomicFetchOp is a semantic function that atomically loads
        a value, combines it with another value, and stores the result
        of the combination.  It returns the loaded value.  It is
        parameterized by the (pure) combining operation.  The following
        steps are taken: </p>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_typedArray_)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _typedArray_, _index_ )
        1. ReturnIfAbrupt(_i_)
        1. Let _v_ be ToInteger(_value_)
        1. ReturnIfAbrupt(_value_).
        1. Let _arrayTypeName_ be the value of _typedArray_'s [[TypedArrayName]] internal slot
        1. Let _elementSize_ be the Number value of the Element Size value specified in Table 49 for _arrayTypeName_.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for _arrayTypeName_.
        1. Let _offset_ be the value of _typedArray_’s [[ByteOffset]] internal slot.
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_
        1. With atomic access to shared memory, do:
          1. Let _r_ be the result of GetValueFromBuffer( _buffer_, _indexedPosition_, _elementType_ )
          1. Compute: Let _w_ be _op_(_r_, _v_)
          1. Call SetValueInBuffer( _buffer_, _indexedPosition_, _elementType_, _w_ )
        1. Return _r_
      </emu-alg>
    </emu-clause>
  </emu-clause> <!-- runtime semantics -->

  <emu-clause id="AtomicsObjectFunctionProps">
    <h1>Function Properties of the Atomics Object</h1>

    <emu-clause id="Atomics.add">
      <h1>Atomics.add( typedArray, index, value )</h1>
      <p> Let `add` denote a semantic function of two number arguments that returns the sum of the arguments. </p>
      <p> The following steps are taken: </p>
      <emu-alg>
        1. Let _result_ be AtomicFetchOp( _typedArray_, _index_, _value_, `add` )
        1. ReturnIfAbrupt(_result_)
        1. Return _result_
      </emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.and">
      <h1>Atomics.and( typedArray, index, value )</h1>
      <p> Let `and` denote a semantic function of two number arguments that returns the bitwise "and" of the arguments. </p>
      <p> The following steps are taken: </p>
      <emu-alg>
        1. Let _result_ be AtomicFetchOp( _typedArray_, _index_, _value_, `and` )
        1. ReturnIfAbrupt(_result_)
        1. Return _result_
      </emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.compareExchange">
      <h1>Atomics.compareExchange( typedArray, index, expectedValue, replacementValue )</h1>
      <p> The following steps are taken: </p>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_typedArray_)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _typedArray_, _index_ )
        1. ReturnIfAbrupt(_i_)
        1. Let _expected_ be ToInteger(_expectedValue_)
        1. ReturnIfAbrupt(_expected_)
        1. Let _replacement_ be ToInteger(_replacedValue_)
        1. ReturnIfAbrupt(_replacement_)
        1. Let _arrayTypeName_ be the value of _typedArray_'s [[TypedArrayName]] internal slot
        1. Let _convOp_ be the conversion operation specified in Table 49 for _arrayTypeName_
        1. Let _x_ be _convOp_ ( _expected_ )
        1. Let _elementSize_ be the Number value of the Element Size value specified in Table 49 for _arrayTypeName_.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for _arrayTypeName_.
        1. Let _offset_ be the value of _typedArray_’s [[ByteOffset]] internal slot.
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_
        1. With atomic access to shared memory, do:
          1. Let _r_ be GetValueFromBuffer( _buffer_, _indexedPosition_, _elementType_ )
          1. If _r_ is the same as _x_ then:
            1. Call SetValueInBuffer( _buffer_, _indexedPosition_, _elementType_, _replacement_ )
        1. Return _r_
      </emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.exchange">
      <h1>Atomics.exchange( typedArray, index, value )</h1>
      <p> Let `second` denote a semantic function of two number arguments that returns its second argument. </p>
      <p> The following steps are taken: </p>
      <emu-alg>
        1. Let _result_ be AtomicFetchOp( _typedArray_, _index_, _value_, `second` )
        1. ReturnIfAbrupt(_result_)
        1. Return _result_
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.wait">
      <h1>Atomics.wait( typedArray, index, value, timeout )</h1>
      <p> Atomics.wait puts the calling agent in a wait queue and puts it to sleep until it is awoken or the sleep times out. The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_typedArray_, *true*)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _typedArray_, _index_ )
        1. ReturnIfAbrupt(_i_)
        1. Let _v_ be the result of ToInt32(_value_).
        1. ReturnIfAbrupt(_v_)
        1. If _timeout_ is not provided or is *undefined* then let _t_ be *+&infin;*.  Otherwise:
          1. Let _q_ be the result of ToNumber(_timeout_)
          1. ReturnIfAbrupt(_q_)
          1. If _q_ is *NaN* then let _t_ be *+&infin;*, otherwise let _t_ be max(0, _q_).
        1. Let _B_ be AgentCanSuspend()
        1. If _B_ is *false* then throw a *TypeError* exception.
        1. Let _bufferVal_ be the value of the internal [[SharedArrayBufferData]] property of _buffer_.
        1. Let _G_ be SharedDataBlockID(_bufferVal_)
        1. Let _arrayTypeName_ be the value of _typedArray_'s [[TypedArrayName]] internal slot
        1. Let _offset_ be the value of _typedArray_'s [[ByteOffset]] internal slot.
        1. Let _indexedPosition_ be (_i_ &times; 4) + _offset_
        1. Let _WL_ be GetWaiterList(_G_, _indexedPosition_)
        1. Call EnterCriticalSection(_WL_)
        1. Let _w_ be Atomics.load(_typedArray_, _i_)
        1. If _v_ does not equal _w_ then:
          1. Call LeaveCriticalSection(_WL_)
          1. Return the string `"not-equal"`.
        1. Let _W_ be AgentSignifier().
        1. Call AddWaiter(_WL_, _W_)
        1. Let awoken = Suspend(_WL_, _W_, _t_)
        1. Call RemoveWaiter(_WL_, _W_)
        1. Call LeaveCriticalSection(_WL_)
        1. If awoken is *true* then return the string `"ok"`.
        1. Return the string `"timed-out"`.
      </emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.wake">
      <h1>Atomics.wake( typedArray, index, count )</h1>
      <p> Atomics.wake wakes up some agents that are sleeping in the wait queue.  The following steps are taken: </p>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray( _typedArray_, *true* )
        1. ReturnIfAbrupt( _buffer_ )
        1. Let _i_ be ValidateAtomicAccess( _typedArray_, _index_ )
        1. ReturnIfAbrupt( _i_ )
        1. If _count_ is not provided or is *undefined* then let _c_ be *+&infin;*.  Otherwise:
          1. Let _tmp_ be ToInteger( _count_ )
          1. ReturnIfAbrupt( _tmp_ )
          1. Let _c_ be max( *+0*, _tmp_ ).
        1. Let _bufferVal_ be the value of the internal [[SharedArrayBufferData]] property of _buffer_.
        1. Let _G_ be SharedDataBlockID( _bufferVal_ )
        1. Let _arrayTypeName_ be the value of _typedArray_'s [[TypedArrayName]] internal slot
        1. Let _offset_ be the value of _typedArray_'s [[ByteOffset]] internal slot.
        1. Let _indexedPosition_ be (_i_ &times; 4) + _offset_
        1. Let _WL_ be GetWaiterList(_G_, _indexedPosition_)
        1. Let _n_ = 0
        1. Call EnterCriticalSection(_WL_):
        1. Let _S_ be RemoveWaiters( _WL_, _c_ )
        1. While _S_ is not the empty list:
          1. Let _W_ be the first agent in _S_
          1. Remove _W_ from the front of _S_
          1. Call WakeWaiter( _WL_, _W_ )
          1. Add 1 to _n_
        1. Call LeaveCriticalSection(_WL_)
        1. Return _n_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.isLockFree">
      <h1>Atomics.isLockFree( size )</h1>

      <emu-alg>
        1. Let _n_ be ToInteger(_size_)
        1. ReturnIfAbrupt(_n_)
        1. If _n_ equals 1 then return the value of the [[IsLockFree1]] property of the Agent Record of the <em>surrounding agent</em>.
        1. If _n_ equals 2 then return the value of the [[IsLockFree2]] property of the Agent Record of the <em>surrounding agent</em>.
        1. If _n_ equals 4 then return *true*.
        1. Return *false*
      </emu-alg>

      <emu-note>
        <p> Atomics.isLockFree() is an optimization primitive.  The
          intuition is that if the atomic step of an atomic primitive
          (compareExchange, load, store, add, sub, and, or, xor, or
          exchange) on a datum of size _n_ bytes will be performed
          without the calling agent acquiring a lock outside the _n_
          bytes comprising the datum, then Atomics.isLockFree(_n_)
          will return *true*.  High-performance algorithms will use
          Atomics.isLockFree() to determine whether to use locks or
          atomic operations in critical sections.  If an atomic
          primitive is not lock-free then it is often more efficient
          for an algorithm to provide its own locking. </p>

        <p> Atomics.isLockFree(4) always returns *true* as that can be
          supported on all known relevant hardware.  Being able to
          assume this will generally simplify programs. </p>

      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.load">
      <h1>Atomics.load( typedArray, index )</h1>
      <p> The following steps are taken: </p>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_typedArray_)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _typedArray_, _index_ )
        1. ReturnIfAbrupt(_i_)
        1. Let _arrayTypeName_ be the value of _typedArray_'s [[TypedArrayName]] internal slot
        1. Let _elementSize_ be the Number value of the Element Size value specified in Table 49 for _arrayTypeName_.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for _arrayTypeName_.
        1. Let _offset_ be the value of _typedArray_’s [[ByteOffset]] internal slot.
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_
        1. With atomic access to shared memory, do:
          1. Let _r_ be the result of GetValueFromBuffer( _buffer_, _indexedPosition_, _elementType_ )
        1. Return _r_
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.or">
      <h1>Atomics.or( typedArray, index, value )</h1>
      <p> Let `or` denote a semantic function of two number arguments that returns the bitwise "or" of the arguments. </p>
      <p> The following steps are taken: </p>
      <emu-alg>
        1. Let _result_ be AtomicFetchOp( _typedArray_, _index_, _value_, `or` )
        1. ReturnIfAbrupt(_result_)
        1. Return _result_
      </emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.store">
      <h1>Atomics.store( typedArray, index, value )</h1>
      <p> The following steps are taken: </p>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_typedArray_)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _typedArray_, _index_ )
        1. ReturnIfAbrupt(_i_)
        1. Let _v_ be ToInteger(_value_)
        1. ReturnIfAbrupt(_v_)
        1. Let _arrayTypeName_ be the value of _typedArray_'s [[TypedArrayName]] internal slot
        1. Let _elementSize_ be the Number value of the Element Size value specified in Table 49 for _arrayTypeName_.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for _arrayTypeName_.
        1. Let _offset_ be the value of _typedArray_’s [[ByteOffset]] internal slot.
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_
        1. With atomic access to shared memory, do:
          1. Call SetValueInBuffer( _buffer_, _indexedPosition_, _elementType_, _v_ )
        1. Return _v_
      </emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.sub">
      <h1>Atomics.sub( typedArray, index, value )</h1>
      <p> Let `subtract` denote a semantic function of two number arguments that returns the difference of the arguments. </p>
      <p> The following steps are taken: </p>
      <emu-alg>
        1. Let _result_ be AtomicFetchOp( _typedArray_, _index_, _value_, `subtract` )
        1. ReturnIfAbrupt(_result_)
        1. Return _result_
      </emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.xor">
      <h1>Atomics.xor( typedArray, index, value )</h1>
      <p> Let `xor` denote a semantic function of two number arguments that returns the bitwise "xor" of the arguments. </p>
      <p> The following steps are taken: </p>
      <emu-alg>
        1. Let _result_ be AtomicFetchOp( _typedArray_, _index_, _value_, `xor` )
        1. ReturnIfAbrupt(_result_)
        1. Return _result_
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="WebBrowserEmbedding">
  <h1>Web browser embedding (informative)</h1>

  <p> This section outlines how the Shared Memory and Atomics
    specification fits into the current web ecosystem with the minimum
    amount of change to that ecosystem.  This section is not part of
    the proposal, it is informative only.  </p>

  <p> In a web browser an <em>agent</em> is an HTML <em>event
    loop</em> <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">[here]</a>.
    The event loop is realized as either a main thread (which may be
    shared among tabs, as it is in Firefox) or some type of worker
    thread.  The event loops are running jobs in the sense of ES262,
    and the forward-progress requirement of this specification
    (section&nbsp;3.1.1) is generally met as long as each agent has
    its own dedicated operating system thread or shared-thread agents
    can't block. </p>
    
  <p> Browsers will typically let agents that run on the browser's
    main thread have [[CanBlock]] = *false*, to prevent blocking the
    UI and to allow the main thread to do work on behalf of other
    threads. </p>

  <p> Normal ("dedicated") `Worker`s will be supported as agents.

  <p> Memory will be shared among agents by means of using
    `postMessage` to transmit `SharedArrayBuffer` and `TypedArray`
    objects that have `SharedArrayBuffer` buffers; this requires an
    extension to the Structured Clone mechanism.  There is agreement
    on the general syntax and semantics for this extension. </p>
    
  <p> Agent-to-agent communication extends the happens-before relation
    of the program, as follows:</p>

  <ul>
    <li> The call to the `Worker` constructor in the parent
      happens-before the execution of the main script in the worker.

    <li> (Worker termination is not directly observable in current
      browsers, see below.)

    <li> A `postMessage` to another agent happens-before the event
      fires in the agent.
  </ul>

  <p> If the browser does not allow a `ServiceWorker` or
    `SharedWorker` ("non-page worker") to share memory with a `Worker`
    it will not violate the suspend/wake cohort rule of this
    specification (section&nbsp;3.3).  The restriction on sharing
    memory can be implemented in the extension to the Structured Clone
    mechanism.  For example, a non-page worker may simply not be
    allowed to receive shared memory (leading to a null value or an
    error signal).  There is not yet any agreement on this point, but
    it is clear that the restriction must be on the receiving side of
    the communication, as the sender may be sending on a `MessagePort`
    that is not yet connected, but may in the future be connected to
    either a valid or invalid recipient. </p>

  <p> At the moment, I believe dedicated workers are in the same
    process as their owning tab in all browsers, so if the process
    crashes then the workers will crash too.  I also don't know any
    reason a browser should forcibly terminate a worker except when a
    tab is closed.  In sum, the termination signaling requirement of
    this specification (section&nbsp;3.3) is probably met by existing
    browsers, or can be met easily. </p>

  <p> The web platform should evolve to serve the shared memory use
    case better: by incorporating inspectable worker state and worker
    lifecycle events, and by tightening the wording in the HTML spec
    (currently the browser is allowed to kill a worker at any time for
    any reason, which is not quite what we want).  WebIDL should
    evolve to allow Web APIs to be described as to when they can and
    cannot receive shared memory parameters.  However, only an
    extension to the Structured Clone algorithm is needed to support
    the Shared Memory and Atomics specification in practice on current
    browsers. </p>
    
</emu-clause>

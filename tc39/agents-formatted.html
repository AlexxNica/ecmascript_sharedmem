<!doctype html>
<head><meta charset="utf-8">
<title>DOM/ECMAScript "Agents"</title>
<script src="https://bterlson.github.io/ecmarkup/ecmarkup.js"></script>
<link rel="stylesheet" href="https://bterlson.github.io/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">

<script type="application/json" id="menu-search-biblio">{"clauses":{"intro":{"location":"","id":"intro","aoid":null,"title":"Introduction","number":""},"ExecutableCodeAndContexts":{"location":"","id":"ExecutableCodeAndContexts","aoid":null,"title":"Executable Code and Execution Contexts (ES6 8)","number":"1"},"ExecutableCodeAndContexts.ExecutionContexts":{"location":"","id":"ExecutableCodeAndContexts.ExecutionContexts","aoid":null,"title":"Execution contexts (ES6 8.3)","number":"1.1"},"ExecutableCodeAndContexts.JobsAndJobQueues":{"location":"","id":"ExecutableCodeAndContexts.JobsAndJobQueues","aoid":null,"title":"Jobs and Job Queues (ES6 8.4)","number":"1.2"},"ExecutableCodeAndContexts.JobsAndJobQueues.Progress":{"location":"","id":"ExecutableCodeAndContexts.JobsAndJobQueues.Progress","aoid":null,"title":"Forward Progress Guarantees","number":"1.2.1"},"ExecutableCodeAndContexts.Agent":{"location":"","id":"ExecutableCodeAndContexts.Agent","aoid":null,"title":"Agents (NEW)","number":"1.3"},"ExecutableCodeAndContexts.AgentCluster":{"location":"","id":"ExecutableCodeAndContexts.AgentCluster","aoid":null,"title":"Agent Clusters (NEW)","number":"1.4"},"ExecutableCodeAndContexts.AgentCommunication":{"location":"","id":"ExecutableCodeAndContexts.AgentCommunication","aoid":null,"title":"Inter-Agent Communication (NEW)","number":"1.5"},"ExecutableCodeAndContexts.ExternalSuspension":{"location":"","id":"ExecutableCodeAndContexts.ExternalSuspension","aoid":null,"title":"External suspension of agents (NEW)","number":"1.6"},"ExecutableCodeAndContexts.ExternalTermination":{"location":"","id":"ExecutableCodeAndContexts.ExternalTermination","aoid":null,"title":"External termination of agents (NEW)","number":"1.7"},"StructuredData":{"location":"","id":"StructuredData","aoid":null,"title":"Structured Data (ES6 24)","number":"2"},"StructuredData.ArrayBuffer":{"location":"","id":"StructuredData.ArrayBuffer","aoid":null,"title":"ArrayBuffer Objects (ES6 24.1)","number":"2.1"},"StructuredData.ArrayBuffer.abstract":{"location":"","id":"StructuredData.ArrayBuffer.abstract","aoid":null,"title":"Abstract Operations for ArrayBuffer (ES6 24.1.1)","number":"2.1.1"},"StructuredData.ArrayBuffer.abstract.GetValueFromBuffer":{"location":"","id":"StructuredData.ArrayBuffer.abstract.GetValueFromBuffer","aoid":"GetValueFromBuffer","title":"GetValueFromBuffer( arrayBuffer, byteIndex, type [, isLittleEndian] ) (ES6 24.1.1.5)","number":"2.1.1.1"},"StructuredData.ArrayBuffer.abstract.SetValueInBuffer":{"location":"","id":"StructuredData.ArrayBuffer.abstract.SetValueInBuffer","aoid":"SetValueInBuffer","title":"SetValueInBuffer( arrayBuffer, byteIndex, type, value [, isLittleEndian] ) (ES6 24.1.1.6)","number":"2.1.1.2"},"WebBrowserEmbedding":{"location":"","id":"WebBrowserEmbedding","aoid":null,"title":"Web browser embedding (for the HTML/DOM spec)","number":"3"},"WebBrowserEmbedding.Agents":{"location":"","id":"WebBrowserEmbedding.Agents","aoid":null,"title":"Agent mapping","number":"3.1"},"WebBrowserEmbedding.WorkerSemantics":{"location":"","id":"WebBrowserEmbedding.WorkerSemantics","aoid":null,"title":"Clarifications and changes to Web Worker semantics","number":"3.2"},"WebBrowserEmbedding.WorkerSemantics.Start":{"location":"","id":"WebBrowserEmbedding.WorkerSemantics.Start","aoid":null,"title":"Actions to start a worker","number":"3.2.1"},"WebBrowserEmbedding.WorkerSemantics.Jobs":{"location":"","id":"WebBrowserEmbedding.WorkerSemantics.Jobs","aoid":null,"title":"Workers are agents","number":"3.2.2"},"WebBrowserEmbedding.WorkerSemantics.LicenseToKill":{"location":"","id":"WebBrowserEmbedding.WorkerSemantics.LicenseToKill","aoid":null,"title":"Curtail the license to kill","number":"3.2.3"},"WebBrowserEmbedding.WorkerSemantics.Introspection":{"location":"","id":"WebBrowserEmbedding.WorkerSemantics.Introspection","aoid":null,"title":"Termination detection","number":"3.2.4"},"WebBrowserEmbedding.Termination":{"location":"","id":"WebBrowserEmbedding.Termination","aoid":null,"title":"Agent termination","number":"3.3"}},"ops":{"GetValueFromBuffer":{"aoid":"GetValueFromBuffer","id":"StructuredData.ArrayBuffer.abstract.GetValueFromBuffer","location":""},"SetValueInBuffer":{"aoid":"SetValueInBuffer","id":"StructuredData.ArrayBuffer.abstract.SetValueInBuffer","location":""}},"productions":{},"terms":{},"examples":{},"notes":{},"tables":{},"figures":{}}</script></head><body><div id="menu-toggle">☰</div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#intro" title="Introduction"><span class="secnum"></span> Introduction</a></li><li><span class="item-toggle">◢</span><a href="#ExecutableCodeAndContexts" title="Executable Code and Execution Contexts (ES6 8)"><span class="secnum">1</span> Executable Code and Execution Contexts (ES6 8)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.ExecutionContexts" title="Execution contexts (ES6 8.3)"><span class="secnum">1.1</span> Execution contexts (ES6 8.3)</a></li><li><span class="item-toggle">◢</span><a href="#ExecutableCodeAndContexts.JobsAndJobQueues" title="Jobs and Job Queues (ES6 8.4)"><span class="secnum">1.2</span> Jobs and Job Queues (ES6 8.4)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.JobsAndJobQueues.Progress" title="Forward Progress Guarantees"><span class="secnum">1.2.1</span> Forward Progress Guarantees</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.Agent" title="Agents (NEW)"><span class="secnum">1.3</span> Agents (NEW)</a></li><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.AgentCluster" title="Agent Clusters (NEW)"><span class="secnum">1.4</span> Agent Clusters (NEW)</a></li><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.AgentCommunication" title="Inter-Agent Communication (NEW)"><span class="secnum">1.5</span> Inter-Agent Communication (NEW)</a></li><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.ExternalSuspension" title="External suspension of agents (NEW)"><span class="secnum">1.6</span> External suspension of agents (NEW)</a></li><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.ExternalTermination" title="External termination of agents (NEW)"><span class="secnum">1.7</span> External termination of agents (NEW)</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData" title="Structured Data (ES6 24)"><span class="secnum">2</span> Structured Data (ES6 24)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.ArrayBuffer" title="ArrayBuffer Objects (ES6 24.1)"><span class="secnum">2.1</span> ArrayBuffer Objects (ES6 24.1)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.ArrayBuffer.abstract" title="Abstract Operations for ArrayBuffer (ES6 24.1.1)"><span class="secnum">2.1.1</span> Abstract Operations for ArrayBuffer (ES6 24.1.1)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" title="GetValueFromBuffer( arrayBuffer, byteIndex, type [, isLittleEndian] ) (ES6 24.1.1.5)"><span class="secnum">2.1.1.1</span> GetValueFromBuffer( arrayBuffer, byteIndex, type [, isLittleEndian] ) (ES6 24.1.1.5)</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer" title="SetValueInBuffer( arrayBuffer, byteIndex, type, value [, isLittleEndian] ) (ES6 24.1.1.6)"><span class="secnum">2.1.1.2</span> SetValueInBuffer( arrayBuffer, byteIndex, type, value [, isLittleEndian] ) (ES6 24.1.1.6)</a></li></ol></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#WebBrowserEmbedding" title="Web browser embedding (for the HTML/DOM spec)"><span class="secnum">3</span> Web browser embedding (for the HTML/DOM spec)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.Agents" title="Agent mapping"><span class="secnum">3.1</span> Agent mapping</a></li><li><span class="item-toggle">◢</span><a href="#WebBrowserEmbedding.WorkerSemantics" title="Clarifications and changes to Web Worker semantics"><span class="secnum">3.2</span> Clarifications and changes to Web Worker semantics</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.WorkerSemantics.Start" title="Actions to start a worker"><span class="secnum">3.2.1</span> Actions to start a worker</a></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.WorkerSemantics.Jobs" title="Workers are agents"><span class="secnum">3.2.2</span> Workers are agents</a></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.WorkerSemantics.LicenseToKill" title="Curtail the license to kill"><span class="secnum">3.2.3</span> Curtail the license to kill</a></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.WorkerSemantics.Introspection" title="Termination detection"><span class="secnum">3.2.4</span> Termination detection</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.Termination" title="Agent termination"><span class="secnum">3.3</span> Agent termination</a></li></ol></li></ol></div></div><h1>DOM/ECMAScript "Agents"</h1>

<p> Second draft.  Revised: 2016-03-04.  lhansen@mozilla.com </p>

<emu-intro id="intro">
<h1><span class="secnum"></span>Introduction<span class="utils"><span class="anchor"><a href="#intro">#</a></span></span></h1>

<p> This is a companion spec to the Shared memory and Atomics specification
  ("SAB spec", for short).  The purpose of the present specification is to
  formalize what the SAB spec means when it refers to "agent", to place the
  runtime semantic operations that the SAB spec depends on on solid ground, and
  to hook "agent" into the ES6 spec at appropriate points (not very many).  </p>

<p> This companion spec has two parts, one for the ECMAScript spec and one for
  the DOM/HTML spec.  The latter is a secondary concern to this spec's author.  </p>

<p> Terminology: I'm going to use "agent" for the time being since that is what
  the SAB spec uses; C++ uses it too, for its similar concept.  "Vat" and
  "continent" would be OK too, I suggest we bikeshed a name later.  </p>

<p> Obvious discussion items:  </p>
<ul>
  <li> Is it OK to expose the  <em>surrounding agent</em> in the way I've done
    here as an implicit container for the <emu-xref href="#sec-execution-contexts"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-execution-contexts">execution context</a></emu-xref> machinery of the
    existing spec?  I don't think there's much room for confusion. 

  </li><li> Do we need to expose semantic operations on agents, or is what we
    have good enough?  Operations could be: adding a job to an agent's
    queue; message send and receive (abstractly); introspection on the
    agent's state. 

  </li><li> SharedArrayBuffer leaks a little bit into this spec but I've tried to
    keep that spec separate from this.  I could separate them even more if
    desired. 

  </li><li> Also search for "TODO".

</li></ul>

<p> Relevant links:  </p>
<ul>
  <li> <a href="https://github.com/tc39/ecmascript_sharedmem/issues/27">SAB spec Issue #27, overall issue bringing up realms, job queues, the appropriateness of any name, and other things</a>
  </li><li> <a href="https://github.com/tc39/ecmascript_sharedmem/issues/28">SAB spec Issue #28, about forward progress</a>
  </li><li> <a href="https://github.com/tc39/ecmascript_sharedmem/issues/55">SAB spec Issue #55, about partial failure</a>
  </li><li> <a href="https://github.com/tc39/ecma262/pull/226">Ecma 262 Issue #226, Domenic's "continents" proposal and discussion around it</a>
  </li><li> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4439.pdf">C++ paper on forward progress, not sure yet if this is the latest</a>
  </li><li> <a href="https://mail.mozilla.org/pipermail/es-discuss/2014-October/039985.html">Allen's explanation of how things hang together, and useful followups</a>
  </li><li> <a href="https://esdiscuss.org/topic/holy-mixed-metaphors-batman-was-event-loops-in-navigated-away-from-windows#content-2">More discussion of the name, notably the origin of "continent"</a>
</li></ul>

<p>Changelog:</p>
<ul>
  <li> 2016-03-04 -- Changed the definition of agent clusters back to the old one where a cluster is monotonically growing.  Integrated several comments and cleaned up.  Removed the contents of the section on agent suspension (by moving it into other sections).
  
  </li><li> 2016-03-04 -- Removed the contents of the section on inter-agent communication because it was not relevant to this spec.
  
  </li><li> 2016-03-04 -- Removed wording about the kinds of objects that agents and agent clusters could be reified as.
  
  </li><li> 2016-03-03 -- Added reference to Issue 39

</li></ul>

</emu-intro>

<!--
<emu-clause id="Overview">
  <h1>Overview (ES6 4)</h1>
  <emu-clause id="Overview.Overview">
    <h1>ECMAScript Overview (ES6 4.2)</h1>
    <p>In the third paragraph, include <b>SharedArrayBuffer</b> after <b>ArrayBuffer</b>.</p>
  </emu-clause>
  <emu-clause id="Overview.Terms">
    <h1>Terms and Definitions (ES6 4.3)</h1>
    <emu-clause id="Overview.Terms.Agent">
      <h1>Agent</h1>
      <p> The combination of an instance of an ECMAScript execution environment and the ECMAScript programs running within that environment. </p>
      <emu-note>
        <p> (Issue 27) This should be worded in terms of running 'jobs', and it needs to be broken out of Terms and Definitions and given a proper section, probably within ES6 section 8. </p>
      </emu-note>
    </emu-clause>
    <emu-clause id="Overview.Terms.AgentComm">
      <h1>Agent communication</h1>
      <p> Two agents are said to be able to communicate through shared
      memory if there can exist a Shared Data Block that can come to
      be referenced from both agents, not necessarily at the same
      time.  (Note this does not require the agents to have
      overlapping lifetimes.) </p>
    </emu-clause>
    <emu-clause id="Overview.Terms.Cluster">
      <h1>Agent cluster</h1>
      <p> A maximal set of agents that are able to communicate through shared memory. </p>
    </emu-clause>
    <emu-clause id="Overview.Terms.AgentEvent">
      <h1>Agent event</h1>
      <p> (TBD, but we're looking for something that captures an agent's observation of an external effect, or the causing of such observation in another agent.  In the Sharedmem spec these events are things like sending and receiving messages.) </p>
    </emu-clause>
    <emu-clause id="Overview.Terms.ProgramOrder">
      <h1>Program order</h1>
      <p> The order of steps within a single agent as determined by the language semantics </p>
    </emu-clause>
  </emu-clause>
</emu-clause>
-->

<emu-clause id="ExecutableCodeAndContexts">
  <h1><span class="secnum">1</span>Executable Code and Execution Contexts (ES6 8)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts">#</a></span></span></h1>

  <emu-clause id="ExecutableCodeAndContexts.ExecutionContexts">
    <h1><span class="secnum">1.1</span>Execution contexts (ES6 8.3)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.ExecutionContexts">#</a></span></span></h1>
    <p> Paragraph one: Change the last two sentences to the following (changes bolded):  </p>
    <blockquote>
      At any point in time, there is at most one <emu-xref href="#sec-execution-contexts"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-execution-contexts">execution context</a></emu-xref>  <b>per
      agent</b> that is actually executing code. This is known as
      the  <b>agent's</b> <em>running <emu-xref href="#sec-execution-contexts"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-execution-contexts">execution context</a></emu-xref></em>.    <b>All references
      to the  <em>running <emu-xref href="#sec-execution-contexts"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-execution-contexts">execution context</a></emu-xref></em> in this specification 
      reference the running <emu-xref href="#sec-execution-contexts"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-execution-contexts">execution context</a></emu-xref> of the  <em>surrounding agent</em>.</b>
    </blockquote>
  </emu-clause> <!-- execution contexts -->

  <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues">
    <h1><span class="secnum">1.2</span>Jobs and Job Queues (ES6 8.4)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.JobsAndJobQueues">#</a></span></span></h1>

    <p> In the paragraph between tables 25 and table 26, append the following
      sentence:  </p>

    <blockquote>
      <b> Each agent has its own set of named job queues.  All references to a
	named job queue in this specification, such as within the <emu-xref aoid="EnqueueJob"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-enqueuejob">EnqueueJob</a></emu-xref> and <emu-xref aoid="NextJob"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-nextjob-result">NextJob</a></emu-xref> semantic
	functions, reference the named queue in the  <em>surrounding agent</em>.</b>
    </blockquote>

    <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues.Progress">
      <h1><span class="secnum">1.2.1</span>Forward Progress Guarantees<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.JobsAndJobQueues.Progress">#</a></span></span></h1>

      <p>Implementations must ensure that all unblocked jobs eventually make
	progress.  </p>

      <emu-note><span class="note">Note</span>
        <p>(Issue 28) This section may be formalized at least partly in the
          terms of the C++ working paper on forward progress, see the referenced
          issue, or it may be left as-is.  An ES6 execution thread is most plausibly a
          'Concurrent agent' in the terms of that paper.  </p>
      </emu-note>
    </emu-clause> <!-- progress -->
  </emu-clause> <!-- jobs and job queues -->

  <emu-clause id="ExecutableCodeAndContexts.Agent">
    <h1><span class="secnum">1.3</span>Agents (NEW)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.Agent">#</a></span></span></h1>

    <p> An  <em>agent</em> comprises a set of ECMAScript execution contexts, an
      <emu-xref href="#sec-execution-contexts"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-execution-contexts">execution context</a></emu-xref> stack, a running <emu-xref href="#sec-execution-contexts"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-execution-contexts">execution context</a></emu-xref>, a set of named job
      queues, a set of attributes, and an executing thread.  Except for the
      executing thread, the constituents of an agent belong exclusively to that
      agent.  </p>

    <p> An agent's executing thread executes the jobs in the agent's job queues
      on the agent's execution contexts independently of other agents.  An
      execution thread may be used as the execution thread by multiple agents
      only if none of the agents sharing the thread have a  <b>canBlock</b>
      attribute that is <emu-const>true</emu-const>.  </p>

    <emu-note><span class="note">Note 1</span>
      <p> This is a case of bowing to reality, since browsers do share the main
	thread across tabs in the same process and will prohibit main-thread
	code from blocking.  Forward progress is guaranteed by implementations
	that set a time limit on how long the main thread can execute in a tab
	without returning to its event loop.  </p>
    </emu-note>

    <p> While an agent's executing thread executes the jobs in the agent's job
      queues, the agent is the  <em>surrounding agent</em> for the code in those
      jobs.  The code uses the surrounding agent to access the specification
      level execution objects held within the agent: the  <em>running execution
      context</em>, the <emu-xref href="#sec-execution-contexts"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-execution-contexts">execution context</a></emu-xref> stack, the named job queues, and the
      agent attributes.  </p>

    <p> The set of per-agent attributes is at least this:</p>
    <ul>
      <li> <b> littleEndian  </b>: the default value computed for
	the  <em>isLittleEndian</em> parameter when it is needed by E262
	algorithms <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref> and <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>.  The choice is
	implementation dependent and should be the alternative that is most
	efficient for the implementation.  Set at agent creation time; constant.
      
      </li><li> <b> canBlock  </b>: determines whether the agent can block (to wait for an
	external unblock event) or not.  Set at agent creation time; constant.
      
      </li><li> <b> state  </b>: the state of the agent.  It can take on the following symbolic
	values:
	
	<ul>
	  <li> <b> Creating  </b>: agent is in the process of being created
	  
	  </li><li> <b> Waiting  </b>: agent is waiting for work to appear in a queue
	  
	  </li><li> <b> Running  </b>: agent is processing a job
	  
	  </li><li> <b> Blocked  </b>: agent has put itself to sleep
	  
	  </li><li> <b> Destroying  </b>: agent is in the process of being destroyed
	  
	  </li><li> <b> Destroyed  </b>: agent has been destroyed
	
	</li></ul>
      </li><li> <b>signifier</b>: an identifier for the agent.
      
      </li><li> <b>lockFree1</b> determines whether atomic operations on shared memory with one-byte granularity are lock-free.
      
      </li><li> <b>lockFree2</b> determines whether atomic operations on shared memory with two-byte granularity are lock-free.
      
      </li><li> <b>lockFree4</b> determines whether atomic operations on shared memory with four-byte granularity are lock-free.
    
    </li></ul>

    <emu-note><span class="note">Note 2</span>
      <p> (Spec draft note) The  <b>state</b> values are not yet being used, but will
	be used by to-be-drafted semantic functions in the SAB spec, and may be used
	here to discuss agent termination.  </p>
    </emu-note>

    <p> An agent is a specification mechanism and need not correspond to any
      particular artefact of an ECMAScript implementation.  </p>

    <emu-note><span class="note">Note 3</span>
      <p> There are several ways in which agents could be meaningful
        without having a direct representation.  </p>

      <p> The standalone shell for Firefox's JS engine allows workers
	to be created but has no JS representation for those workers.
	SharedArrayBuffers are shared not through messages but through
	a global mailbox mechanism.  </p>

      <p> The MessagePort mechanism in HTML5 allows workers to be
	passed around implicitly; it is possible to communicate with a
	worker without having a direct representation for the worker,
	only for a channel that the worker listens on.  </p>
    </emu-note>

  </emu-clause> <!-- agent -->

  <emu-clause id="ExecutableCodeAndContexts.AgentCluster">
    <h1><span class="secnum">1.4</span>Agent Clusters (NEW)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.AgentCluster">#</a></span></span></h1>

    <p> An  <em>agent cluster</em> is a maximal set of agents that can
      communicate by operating on shared memory.  </p>

    <emu-note><span class="note">Note 1</span>
      <p> Programs within different agents may share memory by
        unspecified means.  At a minimum, the backing memory for
        <emu-const>SharedArrayBuffer</emu-const> objects can be shared among the agents in
        the cluster.  </p>

      <p> There may be agents that can communicate by message passing
	that cannot share memory; they are never in the same
	cluster.  </p>
    </emu-note>

    <p> Every agent belongs to exactly one agent cluster.  </p>

    <emu-note><span class="note">Note 2</span>
      <p> The agents in a cluster need not all be alive at some
	particular point in time.  If agent  <b>A</b> creates another
	agent  <b>B</b>, after which  <b>A</b> terminates and  <b>B</b>
	creates agent  <b>C</b>, the three agents are in the same
	cluster if  <b>A</b> could share some memory with  <b>B</b>
	and  <b>B</b> could share some memory with  <b>C</b>.  </p>
    </emu-note>

    <p> All agents within a cluster must have the same value for
      their  <b>littleEndian</b> attributes.  </p>

    <emu-note><span class="note">Note 3</span>
      <p> (Spec draft note) Is the restriction on  <b>littleEndian</b> overreach?
	It seemed reasonable at the time, but on some architectures it's
	possible for different processes to have different endianness.  The rule
	precludes sharing memory among such processes, in any ECMAScript
	implementation.  </p>
    </emu-note>

    <p> All agents within a cluster must have the same values for
      their  <b>lockFree1</b> attributes; the same values for
      their  <b>lockFree2</b> attributes; and the same values for
      their  <b>lockFree4</b> attributes.  </p>

    <p> All agents within a cluster must have different values for
      their  <b>signifier</b> attributes.  </p>

    <p> An agent cluster is a specification mechanism and need not correspond to
      any particular artefact of an ECMAScript implementation.  </p>

    <p> An embedding may suspend and wake an agent without the agent's
      knowledge or cooperation.  If the embedding does so, it must
      suspend and wake all agents in an agent cluster together.  </p>

    <emu-note><span class="note">Note 4</span>
      <p> The purpose of that restriction is to avoid a situation
        where a worker deadlocks or starves because another agent has
        been suspended.  For example, if a DOM SharedWorker shares
        memory with a regular worker, and the regular worker is
        suspended while it holds a lock (because the web page the
        regular worker is in is pushed into the window history), and
        the SharedWorker tries to acquire the lock, then the
        SharedWorker will be blocked until the regular worker wakes up
        again, if ever.  Meanwhile other workers trying to access the
        SharedWorker from other web pages will starve.  </p>

      <p> The implication of the restriction is that it will not be
        possible to share memory between agents that don't belong to
        the same suspend/wake collective within the embedding.  </p>

      <p> (<a href="https://github.com/tc39/ecmascript_sharedmem/issues/39">Issue 39</a>) That, in
        turn, places interesting demands on the structured clone algorithm in web browsers.  </p>
    </emu-note>
        
  </emu-clause> <!-- agent cluster -->

  <emu-clause id="ExecutableCodeAndContexts.AgentCommunication">
    <h1><span class="secnum">1.5</span>Inter-Agent Communication (NEW)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.AgentCommunication">#</a></span></span></h1>

    <p> (Removed; section kept to avoid changing the numbering)  </p>

  </emu-clause> <!-- inter-agent communication -->

  <emu-clause id="ExecutableCodeAndContexts.ExternalSuspension">
    <h1><span class="secnum">1.6</span>External suspension of agents (NEW)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.ExternalSuspension">#</a></span></span></h1>

    <p> (Integrated into the Agent Clusters section; section kept to avoid changing the numbering)  </p>

  </emu-clause> <!-- external suspension -->

  <emu-clause id="ExecutableCodeAndContexts.ExternalTermination">
    <h1><span class="secnum">1.7</span>External termination of agents (NEW)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.ExternalTermination">#</a></span></span></h1>

    <p> An embedding may terminate agents without the agents' knowledge.  If it does that, then:  </p>

    <p> <b>TODO</b> </p>

    <emu-note><span class="note">Note</span>
      <p> The reasons for termination include resource exhaustion and embedding-specific agent management.  </p>
    </emu-note>
    
  </emu-clause> <!-- external termination -->

</emu-clause> <!-- executable code and contexts -->

<emu-clause id="StructuredData">
  <h1><span class="secnum">2</span>Structured Data (ES6 24)<span class="utils"><span class="anchor"><a href="#StructuredData">#</a></span></span></h1>

  <emu-clause id="StructuredData.ArrayBuffer">
    <h1><span class="secnum">2.1</span>ArrayBuffer Objects (ES6 24.1)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer">#</a></span></span></h1>

    <emu-clause id="StructuredData.ArrayBuffer.abstract">
      <h1><span class="secnum">2.1.1</span>Abstract Operations for ArrayBuffer (ES6 24.1.1)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract">#</a></span></span></h1>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" aoid="GetValueFromBuffer">
        <h1><span class="secnum">2.1.1.1</span>GetValueFromBuffer( arrayBuffer, byteIndex, type [, isLittleEndian] ) (ES6 24.1.1.5)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">#</a></span></span></h1>
        <p> Replace step 7 of this algorithm with the following:</p>
        <ul>
	  <li>  if <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to the value of the  <b>isLittleEndian</b> attribute of
	    the  <em>surrounding agent</em>.
        
        </li></ul>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.SetValueInBuffer" aoid="SetValueInBuffer">
        <h1><span class="secnum">2.1.1.2</span>SetValueInBuffer( arrayBuffer, byteIndex, type, value [, isLittleEndian] ) (ES6 24.1.1.6)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">#</a></span></span></h1>
        <p> Replace step 8 of this algorithm with the following:</p>
        <ul>
	  <li>  if <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to the value of the  <b>isLittleEndian</b> attribute of
	    the  <em>surrounding agent</em>.
        
        </li></ul>
      </emu-clause>
      
    </emu-clause> <!-- abstract ops -->
  </emu-clause> <!-- ArrayBuffer -->
</emu-clause> <!-- structured data -->

<emu-clause id="WebBrowserEmbedding">
  <h1><span class="secnum">3</span>Web browser embedding (for the HTML/DOM spec)<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding">#</a></span></span></h1>

  <emu-clause id="WebBrowserEmbedding.Agents">
    <h1><span class="secnum">3.1</span>Agent mapping<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.Agents">#</a></span></span></h1>
    <p> In a web browser setting, the  <em>agents</em> comprise a document's main
      thread environment and worker thread environments.  </p>

    <p> Browsers will typically let main-thread agents
      have  <b>canBlock</b>=false.  Browsers that support several tabs within the
      same content process may share a single agent execution thread across all
      the tabs in that case (Firefox does).  </p>

    <p> Agents are represented to ES programs as Worker objects.  There is no
      representation of agent clusters.  Agents communicate (in the sense of the
      Inter-Agent Communication section) by messages on message channels,
      including on the implicit channel created between a parent and its
      child.    </p>

  </emu-clause> <!-- agents -->
  
  <emu-clause id="WebBrowserEmbedding.WorkerSemantics">
    <h1><span class="secnum">3.2</span>Clarifications and changes to Web Worker semantics<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.WorkerSemantics">#</a></span></span></h1>

    <emu-note><span class="note">Note</span>
      <p> Several of these issues have been reported as bugs against the WHATWG
      spec,  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29039">see
      this bug report</a>.  </p>
    </emu-note>

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Start">
      <h1><span class="secnum">3.2.1</span>Actions to start a worker<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.WorkerSemantics.Start">#</a></span></span></h1>
      <p> (Clarification) The only action required to start a worker is to call
	"new Worker()".  </p>

      <emu-note><span class="note">Note 1</span>
	<p> (Spec draft note) Firefox requires a trip through the event loop
	  to start the worker.  I'm told this won't be fixed, spec or no spec.  </p>

	<p> The current state is a deadlock hazard.  If one worker creates
	  another and then blocks on a futex waiting for the new worker to
	  unblock it, the workers may deadlock since the new one may not have
	  been created.  The hazard is reduced by (a) prohibiting blocking on
	  the main thread and (b) either disallowing nested workers or not
	  requiring workers to return to their event loops to get a nested
	  worker started.  </p>
      </emu-note>

      <p> (Compatible change) If a worker cannot be started for reasons of
	resource exhaustion (notably, no threads available, including arbitrary
	implementation limits on the number of threads) then an error must be
	reported in some manner TBD (TODO).  </p>

      <emu-note><span class="note">Note 2</span>
        <p> (Spec draft note) In current Firefox, there is a per-domain limit on
          the number of workers.  An attempt to create a worker will silently
          not start the worker if the limit has been reached; the worker will be
          queued and started when another worker has terminated.  Again, this
          creates deadlock hazards.  </p>

        <p> There are other error situations during worker startup that can't
          necessarily be signaled synchronously, notably, a load error on the
          URL.  Those have to be signaled via an event callback, or the creating
          agent must poll the state of the worker to see if it enters an error
          state (see more below on the state).  A callback is probably cleanest,
          but we'll want the state variable anyway, so maybe both.  </p>
      </emu-note>
    </emu-clause> <!-- start -->

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Jobs">
      <h1><span class="secnum">3.2.2</span>Workers are agents<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.WorkerSemantics.Jobs">#</a></span></span></h1>
      <p> (Clarification) Every worker implements an independent agent as defined above.  </p>
      <emu-note><span class="note">Note</span>
        <p> Thus the forward-progress guarantee of jobs also applies to workers.  </p>
      </emu-note>
    </emu-clause> <!-- jobs -->

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.LicenseToKill">
      <h1><span class="secnum">3.2.3</span>Curtail the license to kill<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.WorkerSemantics.LicenseToKill">#</a></span></span></h1>

      <p> (Compatible change) Workers may be killed by the browser only for
	specific reasons.  These reasons are TBD (TODO) but include evicting the owning
	page from the history and closing the owning page.  These reasons do not
	include workers that 'run too long'.  </p>

      <emu-note><span class="note">Note</span>
        <p> Currently the WHATWG spec allows the browser to kill any worker at
          any time.  The purpose of the rule is probably a combination of the
          need to stop runaway scripts (without the normal slow-script dialog)
          and the need to remove workers once a page is evicted from the browser
          cache or a tab is closed.  However, the wording is overly broad.
          Also, common uses of workers for computation conflict with the ability
          to detect "runaway" agents:</p>

        <ul>
          <li> The worker may perform a genuinely long-running computation
          
          </li><li> The worker will have its own user-implemented "event" loop,
            communicating synchronously through shared memory; it will not use the
            browser's event loop
        
        </li></ul>
      </emu-note>

      <p> FIXME: Here and/or in termination detection below we want to
      reference the discussion on partial failure in Issue#55  </p>

    </emu-clause> <!-- license to kill -->

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Introspection">
      <h1><span class="secnum">3.2.4</span>Termination detection<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.WorkerSemantics.Introspection">#</a></span></span></h1>
      <p> (Compatible(?) change) The worker object should have a read-only
	property called "state" whose value represents the state of the worker (eg
	a string naming the state).  One state might be "terminated", indicating
	the worker is dead.  </p>

      <emu-note><span class="note">Note 1</span>
        <p> There appears to be no way at present to directly determine whether
        a Worker has terminated.  </p>
      </emu-note>

      <emu-note><span class="note">Note 2</span>
        <p> Possible complementary mechanisms include throwing an exception when
          a message is sent to a terminated worker, and to send an error event to
          the creating agent when a worker is killed.  </p>
      </emu-note>

      <emu-note><span class="note">Note 3</span>
	<p> The spec here can be related back to the agent attributes, specified
	  earlier.  </p>
      </emu-note>
    </emu-clause> <!-- introspection -->
  </emu-clause> <!-- worker semantics -->
  
  <emu-clause id="WebBrowserEmbedding.Termination">
    <h1><span class="secnum">3.3</span>Agent termination<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.Termination">#</a></span></span></h1>

    <p>If a worker is terminated by a call to its terminate method while it is
      blocked in then the worker is first woken and then immediately terminated
      (the wakeup is not observable to code running in the worker).  </p>

    <emu-note><span class="note">Note 1</span>
      <p> (Spec draft note) Firefox supports close handlers that could in
	principle be used to clean up inconsistent state, but I think that's not in
	the HTML5 spec.  </p>
    </emu-note>

    <p>If a worker is terminated for any other reason, such as the user agent
      reloading or closing the window or frame, and the worker is blocked in a
      call to futexWait when it is terminated, then the worker is first woken
      and then immediately terminated (the wakeup is not observable to code
      running in the worker).</p>

    <emu-note><span class="note">Note 2</span>
      <p> (Spec draft note) After the running script has been terminated the
	worker's close handler(s) will be run as if the wait had not been
	aborted.</p>
    </emu-note>
  </emu-clause> <!-- termination -->

</emu-clause> <!-- browser embedding -->

</body>
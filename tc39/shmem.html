<!doctype html>
<head><meta charset="utf8">
<title>Shared memory and atomics specification</title>
<link rel="stylesheet" href="https://bterlson.github.com/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">

</head><body><h1>Shared memory and atomics specification</h1>

<div><h2>Table of Contents</h2><ol class="toc"><li><a href="#intro"><span class="secnum"></span> Introduction</a></li><li><a href="#Overview"><span class="secnum">1</span> Overview (ES6 4)</a><ol class="toc"><li><a href="#Overview.Terms"><span class="secnum">1.1</span> Terms and Definitions (ES6 4.3)</a><ol class="toc"><li><a href="#Overview.Terms.Agent"><span class="secnum">1.1.1</span> Agent</a></li></ol></li></ol></li><li><a href="#DataTypesValues"><span class="secnum">2</span> ECMAScript Data Types and Values (ES6 6)</a><ol class="toc"><li><a href="#DataTypesValues.SpecTypes"><span class="secnum">2.1</span> ECMAScript Specification Types (ES6 6.2)</a><ol class="toc"><li><a href="#DataTypesValues.SpecTypes.DataBlocks"><span class="secnum">2.1.1</span> Data blocks (ES6 6.2.6)</a><ol class="toc"><li><a href="#DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes"><span class="secnum">2.1.1.1</span> CopyDataBlockBytes(toBlock, toIndex, fromBlock, fromIndex, count) (ES6 6.2.6.2)</a></li><li><a href="#DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock"><span class="secnum">2.1.1.2</span> CreateSharedByteDataBlock( size )</a></li><li><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID"><span class="secnum">2.1.1.3</span> SharedDataBlockID( block )</a></li></ol></li></ol></li></ol></li><li><a href="#IndexedCollections"><span class="secnum">3</span> Indexed Collections (ES6 22)</a><ol class="toc"><li><a href="#TypedArray"><span class="secnum">3.1</span> TypedArray Objects (ES6 22.2)</a></li></ol></li><li><a href="#StructuredData"><span class="secnum">4</span> Structured Data (ES6 24)</a><ol class="toc"><li><a href="#StructuredData.SharedArrayBuffer"><span class="secnum">4.1</span> SharedArrayBuffer Objects</a><ol class="toc"><li><a href="#StructuredData.SharedArrayBuffer.abstract"><span class="secnum">4.1.1</span> Abstract Operations for SharedArrayBuffer</a><ol class="toc"><li><a href="#StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer"><span class="secnum">4.1.1.1</span> AllocateSharedArrayBuffer ( constructor, byteLength )</a></li><li><a href="#StructuredData.SharedArrayBuffer.abstract.GetValueFromSharedBuffer"><span class="secnum">4.1.1.2</span> GetValueFromSharedBuffer ( arrayBuffer, byteIndex, type )</a></li><li><a href="#StructuredData.SharedArrayBuffer.abstract.SetValueInSharedBuffer"><span class="secnum">4.1.1.3</span> SetValueInSharedBuffer ( arrayBuffer, byteIndex, type, value )</a></li></ol></li><li><a href="#StructuredData.SharedArrayBuffer.constructor"><span class="secnum">4.1.2</span> The SharedArrayBuffer Constructor</a><ol class="toc"><li><a href="#StructuredData.SharedArrayBuffer.constructor.withLength"><span class="secnum">4.1.2.1</span> SharedArrayBuffer ( length )</a></li></ol></li><li><a href="#StructuredData.SharedArrayBuffer.constructor.properties"><span class="secnum">4.1.3</span> Properties of the SharedArrayBuffer constructor</a><ol class="toc"><li><a href="#StructuredData.SharedArrayBuffer.constructor.properties.isView"><span class="secnum">4.1.3.1</span> SharedArrayBuffer.isView ( arg )</a></li><li><a href="#StructuredData.SharedArrayBuffer.constructor.properties.prototype"><span class="secnum">4.1.3.2</span> SharedArrayBuffer.prototype</a></li><li><a href="#StructuredData.SharedArrayBuffer.constructor.properties.get_species"><span class="secnum">4.1.3.3</span> get SharedArrayBuffer [ @@species ]</a></li></ol></li><li><a href="#StructuredData.SharedArrayBuffer.prototype"><span class="secnum">4.1.4</span> Properties of the SharedArrayBuffer prototype object</a><ol class="toc"><li><a href="#StructuredData.SharedArrayBuffer.prototype.get_byteLength"><span class="secnum">4.1.4.1</span> get SharedArrayBuffer.prototype.byteLength</a></li><li><a href="#SharedArrayBuffer_prototype_constructor"><span class="secnum">4.1.4.2</span> SharedArrayBuffer.prototype.constructor</a></li><li><a href="#SharedArrayBuffer_prototype_slice"><span class="secnum">4.1.4.3</span> SharedArrayBuffer.prototype.slice ( start, end )</a></li><li><a href="#SharedArrayBuffer_prototype_toString"><span class="secnum">4.1.4.4</span> SharedArrayBuffer.prototype[ @@toStringTag ]</a></li></ol></li><li><a href="#SharedArrayBuffer_instances"><span class="secnum">4.1.5</span> Properties of the SharedArrayBuffer instances</a></li></ol></li></ol></li><li><a href="#AtomicsObject"><span class="secnum">5</span> The Atomics Object</a><ol class="toc"><li><a href="#AtomicsObjectValueProps"><span class="secnum">5.1</span> Value Properties of the Atomics Object</a><ol class="toc"><li><a href="#Atomics.OK"><span class="secnum">5.1.1</span> Atomics.OK</a></li><li><a href="#Atomics.NOTEQUAL"><span class="secnum">5.1.2</span> Atomics.NOTEQUAL</a></li><li><a href="#Atomics.TIMEDOUT"><span class="secnum">5.1.3</span> Atomics.TIMEDOUT</a></li></ol></li><li><a href="#"><span class="secnum">5.2</span> Runtime semantics</a><ol class="toc"><li><a href="#Atomics.ValidateSharedIntegerTypedArray"><span class="secnum">5.2.1</span> Runtime semantics: ValidateSharedIntegerTypedArray(<var>ta</var>, [onlyInt32])</a></li><li><a href="#Atomics.ValidateAtomicAccess"><span class="secnum">5.2.2</span> Runtime semantics: ValidateAtomicAccess(<var>ta</var>, <var>index</var>)</a></li><li><a href="#Atomics.AddWaiter"><span class="secnum">5.2.3</span> Runtime semantics: AddWaiter(<var>W</var>, <var>G</var>, <var>i</var>)</a></li><li><a href="#Atomics.RemoveWaiter"><span class="secnum">5.2.4</span> Runtime semantics: RemoveWaiter(<var>W</var>, <var>G</var>, <var>i</var>)</a></li><li><a href="#Atomics.RemoveWaiters"><span class="secnum">5.2.5</span> Runtime semantics: RemoveWaiters(<var>G</var>, <var>i</var>)</a></li><li><a href="#Atomics.SuspendWaiter"><span class="secnum">5.2.6</span> Runtime semantics: Suspend(<var>timeout</var>)</a></li><li><a href="#Atomics.WakeWaiter"><span class="secnum">5.2.7</span> Runtime semantics: WakeWaiter(<var>W</var>)</a></li></ol></li><li><a href="#AtomicsObjectFunctionProps"><span class="secnum">5.3</span> Function Properties of the Atomics Object</a><ol class="toc"><li><a href="#Atomics.add"><span class="secnum">5.3.1</span> Atomics.add ( ta, index, value )</a></li><li><a href="#Atomics.and"><span class="secnum">5.3.2</span> Atomics.and ( ta, index, value )</a></li><li><a href="#Atomics.compareExchange"><span class="secnum">5.3.3</span> Atomics.compareExchange ( ta, index, expectedValue, replacementValue )</a></li><li><a href="#Atomics.exchange"><span class="secnum">5.3.4</span> Atomics.exchange ( ta, index, value )</a></li><li><a href="#Atomics.futexWait"><span class="secnum">5.3.5</span> Atomics.futexWait ( ta, index, value, timeout )</a></li><li><a href="#Atomics.futexWake"><span class="secnum">5.3.6</span> Atomics.futexWake ( ta, index, count )</a></li><li><a href="#Atomics.futexWakeOrRequeue"><span class="secnum">5.3.7</span> Atomics.futexWakeOrRequeue ( ta, index1, count, index2, value )</a></li><li><a href="#Atomics.isLockFree"><span class="secnum">5.3.8</span> Atomics.isLockFree ( size )</a></li><li><a href="#Atomics.load"><span class="secnum">5.3.9</span> Atomics.load ( ta, index )</a></li><li><a href="#Atomics.or"><span class="secnum">5.3.10</span> Atomics.or ( ta, index, value )</a></li><li><a href="#Atomics.store"><span class="secnum">5.3.11</span> Atomics.store ( ta, index, value )</a></li><li><a href="#Atomics.sub"><span class="secnum">5.3.12</span> Atomics.sub ( ta, index, value )</a></li><li><a href="#Atomics.xor"><span class="secnum">5.3.13</span> Atomics.xor ( ta, index, value )</a></li></ol></li></ol></li></ol></div><emu-intro id="intro">
<h1><span class="secnum"></span>Introduction</h1>
<p>
This proposal adds shared memory types and atomic operations to ECMAScript.
</p>
<p>
This document is organized in terms of where changes would be made to the ES6 spec. Although ecmarkup generates numbering at the beginning of headers, these won't correspond to the numbering within the existing ECMA spec, so I've included a matching numbering in parentheses afterwards, referring to the ES6 spec.
</p>
<p>Missing from this document (also search for FIXME):</p>
<ul>
  <li> How things hook into TypedArray (significant work)
  </li><li> Memory model discussion
</li></ul>
<p>This document is in spec order, not written for direct readability.</p>
<p>Changelog:</p>
<ul>
</ul>
</emu-intro>

<emu-clause id="Overview">
  <h1><span class="secnum">1</span>Overview (ES6 4)</h1>
  <emu-clause id="Overview.Terms">
    <h1><span class="secnum">1.1</span>Terms and Definitions (ES6 4.3)</h1>
    <emu-clause id="Overview.Terms.Agent">
      <h1><span class="secnum">1.1.1</span>Agent</h1>
      <p> The combination of an instance of an ECMAScript execution environment and the ECMAScript programs running within that environment. </p>
      <emu-note><span class="note">Note</span>
        <p>Agents whose lifetimes overlap and who are able to share a Shared Data Block can communicate by means of certain operations on that Shared Data Block.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="DataTypesValues">
  <h1><span class="secnum">2</span>ECMAScript Data Types and Values (ES6 6)</h1>
  <emu-clause id="DataTypesValues.SpecTypes">
    <h1><span class="secnum">2.1</span>ECMAScript Specification Types (ES6 6.2)</h1>
    <emu-clause id="DataTypesValues.SpecTypes.DataBlocks">
      <h1><span class="secnum">2.1.1</span>Data blocks (ES6 6.2.6)</h1>
      <p> AMEND: Insert the following paragraph after the third: </p>
      <p> A data block that resides in memory that is shareable between concurrent agents is designated a Shared Data Block. </p>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes">
        <h1><span class="secnum">2.1.1.1</span>CopyDataBlockBytes(toBlock, toIndex, fromBlock, fromIndex, count) (ES6 6.2.6.2)</h1>
        <p> AMEND: In step 1, allow also a Shared Data Block. </p>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock">
        <h1><span class="secnum">2.1.1.2</span>CreateSharedByteDataBlock( size )</h1>
        <p>When the abstract operation CreateSharedByteDataBlock is called with integer argument size, the following steps are taken:</p>
        <emu-alg><ol>
  <li>Assert: <var>size</var> &gt;= 0.</li>
  <li>Let <var>db</var> be a new Shared Data Block value consisting of size bytes. If it is impossible to create such a Shared Data Block, throw a <emu-const>RangeError</emu-const> exception.</li>
  <li>Set all of the bytes of <var>db</var> to 0.</li>
  <li>Return <var>db</var>.</li>
</ol></emu-alg>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID" aoid="SharedDataBlockID">
        <h1><span class="secnum">2.1.1.3</span>SharedDataBlockID( block )</h1>
        <p>When the abstract operation SharedDataBlockID is called with shared data block argument <var>block</var>, the following steps are taken:</p>
        <emu-alg><ol>
  <li>Let <var>G</var> be an address-free identifier for <var>block</var>. <var>G</var> has the same value in every agent.</li>
  <li>Return <var>G</var>.</li>
</ol></emu-alg>
        <emu-note><span class="note">Note</span>
          <p>The Shared Data Block ID is used by the futex mechanism and names <var>block</var> independently of any virtual addresses it may be mapped to in any particular agent.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="IndexedCollections">
  <h1><span class="secnum">3</span>Indexed Collections (ES6 22)</h1>
  <emu-clause id="TypedArray">
    <h1><span class="secnum">3.1</span>TypedArray Objects (ES6 22.2)</h1>
    <p>FIXME: Modifications to TypedArray to allow the use of SharedArrayBuffer. These may be extensive. SharedArrayBuffer stores its internal data in slots that ave other names than ArrayBuffer, this will cause some churn. </p>
  </emu-clause>
</emu-clause>

<emu-clause id="StructuredData">
  <h1><span class="secnum">4</span>Structured Data (ES6 24)</h1>
  <emu-clause id="StructuredData.SharedArrayBuffer">
    <h1><span class="secnum">4.1</span>SharedArrayBuffer Objects</h1>

    <emu-clause id="StructuredData.SharedArrayBuffer.abstract">
      <h1><span class="secnum">4.1.1</span>Abstract Operations for SharedArrayBuffer</h1>
      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer">
        <h1><span class="secnum">4.1.1.1</span>AllocateSharedArrayBuffer ( constructor, byteLength )</h1>
        <p> The abstract operation AllocateSharedArrayBuffer with arguments constructor and byteLength is used to create a SharedArrayBuffer object. It performs the following steps:</p>

        <emu-alg><ol>
  <li>Let obj be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ordinarycreatefromconstructor">OrdinaryCreateFromConstructor</a>(constructor, <code>"%SharedArrayBufferPrototype%"</code>, «‍[[SharedArrayBufferData]], [[SharedArrayBufferByteLength]]» ).</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(obj).</li>
  <li>Assert: byteLength is a positive integer.</li>
  <li>Let block be CreateSharedByteDataBlock(byteLength).</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(block).</li>
  <li>Set obj’s [[SharedArrayBufferData]] internal slot to block.</li>
  <li>Set obj’s [[SharedArrayBufferByteLength]] internal slot to byteLength.</li>
  <li>Return obj.</li>
</ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.GetValueFromSharedBuffer" aoid="GetValueFromSharedBuffer">
        <h1><span class="secnum">4.1.1.2</span>GetValueFromSharedBuffer ( arrayBuffer, byteIndex, type )</h1>
        <p> This is the same as ArrayBuffer's GetValueFromBuffer (ES6 24.1.1.5) except that: </p>
        <ul>
          <li> The <var>arrayBuffer</var> parameter is a SharedArrayBuffer
          </li><li> There is no <var>isLittleEndian</var> parameter, it is "not present". The implementation must determine the same value for <var>isLittleEndian</var> in all agents that can communicate through shared memory (see Atomics.isLockFree for more precise wording, for now)
          </li><li> There is no detachment check (step 1)
          </li><li> Use the [[SharedArrayBufferData]] internal slot (step 4)
        </li></ul>
      </emu-clause>
      
      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.SetValueInSharedBuffer" aoid="SetValueInSharedBuffer">
        <h1><span class="secnum">4.1.1.3</span>SetValueInSharedBuffer ( arrayBuffer, byteIndex, type, value )</h1>
        <p> This is the same as ArrayBuffer's SetValueInBuffer (ES6 24.1.1.6) except that: </p>
        <ul>
          <li> The <var>arrayBuffer</var> parameter is a SharedArrayBuffer
          </li><li> There is no <var>isLittleEndian</var> parameter, it is "not present".
          </li><li> There is no detachment check (step 1)
          </li><li> Use the [[SharedArrayBufferData]] internal slot (step 5)
        </li></ul>
      </emu-clause>
      
    </emu-clause>

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor">
      <h1><span class="secnum">4.1.2</span>The SharedArrayBuffer Constructor</h1>
      <p> The SharedArrayBuffer constructor is the %SharedArrayBuffer% intrinsic object and the initial value of the SharedArrayBuffer property of the global object. When called as a constructor it creates and initializes a new SharedArrayBuffer object. SharedArrayBuffer is not intended to be called as a function and will throw an exception when called in that manner. </p>

      <p> The SharedArrayBuffer constructor is designed to be subclassable. It may be used as the value of an extends clause of a class definition. Subclass constructors that intend to inherit the specified SharedArrayBuffer behaviour must include a super call to the SharedArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support the SharedArrayBuffer.prototype built-in methods. </p>
      
      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.withLength">
        <h1><span class="secnum">4.1.2.1</span>SharedArrayBuffer ( length )</h1>
        <p> SharedArrayBuffer called with argument length performs the following steps: </p>
        <emu-alg><ol>
  <li>If NewTarget is undefined, throw a <emu-const>TypeError</emu-const> exception.</li>
  <li>Let <var>numberLength</var> be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tonumber">ToNumber</a>(<var>length</var>).</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>numberLength</var>).</li>
  <li>Let <var>byteLength</var> be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength">ToLength</a>(<var>numberLength</var>).</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>byteLength</var>).</li>
  <li>If <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero">SameValueZero</a>(<var>numberLength</var>, <var>byteLength</var>) is false, throw a <emu-const>RangeError</emu-const> exception.</li>
  <li>Return AllocateSharedArrayBuffer(NewTarget, <var>byteLength</var>).</li>
</ol></emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties">
      <h1><span class="secnum">4.1.3</span>Properties of the SharedArrayBuffer constructor</h1>
      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.isView">
        <h1><span class="secnum">4.1.3.1</span>SharedArrayBuffer.isView ( arg )</h1>
        <p>The isView function takes one argument arg, and performs the following steps are taken:</p>
        <emu-alg><ol>
  <li>If <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-data-types-and-values">Type</a>(<var>arg</var>) is not <emu-const>Object</emu-const>, return <emu-const>false</emu-const>.</li>
  <li>If <var>arg</var> has a [[ViewedArrayBuffer]] internal slot, return <emu-const>true</emu-const>.</li>
  <li>Return <emu-const>false</emu-const>.</li>
</ol></emu-alg>
        <emu-note><span class="note">Note</span>
          <p> This function is identical to ArrayBuffer.isView, since TypedArrays use the [[ViewedArrayBuffer]] internal slot to hold both unshared and shared views. </p>
        </emu-note>
      </emu-clause>
      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.prototype">
        <h1><span class="secnum">4.1.3.2</span>SharedArrayBuffer.prototype</h1>
        <p> The initial value of SharedArrayBuffer.prototype is the intrinsic object %SharedArrayBufferPrototype% (q.v.).</p>
        <p> This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</p>
      </emu-clause>
      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.get_species">
        <h1><span class="secnum">4.1.3.3</span>get SharedArrayBuffer [ @@species ]</h1>
        <p><code>SharedArrayBuffer[@@species]</code> is an accessor property whose set accessor function is <emu-const>undefined</emu-const>. Its get accessor function performs the following steps:</p>
        <emu-alg><ol>
  <li>Return the this value.</li>
</ol></emu-alg>
        <p> The value of the name property of this function is "<code>get [Symbol.species]</code>".</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="StructuredData.SharedArrayBuffer.prototype">
      <h1><span class="secnum">4.1.4</span>Properties of the SharedArrayBuffer prototype object</h1>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.get_byteLength">
        <h1><span class="secnum">4.1.4.1</span>get SharedArrayBuffer.prototype.byteLength</h1>

        <p> SharedArrayBuffer.prototype.byteLength is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: </p>

        <emu-alg><ol>
  <li>Let <var>O</var> be the <emu-const>this</emu-const> value.</li>
  <li>If <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-data-types-and-values">Type</a>(<var>O</var>) is not <emu-const>Object</emu-const>, throw a <emu-const>TypeError</emu-const> exception.</li>
  <li>If <var>O</var> does not have a [[SharedArrayBufferData]] internal slot, throw a <emu-const>TypeError</emu-const> exception.</li>
  <li>Let length be the value of <var>O</var>’s [[SharedArrayBufferByteLength]] internal slot.</li>
  <li>Return length.</li>
</ol></emu-alg>
      </emu-clause>

      <emu-clause id="SharedArrayBuffer_prototype_constructor">
        <h1><span class="secnum">4.1.4.2</span>SharedArrayBuffer.prototype.constructor</h1>
        <p> The initial value of <code>SharedArrayBuffer.prototype.constructor</code> is the intrinsic object %SharedArrayBuffer%. </p>
      </emu-clause>

      <emu-clause id="SharedArrayBuffer_prototype_slice">
        <h1><span class="secnum">4.1.4.3</span>SharedArrayBuffer.prototype.slice ( start, end )</h1>
        <p> The following steps are taken: </p>
        <emu-alg><ol>
  <li>Let <var>O</var> be the <emu-const>this</emu-const> value.</li>
  <li>If <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-data-types-and-values">Type</a>(<var>O</var>) is not <emu-const>Object</emu-const>, throw a <emu-const>TypeError</emu-const> exception.</li>
  <li>If <var>O</var> does not have a [[SharedArrayBufferData]] internal slot, throw a <emu-const>TypeError</emu-const> exception.</li>
  <li>Let <var>len</var> be the value of <var>O</var>’s [[SharedArrayBufferByteLength]] internal slot.</li>
  <li>Let <var>relativeStart</var> be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger">ToInteger</a>(<var>start</var>).</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>relativeStart</var>).</li>
  <li>If <var>relativeStart</var> &lt; 0, let first be max((<var>len</var> + <var>relativeStart</var>),0); else let first be min(<var>relativeStart</var>, <var>len</var>).</li>
  <li>If <var>end</var> is <emu-const>undefined</emu-const>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger">ToInteger</a>(<var>end</var>).</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>relativeEnd</var>).</li>
  <li>If <var>relativeEnd</var> &lt; 0, let <var>final</var> be max((<var>len</var> + <var>relativeEnd</var>),0); else let <var>final</var> be min(<var>relativeEnd</var>, <var>len</var>).</li>
  <li>Let <var>newLen</var> be max(<var>final_-_first</var>,0).</li>
  <li>Let <var>ctor</var> be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-speciesconstructor">SpeciesConstructor</a>(<var>O</var>, %SharedArrayBuffer%).</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>ctor</var>).</li>
  <li>Let <var>new</var> be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-construct-f-argumentslist">Construct</a>(<var>ctor</var>, «newLen»).</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>new</var>).</li>
  <li>If <var>new</var> does not have a [[SharedArrayBufferData]] internal slot, throw a <emu-const>TypeError</emu-const> exception.</li>
  <li>If <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevalue">SameValue</a>(<var>new</var>, <var>O</var>) is true, throw a <emu-const>TypeError</emu-const> exception.</li>
  <li>If the value of <var>new</var>’s [[SharedArrayBufferByteLength]] internal slot &lt; <var>newLen</var>, throw a <emu-const>TypeError</emu-const> exception.</li>
  <li>Let <var>fromBuf</var> be the value of <var>O</var>’s [[SharedArrayBufferData]] internal slot.</li>
  <li>Let <var>toBuf</var> be the value of <var>new</var>’s [[SharedArrayBufferData]] internal slot.</li>
  <li>Perform <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-copydatablockbytes">CopyDataBlockBytes</a>(<var>toBuf</var>, 0, <var>fromBuf</var>, <var>first</var>, <var>newLen</var>).</li>
  <li>Return <var>new</var>.</li>
</ol></emu-alg>
      </emu-clause>

      <emu-clause id="SharedArrayBuffer_prototype_toString">
        <h1><span class="secnum">4.1.4.4</span>SharedArrayBuffer.prototype[ @@toStringTag ]</h1>
        <p> The initial value of the @@toStringTag property is the String value <code>"SharedArrayBuffer"</code>.</p>

        <p>This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="SharedArrayBuffer_instances">
      <h1><span class="secnum">4.1.5</span>Properties of the SharedArrayBuffer instances</h1>

      <p> SharedArrayBuffer instances inherit properties from the SharedArrayBuffer prototype object. SharedArrayBuffer instances each have a [[SharedArrayBufferData]] internal slot and a [[SharedArrayBufferByteLength]] internal slot. </p>

      <emu-note><span class="note">Note</span>
        <p> SharedArrayBuffer instances, unlike ArrayBuffer instances, are never detached. </p>
      </emu-note>
    </emu-clause>

  </emu-clause>
</emu-clause>

<emu-clause id="AtomicsObject">
  <h1><span class="secnum">5</span>The Atomics Object</h1>
  
  <emu-clause id="AtomicsObjectValueProps">
    <h1><span class="secnum">5.1</span>Value Properties of the Atomics Object</h1>
    <emu-clause id="Atomics.OK">
      <h1><span class="secnum">5.1.1</span>Atomics.OK</h1>
      <p>The value 0.</p>
    </emu-clause>
    <emu-clause id="Atomics.NOTEQUAL">
      <h1><span class="secnum">5.1.2</span>Atomics.NOTEQUAL</h1>
      <p>The value -1.</p>
    </emu-clause>
    <emu-clause id="Atomics.TIMEDOUT">
      <h1><span class="secnum">5.1.3</span>Atomics.TIMEDOUT</h1>
      <p>The value -2.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause "atomicsobjectfunctionprops.semantics"="">
    <h1><span class="secnum">5.2</span>Runtime semantics</h1>
    
    <p> FIXME: Memory model probably goes here </p>

    <p> In the algorithms below, the algorithm step 'With atomic access to (<var>buffer</var>, <var>indexedPosition</var>, <var>elementSize</var>)' means the following:</p>
    <ul>
      <li> If several agents are claiming atomic access to exactly the same <var>elementSize</var> memory cells then these atomic sections are serialized, each agent executes all its dependent steps while the other agents are waiting
      </li><li> FIXME: Well-defined atomic sections are globally ordered
      </li><li> FIXME: It's possible to create ill-defined behavior with overlapping
      </li><li> FIXME: Conflicts are implementation dependent and can change over time (eg, moving from a spinlock to an atomic can change behavior)
    </li></ul>

    <p> In the algorithms below, the algorithm step 'Within the futex critical section' means the following:</p>
    <ul>
      <li> There is a critical section for the futex operations that is shared among all agents that can communicate through shared memory.
      </li><li> The phrase 'within the futex critical section' acquires that section exclusively; any return from the dependent statements releases the section.
    </li></ul>

    <emu-clause id="Atomics.ValidateSharedIntegerTypedArray" aoid="ValidateSharedIntegerTypedArray">
      <h1><span class="secnum">5.2.1</span>Runtime semantics: ValidateSharedIntegerTypedArray(<var>ta</var>, [onlyInt32])</h1>
      <emu-alg><ol>
  <li>If <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-data-types-and-values">Type</a>(<var>ta</var>) is not Object, throw a <emu-const>TypeError</emu-const> exception.</li>
  <li>Let <var>typeName</var> be the value of <var>ta</var>'s [[TypedArrayName]] internal slot</li>
  <li>If <var>onlyInt32</var> is <emu-const>true</emu-const> then
    <ol>
      <li>If <var>typeName</var> is not <code>"Int32Array"</code> then throw a <emu-const>TypeError</emu-const> exception</li>
    </ol>
  </li>
  <li>Else
    <ol>
      <li>If <var>typeName</var> is not <code>"Int8Array"</code>, <code>"Uint8Array"</code>, <code>"Int16Array"</code>, <code>"Uint16Array"</code>, <code>"Int32Array"</code>, or <code>"Uint32Array"</code> then throw a <emu-const>TypeError</emu-const> exception</li>
    </ol>
  </li>
  <li>If <var>ta</var> does not have a [[ViewedArrayBuffer]] internal slot, throw a <emu-const>TypeError</emu-const> exception.</li>
  <li>Let <var>buffer</var> be the value of <var>ta</var>’s [[ViewedArrayBuffer]] internal slot.</li>
  <li>If <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-data-types-and-values">Type</a>(<var>buffer</var>) is not Object, throw a <emu-const>TypeError</emu-const> exception.</li>
  <li>If <var>buffer</var> does not have a [[SharedArrayBufferData]] internal slot, throw a <emu-const>TypeError</emu-const> exception.</li>
  <li>Return <var>buffer</var></li>
</ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.ValidateAtomicAccess" aoid="ValidateAtomicAccess">
      <h1><span class="secnum">5.2.2</span>Runtime semantics: ValidateAtomicAccess(<var>ta</var>, <var>index</var>)</h1>
      <p> FIXME: Flesh this out; the original spec uses ToLength here but it may be more complicated </p>
      <emu-alg><ol>
  <li>If <var>index</var> can be interpreted as a nonnegative index <var>i</var> within <var>ta</var> then return <var>i</var>.</li>
  <li>Throw a RangeError exception</li>
</ol></emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.AddWaiter" aoid="AddWaiter">
      <h1><span class="secnum">5.2.3</span>Runtime semantics: AddWaiter(<var>W</var>, <var>G</var>, <var>i</var>)</h1>
      <emu-alg><ol>
  <li>Assert: The calling agent is in the futex critical section.</li>
  <li>Assert: <var>W</var> is not in any global list of waiters</li>
  <li>Add <var>W</var> to the end of the global list of all waiters that wait on (<var>G</var>, <var>i</var>)</li>
</ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.RemoveWaiter" aoid="RemoveWaiter">
      <h1><span class="secnum">5.2.4</span>Runtime semantics: RemoveWaiter(<var>W</var>, <var>G</var>, <var>i</var>)</h1>
      <emu-alg><ol>
  <li>Assert: The calling agent is in the futex critical section.</li>
  <li>Assert: <var>W</var> is in the global list of all waiters that wait on (<var>G</var>, <var>i</var>)</li>
  <li>Remove <var>W</var> from the global list of all waiters that wait on (<var>G</var>, <var>i</var>)</li>
</ol></emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.RemoveWaiters" aoid="RemoveWaiters">
      <h1><span class="secnum">5.2.5</span>Runtime semantics: RemoveWaiters(<var>G</var>, <var>i</var>)</h1>
      <emu-alg><ol>
  <li>Assert: The calling agent is in the futex critical section.</li>
  <li>Let <var>L</var> be a copy of the global list of all waiters that wait on (<var>G</var>, <var>i</var>)</li>
  <li>Set the global list of all waiters that wait on (<var>G</var>, <var>i</var>) to the empty list</li>
  <li>Return <var>L</var></li>
</ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.SuspendWaiter">
      <h1><span class="secnum">5.2.6</span>Runtime semantics: Suspend(<var>timeout</var>)</h1>
      <emu-alg><ol>
  <li>Assert: The calling agent is in the futex critical section.</li>
  <li>Assert: The calling agent is on some global list of waiters</li>
  <li>Atomically relinquish the futex critical section and suspend the calling agent for up to <var>timeout</var> milliseconds. It can wake up either because the timeout expired or because it was woken explicitly by another agent calling WakeWaiter, and not for any other reasons at all.</li>
  <li>Re-acquire the futex critical section.</li>
  <li>If the calling agent was woken explicitly by another agent calling WakeWaiter, then return <emu-const>true</emu-const></li>
  <li>Return <emu-const>false</emu-const></li>
</ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.WakeWaiter">
      <h1><span class="secnum">5.2.7</span>Runtime semantics: WakeWaiter(<var>W</var>)</h1>
      <emu-alg><ol>
  <li>Assert: The calling agent is in the futex critical section.</li>
  <li>Assert: <var>W</var> is on some global list of waiters</li>
  <li>Wake the agent <var>W</var></li>
</ol></emu-alg>
    </emu-clause>

  </emu-clause> <!-- runtime semantics -->

  <emu-clause id="AtomicsObjectFunctionProps">
    <h1><span class="secnum">5.3</span>Function Properties of the Atomics Object</h1>

    <emu-clause id="Atomics.add">
      <h1><span class="secnum">5.3.1</span>Atomics.add ( ta, index, value )</h1>
      <emu-alg><ol>
  <li>Let <var>buffer</var> be <a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a>(<var>ta</var>)</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>buffer</var>)</li>
  <li>Let <var>i</var> be <a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a>( <var>ta</var>, <var>index</var> )</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>i</var>)</li>
  <li>Let <var>v</var> be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tonumber">ToNumber</a>(<var>value</var>)</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>value</var>).</li>
  <li>Let <var>arrayTypeName</var> be the value of <var>ta</var>'s [[TypedArrayName]] internal slot</li>
  <li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for arrayTypeName.</li>
  <li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for arrayTypeName.</li>
  <li>Let <var>offset</var> be the value of <var>ta</var>’s [[ByteOffset]] internal slot.</li>
  <li>Let <var>indexedPosition</var> be (<var>i</var> * <var>elementSize</var>) + <var>offset</var></li>
  <li>With atomic access to ( <var>buffer</var>, <var>indexedPosition</var>, <var>elementSize</var> ), do:
    <ol>
      <li>Let <var>r</var> be the result of <a href="#StructuredData.SharedArrayBuffer.abstract.GetValueFromSharedBuffer">GetValueFromSharedBuffer</a>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var> )</li>
      <li>Compute: Let <var>w</var> be <var>r</var> + <var>v</var></li>
      <li>Call <a href="#StructuredData.SharedArrayBuffer.abstract.SetValueInSharedBuffer">SetValueInSharedBuffer</a>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>w</var> )</li>
    </ol>
  </li>
  <li>Return <var>r</var></li>
</ol></emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.and">
      <h1><span class="secnum">5.3.2</span>Atomics.and ( ta, index, value )</h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let <var>w</var> be <var>r</var> &amp; <var>v</var>.</p>
    </emu-clause>
    
    <emu-clause id="Atomics.compareExchange">
      <h1><span class="secnum">5.3.3</span>Atomics.compareExchange ( ta, index, expectedValue, replacementValue )</h1>
      <emu-alg><ol>
  <li>Let <var>buffer</var> be <a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a>(<var>ta</var>)</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>buffer</var>)</li>
  <li>Let <var>i</var> be <a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a>( <var>ta</var>, <var>index</var> )</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>i</var>)</li>
  <li>Let <var>expected</var> be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tonumber">ToNumber</a>(<var>expectedValue</var>)</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>expected</var>)</li>
  <li>Let <var>replacement</var> be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tonumber">ToNumber</a>(<var>replacedValue</var>)</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>replacement</var>)</li>
  <li>Let <var>arrayTypeName</var> be the value of <var>ta</var>'s [[TypedArrayName]] internal slot</li>
  <li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for arrayTypeName.</li>
  <li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for arrayTypeName.</li>
  <li>Let <var>offset</var> be the value of <var>ta</var>’s [[ByteOffset]] internal slot.</li>
  <li>Let <var>indexedPosition</var> be (<var>i</var> * <var>elementSize</var>) + <var>offset</var></li>
  <li>With atomic access to ( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var> ), do:
    <ol>
      <li>Let <var>r</var> be the result of <a href="#StructuredData.SharedArrayBuffer.abstract.GetValueFromSharedBuffer">GetValueFromSharedBuffer</a>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var> )</li>
      <li>If <var>r</var> equals <var>expected</var> then:
        <ol>
          <li>Call <a href="#StructuredData.SharedArrayBuffer.abstract.SetValueInSharedBuffer">SetValueInSharedBuffer</a>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>replacement</var> )</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Return <var>r</var></li>
</ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.exchange">
      <h1><span class="secnum">5.3.4</span>Atomics.exchange ( ta, index, value )</h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let <var>w</var> be <var>v</var>.</p>
    </emu-clause>

    <emu-clause id="Atomics.futexWait">
      <h1><span class="secnum">5.3.5</span>Atomics.futexWait ( ta, index, value, timeout )</h1>
      <emu-alg><ol>
  <li>Let <var>buffer</var> be <a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a>(<var>ta</var>, <emu-const>true</emu-const>)</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>buffer</var>)</li>
  <li>Let <var>i</var> be <a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a>( <var>ta</var>, <var>index</var> )</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>i</var>)</li>
  <li>Let <var>v</var> be the result of <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint32">ToInt32</a>(<var>value</var>).</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>v</var>)</li>
  <li>If <var>timeout</var> is not provided or is <emu-const>undefined</emu-const> then let <var>t</var> be +Infinity. Otherwise:
    <ol>
      <li>Let <var>q</var> be the result of <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tonumber">ToNumber</a>(<var>timeout</var>)</li>
      <li>If <var>q</var> is NaN then let <var>t</var> be +Infinity, otherwise let <var>t</var> be max(0,<var>q</var>).</li>
    </ol>
  </li>
  <li>Let <var>bufferVal</var> be the value of the internal [[SharedArrayBufferData]] property of <var>buffer</var>.</li>
  <li>Let <var>G</var> be <a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">SharedDataBlockID</a>(<var>bufferVal</var>)</li>
  <li>Within the futex critical section do:
    <ol>
      <li>Let <var>w</var> be Atomics.load(<var>ta</var>, <var>i</var>)</li>
      <li>If <var>v</var> does not equal <var>w</var> then return the original value of <emu-const>Atomics.NOTEQUAL</emu-const>.</li>
      <li>Let <var>W</var> be a signifier for the calling agent</li>
      <li>Call <a href="#Atomics.AddWaiter">AddWaiter</a>(<var>W</var>, <var>G</var>, <var>i</var>)</li>
      <li>Let awoken = Suspend(<var>t</var>)</li>
      <li>Call <a href="#Atomics.RemoveWaiter">RemoveWaiter</a>(<var>W</var>, <var>G</var>, <var>i</var>)</li>
    </ol>
  </li>
  <li>If awoken = <emu-const>true</emu-const> then return the original value of <emu-const>Atomics.OK</emu-const>.</li>
  <li>Return the original value of <emu-const>Atomics.TIMEDOUT</emu-const>.</li>
</ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p> The name "futex" comes from Linux, where it means "fast user-space mutex". Linux has wait/wake system calls with names and functionality similar to what's defined here. The mechanism described here is however not Linux-dependent in any way. </p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.futexWake">
      <h1><span class="secnum">5.3.6</span>Atomics.futexWake ( ta, index, count )</h1>
      <emu-alg><ol>
  <li>Let <var>buffer</var> be <a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a>(<var>ta</var>, <emu-const>true</emu-const>)</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>buffer</var>)</li>
  <li>Let <var>i</var> be <a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a>( <var>ta</var>, <var>index</var> )</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>i</var>)</li>
  <li>Let <var>c</var> be max(+0,<a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger">ToInteger</a>(<var>count</var>)).</li>
  <li>Let <var>bufferVal</var> be the value of the internal [[SharedArrayBufferData]] property of <var>buffer</var>.</li>
  <li>Let <var>G</var> be <a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">SharedDataBlockID</a>(<var>bufferVal</var>)</li>
  <li>Let <var>n</var> = 0</li>
  <li>Within the futex critical section do:
    <ol>
      <li>Let <var>S</var> be <a href="#Atomics.RemoveWaiters">RemoveWaiters</a>(<var>G</var>, <var>i</var>)</li>
      <li>While <var>c</var> &gt; 0 and <var>S</var> is not the empty list:
        <ol>
          <li>Let <var>W</var> be the first agent in <var>S</var></li>
          <li>Remove <var>W</var> from the front of <var>S</var></li>
          <li>Call WakeWaiter(<var>W</var>)</li>
          <li>Subtract 1 from <var>c</var></li>
          <li>Add 1 to <var>n</var></li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Return <var>n</var>.</li>
</ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.futexWakeOrRequeue">
      <h1><span class="secnum">5.3.7</span>Atomics.futexWakeOrRequeue ( ta, index1, count, index2, value )</h1>
      <emu-alg><ol>
  <li>Let <var>buffer</var> be <a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a>(<var>ta</var>, <emu-const>true</emu-const>)</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>buffer</var>)</li>
  <li>Let <var>i</var> be <a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a>( <var>ta</var>, <var>index1</var> )</li>
  <li>Let <var>c</var> be max(+0,<a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger">ToInteger</a>(<var>count</var>))</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>i</var>)</li>
  <li>Let <var>j</var> be <a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a>( <var>ta</var>, <var>index2</var> )</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>j</var>)</li>
  <li>Let <var>v</var> be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint32">ToInt32</a>(<var>value</var>)</li>
  <li>Let <var>bufferVal</var> be the value of the internal [[SharedArrayBufferData]] property of <var>buffer</var></li>
  <li>Let <var>G</var> be <a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">SharedDataBlockID</a>(<var>bufferVal</var>)</li>
  <li>Within the futex critical section do:
    <ol>
      <li>Let <var>w</var> be Atomics.load(<var>ta</var>, <var>i</var>)</li>
      <li>If <var>v</var> does not equal <var>w</var> then return the original value of <emu-const>Atomics.NOTEQUAL</emu-const></li>
      <li>Let <var>S</var> be <a href="#Atomics.RemoveWaiters">RemoveWaiters</a>(<var>G</var>, <var>i</var>)</li>
      <li>Let <var>n</var> = 0</li>
      <li>While <var>c</var> &gt; 0 and <var>S</var> is not the empty list:
        <ol>
          <li>Let <var>W</var> be the first agent in <var>S</var></li>
          <li>Remove <var>W</var> from the front of <var>S</var></li>
          <li>Call WakeWaiter(<var>W</var>)</li>
          <li>Subtract 1 from <var>c</var></li>
          <li>Add 1 to <var>n</var></li>
        </ol>
      </li>
      <li>While <var>S</var> is not the empty list:
        <ol>
          <li>Let <var>W</var> be the first agent in <var>S</var></li>
          <li>Remove <var>W</var> from the front of <var>S</var></li>
          <li>Call <a href="#Atomics.AddWaiter">AddWaiter</a>(<var>W</var>, <var>G</var>, <var>j</var>)</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Return <var>n</var>.</li>
</ol></emu-alg>        

      <emu-note><span class="note">Note</span>
        <p> Atomics.futexWaitOrRequeue is an optimization that helps programs avoid a "thundering herd" problem when many threads are woken and compete for a lock (as in a broadcast). </p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.isLockFree">
      <h1><span class="secnum">5.3.8</span>Atomics.isLockFree ( size )</h1>

      <p> An atomic operation on a range of locations (<var>sab</var>, <var>offset</var>, <var>size</var>) is said to be <var>lock-free</var> if the algorithm section of the operation that is labeled 'With atomic access to (<var>sab</var>, <var>offset</var>, <var>size</var>)' is implemented in a way that does not require a lock outside the specified data locations to be acquired. </p>

      <emu-alg><ol>
  <li>Let <var>n</var> be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger">ToInteger</a>(<var>size</var>)</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>n</var>)</li>
  <li>If <var>n</var> is not the initial value of the BYTES<var>PER</var>ELEMENT property of some TypedArray then return <emu-const>false</emu-const></li>
  <li>If an atomic operation (compareExchange, load, store, add, sub, and, or, xor, or exchange) on a datum of size <var>n</var> bytes will be performed in a lock-free manner in the calling agent then return <emu-const>true</emu-const></li>
  <li>Return <emu-const>false</emu-const></li>
</ol></emu-alg>

      <p>If Atomics.isLockFree(k) returns v in some agent then every subsequent invocation of Atomics.isLockFree(k) in that environment must return v. Furthermore, any invocation of Atomics.isLockFree(k) in any other agent that can (assuming arbitrary code) reference (in the past, currently, or in the future) any of the same shared memory that the first environment references must also return v.</p>

      <emu-note><span class="note">Note 1</span>
        <p> Atomics.isLockFree is an optimization primitive. High-performance algorithms will use it to determine whether to use locks or atomic operations in critical sections. If an atomic primitive is not lock-free then it is often more efficient for an algorithm to provide its own locking.</p>
      </emu-note>

      <emu-note><span class="note">Note 2</span>
        <p>The return value for a given argument is not necessarily a constant on a given piece of hardware, but also reflects implementation choices that can vary over time and across engines. The specification requires that if a SharedArrayBuffer can be communicated from one agent to another even in principle, for unrestricted agent types (web workers, service workers, ...) and unrestricted communication channels (postMessage or other mechanisms that might exist), then the two agents must agree on the values returned from isLockFree.</p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.load">
      <h1><span class="secnum">5.3.9</span>Atomics.load ( ta, index )</h1>
      <emu-alg><ol>
  <li>Let <var>buffer</var> be <a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a>(<var>ta</var>)</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>buffer</var>)</li>
  <li>Let <var>i</var> be <a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a>( <var>ta</var>, <var>index</var> )</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>i</var>)</li>
  <li>Let <var>arrayTypeName</var> be the value of <var>ta</var>'s [[TypedArrayName]] internal slot</li>
  <li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for arrayTypeName.</li>
  <li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for arrayTypeName.</li>
  <li>Let <var>offset</var> be the value of <var>ta</var>’s [[ByteOffset]] internal slot.</li>
  <li>Let <var>indexedPosition</var> be (<var>i</var> * <var>elementSize</var>) + <var>offset</var></li>
  <li>With atomic access to ( <var>buffer</var>, <var>indexedPosition</var>, <var>elementSize</var> ), do:
    <ol>
      <li>Let <var>r</var> be the result of <a href="#StructuredData.SharedArrayBuffer.abstract.GetValueFromSharedBuffer">GetValueFromSharedBuffer</a>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var> )</li>
    </ol>
  </li>
  <li>Return <var>r</var></li>
</ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.or">
      <h1><span class="secnum">5.3.10</span>Atomics.or ( ta, index, value )</h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let <var>w</var> be <var>r</var> | <var>v</var>.</p>
    </emu-clause>
    
    <emu-clause id="Atomics.store">
      <h1><span class="secnum">5.3.11</span>Atomics.store ( ta, index, value )</h1>
      <emu-alg><ol>
  <li>Let <var>buffer</var> be <a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a>(<var>ta</var>)</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>buffer</var>)</li>
  <li>Let <var>i</var> be <a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a>( <var>ta</var>, <var>index</var> )</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>i</var>)</li>
  <li>Let <var>v</var> be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tonumber">ToNumber</a>(<var>value</var>)</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>v</var>)</li>
  <li>Let <var>arrayTypeName</var> be the value of <var>ta</var>'s [[TypedArrayName]] internal slot</li>
  <li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for arrayTypeName.</li>
  <li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for arrayTypeName.</li>
  <li>Let <var>offset</var> be the value of <var>ta</var>’s [[ByteOffset]] internal slot.</li>
  <li>Let <var>indexedPosition</var> be (<var>i</var> * <var>elementSize</var>) + <var>offset</var></li>
  <li>With atomic access to ( <var>buffer</var>, <var>indexedPosition</var>, <var>elementSize</var> ), do:
    <ol>
      <li>Call <a href="#StructuredData.SharedArrayBuffer.abstract.SetValueInSharedBuffer">SetValueInSharedBuffer</a>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>v</var> )</li>
    </ol>
  </li>
  <li>Return <var>v</var></li>
</ol></emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.sub">
      <h1><span class="secnum">5.3.12</span>Atomics.sub ( ta, index, value )</h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let <var>w</var> be <var>r</var> - <var>v</var>.</p>
    </emu-clause>
    
    <emu-clause id="Atomics.xor">
      <h1><span class="secnum">5.3.13</span>Atomics.xor ( ta, index, value )</h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let <var>w</var> be <var>r</var> ^ <var>v</var>.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>
</body>
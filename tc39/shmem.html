<!doctype html>
<head><meta charset="utf-8">
<title>ECMAScript Shared Memory and Atomics</title><script type="application/json" id="menu-search-biblio">[{"type":"clause","id":"intro","aoid":null,"title":"Introduction","number":"","namespace":"<no location>","location":"","key":"Introduction"},{"type":"clause","id":"Overview","aoid":null,"title":"Overview (ES7 4)","number":"1","namespace":"<no location>","location":"","key":"Overview (ES7 4)"},{"type":"clause","id":"Overview.Overview","aoid":null,"title":"ECMAScript Overview (ES7 4.2)","number":"1.1","namespace":"<no location>","location":"","key":"ECMAScript Overview (ES7 4.2)"},{"type":"clause","id":"DataTypesValues","aoid":null,"title":"ECMAScript Data Types and Values (ES7 6)","number":"2","namespace":"<no location>","location":"","key":"ECMAScript Data Types and Values (ES7 6)"},{"type":"clause","id":"DataTypesValues.LanguageTypes","aoid":null,"title":"ECMAScript Language Types (ES7 6.1)","number":"2.1","namespace":"<no location>","location":"","key":"ECMAScript Language Types (ES7 6.1)"},{"type":"clause","id":"DataTypesValues.LanguageTypes.Number","aoid":null,"title":"The Number Type (ES7 6.1.6)","number":"2.1.1","namespace":"<no location>","location":"","key":"The Number Type (ES7 6.1.6)"},{"type":"clause","id":"DataTypesValues.LanguageTypes.Object","aoid":null,"title":"The Object Type (ES7 6.1.7)","number":"2.1.2","namespace":"<no location>","location":"","key":"The Object Type (ES7 6.1.7)"},{"type":"clause","id":"DataTypesValues.LanguageTypes.Object.Intrinsic","aoid":null,"title":"Well-Known Intrinsic Objects (ES7 6.1.7.4)","number":"2.1.2.1","namespace":"<no location>","location":"","key":"Well-Known Intrinsic Objects (ES7 6.1.7.4)"},{"type":"clause","id":"DataTypesValues.SpecTypes","aoid":null,"title":"ECMAScript Specification Types (ES7 6.2)","number":"2.2","namespace":"<no location>","location":"","key":"ECMAScript Specification Types (ES7 6.2)"},{"type":"clause","id":"DataTypesValues.SpecTypes.DataBlocks","aoid":null,"title":"Data blocks (ES7 6.2.6)","number":"2.2.1","namespace":"<no location>","location":"","key":"Data blocks (ES7 6.2.6)"},{"type":"op","aoid":"CopyDataBlockBytes","refId":"DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes","location":"","key":"CopyDataBlockBytes"},{"type":"clause","id":"DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes","aoid":"CopyDataBlockBytes","title":"CopyDataBlockBytes ( _toBlock_, _toIndex_, _fromBlock_, _fromIndex_, _count_ ) (ES7 6.2.6.2)","number":"2.2.1.1","namespace":"<no location>","location":"","key":"CopyDataBlockBytes ( _toBlock_, _toIndex_, _fromBlock_, _fromIndex_, _count_ ) (ES7 6.2.6.2)"},{"type":"op","aoid":"CreateSharedByteDataBlock","refId":"DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock","location":"","key":"CreateSharedByteDataBlock"},{"type":"clause","id":"DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock","aoid":"CreateSharedByteDataBlock","title":"CreateSharedByteDataBlock( _size_ )","number":"2.2.1.2","namespace":"<no location>","location":"","key":"CreateSharedByteDataBlock( _size_ )"},{"type":"clause","id":"ExecutableCodeAndContexts","aoid":null,"title":"Executable Code and Execution Contexts (ES7 8)","number":"3","namespace":"<no location>","location":"","key":"Executable Code and Execution Contexts (ES7 8)"},{"type":"clause","id":"ExecutableCodeAndContexts.JobsAndJobQueues","aoid":null,"title":"Jobs and Job Queues (ES7 8.4)","number":"3.1","namespace":"<no location>","location":"","key":"Jobs and Job Queues (ES7 8.4)"},{"type":"clause","id":"ExecutableCodeAndContexts.JobsAndJobQueues.Progress","aoid":null,"title":"Forward Progress Guarantees","number":"3.1.1","namespace":"<no location>","location":"","key":"Forward Progress Guarantees"},{"type":"clause","id":"ExecutableCodeAndContexts.AgentCluster","aoid":null,"title":"Agents (AMENDMENTS)","number":"3.2","namespace":"<no location>","location":"","key":"Agents (AMENDMENTS)"},{"type":"clause","id":"ExecutableCodeAndContexts.AgentCluster","aoid":null,"title":"Agent Clusters (NEW)","number":"3.3","namespace":"<no location>","location":"","key":"Agent Clusters (NEW)"},{"type":"clause","id":"sec-ordinary-and-exotic-objects-behaviours","aoid":null,"title":"Ordinary and Exotic Objects Behaviours (ES7 9)","number":"4","namespace":"<no location>","location":"","key":"Ordinary and Exotic Objects Behaviours (ES7 9)"},{"type":"clause","id":"sec-built-in-exotic-object-internal-methods-and-slots","aoid":null,"title":"Built-in Exotic Object Internal Methods and Slots (ES7 9.4)","number":"4.1","namespace":"<no location>","location":"","key":"Built-in Exotic Object Internal Methods and Slots (ES7 9.4)"},{"type":"clause","id":"sec-integer-indexed-exotic-objects","aoid":null,"title":"Integer Indexed Exotic Objects (ES7 9.4.5)","number":"4.1.1","namespace":"<no location>","location":"","key":"Integer Indexed Exotic Objects (ES7 9.4.5)"},{"type":"op","aoid":"IntegerIndexedElementGet","refId":"sec-integerindexedelementget","location":"","key":"IntegerIndexedElementGet"},{"type":"clause","id":"sec-integerindexedelementget","aoid":"IntegerIndexedElementGet","title":"IntegerIndexedElementGet ( _O_, _index_ ) (ES7 9.4.5.8)","number":"4.1.1.1","namespace":"<no location>","location":"","key":"IntegerIndexedElementGet ( _O_, _index_ ) (ES7 9.4.5.8)"},{"type":"op","aoid":"IntegerIndexedElementSet","refId":"sec-integerindexedelementset","location":"","key":"IntegerIndexedElementSet"},{"type":"clause","id":"sec-integerindexedelementset","aoid":"IntegerIndexedElementSet","title":"IntegerIndexedElementSet ( _O_, _index_, _value_ ) (ES7 9.4.5.9)","number":"4.1.1.2","namespace":"<no location>","location":"","key":"IntegerIndexedElementSet ( _O_, _index_, _value_ ) (ES7 9.4.5.9)"},{"type":"clause","id":"GlobalObject","aoid":null,"title":"The Global Object (ES7 18)","number":"5","namespace":"<no location>","location":"","key":"The Global Object (ES7 18)"},{"type":"clause","id":"GlobalObject.ConstructorProps","aoid":null,"title":"Constructor Properties of the Global Object (ES7 18.3)","number":"5.1","namespace":"<no location>","location":"","key":"Constructor Properties of the Global Object (ES7 18.3)"},{"type":"clause","id":"GlobalObject.ConstructorProps.SharedArrayBuffer","aoid":null,"title":"SharedArrayBuffer","number":"5.1.1","namespace":"<no location>","location":"","key":"SharedArrayBuffer"},{"type":"clause","id":"GlobalObject.ConstructorProps.Atomics","aoid":null,"title":"Atomics","number":"5.1.2","namespace":"<no location>","location":"","key":"Atomics"},{"type":"clause","id":"IndexedCollections","aoid":null,"title":"Indexed Collections (ES7 22)","number":"6","namespace":"<no location>","location":"","key":"Indexed Collections (ES7 22)"},{"type":"clause","id":"IndexedCollections.TypedArray","aoid":null,"title":"TypedArray Objects (ES7 22.2)","number":"6.1","namespace":"<no location>","location":"","key":"TypedArray Objects (ES7 22.2)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype","aoid":null,"title":"Properties of the %TypedArrayPrototype% object (ES7 22.2.3)","number":"6.1.1","namespace":"<no location>","location":"","key":"Properties of the %TypedArrayPrototype% object (ES7 22.2.3)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype.set","aoid":null,"title":"%TypedArray%.prototype.set( _overloaded_ [ , _offset_ ] ) (ES7 22.2.3.23)","number":"6.1.1.1","namespace":"<no location>","location":"","key":"%TypedArray%.prototype.set( _overloaded_ [ , _offset_ ] ) (ES7 22.2.3.23)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype.setFromTypedArray","aoid":null,"title":"%TypedArray%.prototype.set( _array_ [, _offset_ ] ) (ES7 22.2.3.23.1)","number":"6.1.1.1.1","namespace":"<no location>","location":"","key":"%TypedArray%.prototype.set( _array_ [, _offset_ ] ) (ES7 22.2.3.23.1)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype.setFromTypedArray","aoid":null,"title":"%TypedArray%.prototype.set( _typedArray_ [, _offset_ ] ) (ES7 22.2.3.23.2)","number":"6.1.1.1.2","namespace":"<no location>","location":"","key":"%TypedArray%.prototype.set( _typedArray_ [, _offset_ ] ) (ES7 22.2.3.23.2)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype.slice","aoid":null,"title":"%TypedArray%.prototype.slice( _start_, _end_ ) (ES7 22.2.3.24)","number":"6.1.1.1.3","namespace":"<no location>","location":"","key":"%TypedArray%.prototype.slice( _start_, _end_ ) (ES7 22.2.3.24)"},{"type":"clause","id":"IndexedCollections.TypedArray.constructors","aoid":null,"title":"The %TypedArray% constructors (ES7 22.2.4)","number":"6.1.2","namespace":"<no location>","location":"","key":"The %TypedArray% constructors (ES7 22.2.4)"},{"type":"clause","id":"sec-typedarray-typedarray","aoid":null,"title":"_TypedArray_ ( _typedArray_ ) (ES7 22.2.4.3)","number":"6.1.2.1","namespace":"<no location>","location":"","key":"_TypedArray_ ( _typedArray_ ) (ES7 22.2.4.3)"},{"type":"clause","id":"StructuredData","aoid":null,"title":"Structured Data (ES7 24)","number":"7","namespace":"<no location>","location":"","key":"Structured Data (ES7 24)"},{"type":"clause","id":"StructuredData.ArrayBuffer","aoid":null,"title":"ArrayBuffer Objects (ES7 24.1)","number":"7.1","namespace":"<no location>","location":"","key":"ArrayBuffer Objects (ES7 24.1)"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract","aoid":null,"title":"Abstract Operations for ArrayBuffer (ES7 24.1.1)","number":"7.1.1","namespace":"<no location>","location":"","key":"Abstract Operations for ArrayBuffer (ES7 24.1.1)"},{"type":"op","aoid":"DetachArrayBuffer","refId":"sec-detacharraybuffer","location":"","key":"DetachArrayBuffer"},{"type":"clause","id":"sec-detacharraybuffer","aoid":"DetachArrayBuffer","title":"DetachArrayBuffer ( _arrayBuffer_ ) (ES7 24.1.1.3)","number":"7.1.1.1","namespace":"<no location>","location":"","key":"DetachArrayBuffer ( _arrayBuffer_ ) (ES7 24.1.1.3)"},{"type":"op","aoid":"GetValueFromBuffer","refId":"StructuredData.ArrayBuffer.abstract.GetValueFromBuffer","location":"","key":"GetValueFromBuffer"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract.GetValueFromBuffer","aoid":"GetValueFromBuffer","title":"GetValueFromBuffer( _arrayBuffer_, _byteIndex_, _type_, _isTypedArray_, _isLittleEndian_ ) (ES7 24.1.1.5)","number":"7.1.1.2","namespace":"<no location>","location":"","key":"GetValueFromBuffer( _arrayBuffer_, _byteIndex_, _type_, _isTypedArray_, _isLittleEndian_ ) (ES7 24.1.1.5)"},{"type":"op","aoid":"SetValueInBuffer","refId":"StructuredData.ArrayBuffer.abstract.SetValueInBuffer","location":"","key":"SetValueInBuffer"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract.SetValueInBuffer","aoid":"SetValueInBuffer","title":"SetValueInBuffer( _arrayBuffer_, _byteIndex_, _type_, _isTypedArray_, _value_, _isLittleEndian_ ) (ES7 24.1.1.6)","number":"7.1.1.3","namespace":"<no location>","location":"","key":"SetValueInBuffer( _arrayBuffer_, _byteIndex_, _type_, _isTypedArray_, _value_, _isLittleEndian_ ) (ES7 24.1.1.6)"},{"type":"clause","id":"sec-properties-of-the-arraybuffer-prototype-object","aoid":null,"title":"Properties of the ArrayBuffer Prototype Object (ES7 24.1.4)","number":"7.1.2","namespace":"<no location>","location":"","key":"Properties of the ArrayBuffer Prototype Object (ES7 24.1.4)"},{"type":"clause","id":"sec-get-arraybuffer.prototype.bytelength","aoid":null,"title":"get ArrayBuffer.prototype.byteLength (ES7 24.1.4.1)","number":"7.1.2.1","namespace":"<no location>","location":"","key":"get ArrayBuffer.prototype.byteLength (ES7 24.1.4.1)"},{"type":"clause","id":"sec-arraybuffer.prototype.slice","aoid":null,"title":"ArrayBuffer.prototype.slice ( _start_, _end_ ) (ES7 24.1.4.3)","number":"7.1.2.2","namespace":"<no location>","location":"","key":"ArrayBuffer.prototype.slice ( _start_, _end_ ) (ES7 24.1.4.3)"},{"type":"clause","id":"StructuredData.DataView","aoid":null,"title":"DataView Objects (ES7 24.2)","number":"7.2","namespace":"<no location>","location":"","key":"DataView Objects (ES7 24.2)"},{"type":"clause","id":"sec-abstract-operations-for-dataview-objects","aoid":null,"title":"Abstract Operations For DataView Objects (ES7 24.2.1)","number":"7.2.1","namespace":"<no location>","location":"","key":"Abstract Operations For DataView Objects (ES7 24.2.1)"},{"type":"op","aoid":"GetViewValue","refId":"sec-getviewvalue","location":"","key":"GetViewValue"},{"type":"clause","id":"sec-getviewvalue","aoid":"GetViewValue","title":"GetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_ ) (ES7 24.2.1.1)","number":"7.2.1.1","namespace":"<no location>","location":"","key":"GetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_ ) (ES7 24.2.1.1)"},{"type":"op","aoid":"SetViewValue","refId":"sec-setviewvalue","location":"","key":"SetViewValue"},{"type":"clause","id":"sec-setviewvalue","aoid":"SetViewValue","title":"SetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_, _value_ ) (ES7 24.2.1.2)","number":"7.2.1.2","namespace":"<no location>","location":"","key":"SetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_, _value_ ) (ES7 24.2.1.2)"},{"type":"clause","id":"StructuredData.SharedArrayBuffer","aoid":null,"title":"SharedArrayBuffer Objects","number":"7.3","namespace":"<no location>","location":"","key":"SharedArrayBuffer Objects"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.abstract","aoid":null,"title":"Abstract Operations for SharedArrayBuffer","number":"7.3.1","namespace":"<no location>","location":"","key":"Abstract Operations for SharedArrayBuffer"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer","aoid":null,"title":"AllocateSharedArrayBuffer( _constructor_, _byteLength_ )","number":"7.3.1.1","namespace":"<no location>","location":"","key":"AllocateSharedArrayBuffer( _constructor_, _byteLength_ )"},{"type":"op","aoid":"IsSharedArrayBuffer","refId":"StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer","location":"","key":"IsSharedArrayBuffer"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer","aoid":"IsSharedArrayBuffer","title":"IsSharedArrayBuffer( _obj_ )","number":"7.3.1.2","namespace":"<no location>","location":"","key":"IsSharedArrayBuffer( _obj_ )"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor","aoid":null,"title":"The SharedArrayBuffer Constructor","number":"7.3.1.3","namespace":"<no location>","location":"","key":"The SharedArrayBuffer Constructor"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor.withLength","aoid":null,"title":"SharedArrayBuffer( _length_ )","number":"7.3.1.3.1","namespace":"<no location>","location":"","key":"SharedArrayBuffer( _length_ )"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor.properties","aoid":null,"title":"Properties of the SharedArrayBuffer constructor","number":"7.3.1.4","namespace":"<no location>","location":"","key":"Properties of the SharedArrayBuffer constructor"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor.properties.prototype","aoid":null,"title":"SharedArrayBuffer.prototype","number":"7.3.1.4.1","namespace":"<no location>","location":"","key":"SharedArrayBuffer.prototype"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor.properties.get_species","aoid":null,"title":"get SharedArrayBuffer [ @@species ]","number":"7.3.1.4.2","namespace":"<no location>","location":"","key":"get SharedArrayBuffer [ @@species ]"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype","aoid":null,"title":"Properties of the SharedArrayBuffer prototype object","number":"7.3.1.5","namespace":"<no location>","location":"","key":"Properties of the SharedArrayBuffer prototype object"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype.get_byteLength","aoid":null,"title":"get SharedArrayBuffer.prototype.byteLength","number":"7.3.1.5.1","namespace":"<no location>","location":"","key":"get SharedArrayBuffer.prototype.byteLength"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype.constructor","aoid":null,"title":"SharedArrayBuffer.prototype.constructor","number":"7.3.1.5.2","namespace":"<no location>","location":"","key":"SharedArrayBuffer.prototype.constructor"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype.slice","aoid":null,"title":"SharedArrayBuffer.prototype.slice( _start_, _end_ )","number":"7.3.1.5.3","namespace":"<no location>","location":"","key":"SharedArrayBuffer.prototype.slice( _start_, _end_ )"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype.toString","aoid":null,"title":"SharedArrayBuffer.prototype[ @@toStringTag ]","number":"7.3.1.5.4","namespace":"<no location>","location":"","key":"SharedArrayBuffer.prototype[ @@toStringTag ]"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.instances","aoid":null,"title":"Properties of the SharedArrayBuffer instances","number":"7.3.1.6","namespace":"<no location>","location":"","key":"Properties of the SharedArrayBuffer instances"},{"type":"clause","id":"AtomicsObject","aoid":null,"title":"The Atomics Object","number":"7.4","namespace":"<no location>","location":"","key":"The Atomics Object"},{"type":"clause","id":"AtomicsObject.FunctionProps.semantics","aoid":null,"title":"Runtime semantics","number":"7.4.1","namespace":"<no location>","location":"","key":"Runtime semantics"},{"type":"clause","id":"AtomicsObject.MemoryModel","aoid":null,"title":"Memory model","number":"7.4.1.1","namespace":"<no location>","location":"","key":"Memory model"},{"type":"clause","id":"AtomicsObject.Fundamentals","aoid":null,"title":"Fundamentals","number":"7.4.1.1.1","namespace":"<no location>","location":"","key":"Fundamentals"},{"type":"clause","id":"AtomicsObject.Formalization","aoid":null,"title":"Formalization framework","number":"7.4.1.1.2","namespace":"<no location>","location":"","key":"Formalization framework"},{"type":"clause","id":"AtomicsObject.Transformations","aoid":null,"title":"Program transformations","number":"7.4.1.1.3","namespace":"<no location>","location":"","key":"Program transformations"},{"type":"op","aoid":"ReadSharedMemory","refId":"Atomics.ReadSharedMemory","location":"","key":"ReadSharedMemory"},{"type":"clause","id":"Atomics.ReadSharedMemory","aoid":"ReadSharedMemory","title":"ReadSharedMemory(_block_, _byteIndex_, _accessAtomic_, _numBytes_)","number":"7.4.1.1.4","namespace":"<no location>","location":"","key":"ReadSharedMemory(_block_, _byteIndex_, _accessAtomic_, _numBytes_)"},{"type":"op","aoid":"WriteSharedMemory","refId":"Atomics.WriteSharedMemory","location":"","key":"WriteSharedMemory"},{"type":"clause","id":"Atomics.WriteSharedMemory","aoid":"WriteSharedMemory","title":"WriteSharedMemory(_block_, _byteIndex_, _accessAtomic_, _numBytes_, _rawBytes_)","number":"7.4.1.1.5","namespace":"<no location>","location":"","key":"WriteSharedMemory(_block_, _byteIndex_, _accessAtomic_, _numBytes_, _rawBytes_)"},{"type":"op","aoid":"BeginAtomic","refId":"Atomics.BeginAtomic","location":"","key":"BeginAtomic"},{"type":"clause","id":"Atomics.BeginAtomic","aoid":"BeginAtomic","title":"BeginAtomic(_block_, _byteIndex_, _elementSize_)","number":"7.4.1.1.6","namespace":"<no location>","location":"","key":"BeginAtomic(_block_, _byteIndex_, _elementSize_)"},{"type":"op","aoid":"EndAtomic","refId":"Atomics.EndAtomic","location":"","key":"EndAtomic"},{"type":"clause","id":"Atomics.EndAtomic","aoid":"EndAtomic","title":"EndAtomic(_timestamp_)","number":"7.4.1.1.7","namespace":"<no location>","location":"","key":"EndAtomic(_timestamp_)"},{"type":"op","aoid":"BeginNonAtomic","refId":"Atomics.BeginNonAtomic","location":"","key":"BeginNonAtomic"},{"type":"clause","id":"Atomics.BeginNonAtomic","aoid":"BeginNonAtomic","title":"BeginNonAtomic(_op_, _block_, _byteIndex_, _elementSize_)","number":"7.4.1.1.8","namespace":"<no location>","location":"","key":"BeginNonAtomic(_op_, _block_, _byteIndex_, _elementSize_)"},{"type":"op","aoid":"EndNonAtomic","refId":"Atomics.EndNonAtomic","location":"","key":"EndNonAtomic"},{"type":"clause","id":"Atomics.EndNonAtomic","aoid":"EndNonAtomic","title":"EndNonAtomic(_timestamp_)","number":"7.4.1.1.9","namespace":"<no location>","location":"","key":"EndNonAtomic(_timestamp_)"},{"type":"op","aoid":"NonAtomicRead","refId":"Atomics.NonAtomicRead","location":"","key":"NonAtomicRead"},{"type":"clause","id":"Atomics.NonAtomicRead","aoid":"NonAtomicRead","title":"NonAtomicRead(_block_, _byteIndex_, _accessAtomic_, _elementSize_)","number":"7.4.1.1.10","namespace":"<no location>","location":"","key":"NonAtomicRead(_block_, _byteIndex_, _accessAtomic_, _elementSize_)"},{"type":"op","aoid":"NonAtomicWrite","refId":"Atomics.NonAtomicWrite","location":"","key":"NonAtomicWrite"},{"type":"clause","id":"Atomics.NonAtomicWrite","aoid":"NonAtomicWrite","title":"NonAtomicWrite(_block_, _byteIndex_, _accessAtomic_, _elementSize_, _rawBytes_)","number":"7.4.1.1.11","namespace":"<no location>","location":"","key":"NonAtomicWrite(_block_, _byteIndex_, _accessAtomic_, _elementSize_, _rawBytes_)"},{"type":"op","aoid":"AtomicRead","refId":"Atomics.AtomicRead","location":"","key":"AtomicRead"},{"type":"clause","id":"Atomics.AtomicRead","aoid":"AtomicRead","title":"AtomicRead(_buffer_, _byteIndex_, _type_)","number":"7.4.1.1.12","namespace":"<no location>","location":"","key":"AtomicRead(_buffer_, _byteIndex_, _type_)"},{"type":"op","aoid":"AtomicWrite","refId":"Atomics.AtomicWrite","location":"","key":"AtomicWrite"},{"type":"clause","id":"Atomics.AtomicWrite","aoid":"AtomicWrite","title":"AtomicWrite(_buffer_, _byteIndex_, _type_, _v_)","number":"7.4.1.1.13","namespace":"<no location>","location":"","key":"AtomicWrite(_buffer_, _byteIndex_, _type_, _v_)"},{"type":"op","aoid":"AtomicReadModifyWrite","refId":"Atomics.AtomicReadModifyWrite","location":"","key":"AtomicReadModifyWrite"},{"type":"clause","id":"Atomics.AtomicReadModifyWrite","aoid":"AtomicReadModifyWrite","title":"AtomicReadModifyWrite(_buffer_, _byteIndex_, _type_, _op_, _v_)","number":"7.4.1.1.14","namespace":"<no location>","location":"","key":"AtomicReadModifyWrite(_buffer_, _byteIndex_, _type_, _op_, _v_)"},{"type":"op","aoid":"AtomicCompareExchange","refId":"Atomics.AtomicCompareExchange","location":"","key":"AtomicCompareExchange"},{"type":"clause","id":"Atomics.AtomicCompareExchange","aoid":"AtomicCompareExchange","title":"AtomicCompareExchange(_buffer_, _byteIndex_, _type_, _expected_, _replacement_)","number":"7.4.1.1.15","namespace":"<no location>","location":"","key":"AtomicCompareExchange(_buffer_, _byteIndex_, _type_, _expected_, _replacement_)"},{"type":"clause","id":"AtomicsObject.PropertiesOfMemModel","aoid":null,"title":"Properties of the Memory Model","number":"7.4.1.2","namespace":"<no location>","location":"","key":"Properties of the Memory Model"},{"type":"clause","id":"AtomicsObject.Properties2","aoid":null,"title":"Properties of Memory Operations","number":"7.4.1.2.1","namespace":"<no location>","location":"","key":"Properties of Memory Operations"},{"type":"clause","id":"AtomicsObject.Implementability","aoid":null,"title":"Implementability of the Semantics","number":"7.4.1.2.2","namespace":"<no location>","location":"","key":"Implementability of the Semantics"},{"type":"clause","id":"AtomicsObject.EventsAndSync","aoid":null,"title":"Events, Synchronization, Data Races, and Sequential Consistency","number":"7.4.1.2.3","namespace":"<no location>","location":"","key":"Events, Synchronization, Data Races, and Sequential Consistency"},{"type":"op","aoid":"ValidateSharedIntegerTypedArray","refId":"Atomics.ValidateSharedIntegerTypedArray","location":"","key":"ValidateSharedIntegerTypedArray"},{"type":"clause","id":"Atomics.ValidateSharedIntegerTypedArray","aoid":"ValidateSharedIntegerTypedArray","title":"ValidateSharedIntegerTypedArray(_typedArray_ [, _onlyInt32_] )","number":"7.4.1.3","namespace":"<no location>","location":"","key":"ValidateSharedIntegerTypedArray(_typedArray_ [, _onlyInt32_] )"},{"type":"op","aoid":"ValidateAtomicAccess","refId":"Atomics.ValidateAtomicAccess","location":"","key":"ValidateAtomicAccess"},{"type":"clause","id":"Atomics.ValidateAtomicAccess","aoid":"ValidateAtomicAccess","title":"ValidateAtomicAccess( _typedArray_, _requestIndex_ )","number":"7.4.1.4","namespace":"<no location>","location":"","key":"ValidateAtomicAccess( _typedArray_, _requestIndex_ )"},{"type":"op","aoid":"AgentSignifier","refId":"Atomics.AgentSignifier","location":"","key":"AgentSignifier"},{"type":"clause","id":"Atomics.AgentSignifier","aoid":"AgentSignifier","title":"AgentSignifier( )","number":"7.4.1.5","namespace":"<no location>","location":"","key":"AgentSignifier( )"},{"type":"op","aoid":"AgentCanSuspend","refId":"Atomics.AgentCanSuspend","location":"","key":"AgentCanSuspend"},{"type":"clause","id":"Atomics.AgentCanSuspend","aoid":"AgentCanSuspend","title":"AgentCanSuspend( )","number":"7.4.1.6","namespace":"<no location>","location":"","key":"AgentCanSuspend( )"},{"type":"op","aoid":"GetWaiterList","refId":"GetWaiterList","location":"","key":"GetWaiterList"},{"type":"clause","id":"GetWaiterList","aoid":"GetWaiterList","title":"GetWaiterList( _block_, _i_ )","number":"7.4.1.7","namespace":"<no location>","location":"","key":"GetWaiterList( _block_, _i_ )"},{"type":"op","aoid":"EnterCriticalSection","refId":"EnterCriticalSection","location":"","key":"EnterCriticalSection"},{"type":"clause","id":"EnterCriticalSection","aoid":"EnterCriticalSection","title":"EnterCriticalSection( _WL_ )","number":"7.4.1.8","namespace":"<no location>","location":"","key":"EnterCriticalSection( _WL_ )"},{"type":"op","aoid":"LeaveCriticalSection","refId":"LeaveCriticalSection","location":"","key":"LeaveCriticalSection"},{"type":"clause","id":"LeaveCriticalSection","aoid":"LeaveCriticalSection","title":"LeaveCriticalSection( _WL_ )","number":"7.4.1.9","namespace":"<no location>","location":"","key":"LeaveCriticalSection( _WL_ )"},{"type":"op","aoid":"AddWaiter","refId":"Atomics.AddWaiter","location":"","key":"AddWaiter"},{"type":"clause","id":"Atomics.AddWaiter","aoid":"AddWaiter","title":"AddWaiter( _WL_, _W_ )","number":"7.4.1.10","namespace":"<no location>","location":"","key":"AddWaiter( _WL_, _W_ )"},{"type":"op","aoid":"RemoveWaiter","refId":"Atomics.RemoveWaiter","location":"","key":"RemoveWaiter"},{"type":"clause","id":"Atomics.RemoveWaiter","aoid":"RemoveWaiter","title":"RemoveWaiter( _WL_, _W_ )","number":"7.4.1.11","namespace":"<no location>","location":"","key":"RemoveWaiter( _WL_, _W_ )"},{"type":"op","aoid":"RemoveWaiters","refId":"Atomics.RemoveWaiters","location":"","key":"RemoveWaiters"},{"type":"clause","id":"Atomics.RemoveWaiters","aoid":"RemoveWaiters","title":"RemoveWaiters( _WL_, _c_ )","number":"7.4.1.12","namespace":"<no location>","location":"","key":"RemoveWaiters( _WL_, _c_ )"},{"type":"op","aoid":"Suspend","refId":"Atomics.Suspend","location":"","key":"Suspend"},{"type":"clause","id":"Atomics.Suspend","aoid":"Suspend","title":"Suspend( _WL_, _W_, _timeout_ )","number":"7.4.1.13","namespace":"<no location>","location":"","key":"Suspend( _WL_, _W_, _timeout_ )"},{"type":"op","aoid":"WakeWaiter","refId":"Atomics.WakeWaiter","location":"","key":"WakeWaiter"},{"type":"clause","id":"Atomics.WakeWaiter","aoid":"WakeWaiter","title":"WakeWaiter( _WL_, _W_ )","number":"7.4.1.14","namespace":"<no location>","location":"","key":"WakeWaiter( _WL_, _W_ )"},{"type":"op","aoid":"AtomicFetchOp","refId":"Atomics.FetchOp","location":"","key":"AtomicFetchOp"},{"type":"clause","id":"Atomics.FetchOp","aoid":"AtomicFetchOp","title":"AtomicFetchOp( _typedArray_, _index_, _value_, _op_ )","number":"7.4.1.15","namespace":"<no location>","location":"","key":"AtomicFetchOp( _typedArray_, _index_, _value_, _op_ )"},{"type":"clause","id":"AtomicsObject.FunctionProps","aoid":null,"title":"Function Properties of the Atomics Object","number":"7.4.2","namespace":"<no location>","location":"","key":"Function Properties of the Atomics Object"},{"type":"clause","id":"Atomics.add","aoid":null,"title":"Atomics.add( _typedArray_, _index_, _value_ )","number":"7.4.2.1","namespace":"<no location>","location":"","key":"Atomics.add( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.and","aoid":null,"title":"Atomics.and( _typedArray_, _index_, _value_ )","number":"7.4.2.2","namespace":"<no location>","location":"","key":"Atomics.and( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.compareExchange","aoid":null,"title":"Atomics.compareExchange( _typedArray_, _index_, _expectedValue_, _replacementValue_ )","number":"7.4.2.3","namespace":"<no location>","location":"","key":"Atomics.compareExchange( _typedArray_, _index_, _expectedValue_, _replacementValue_ )"},{"type":"clause","id":"Atomics.exchange","aoid":null,"title":"Atomics.exchange( _typedArray_, _index_, _value_ )","number":"7.4.2.4","namespace":"<no location>","location":"","key":"Atomics.exchange( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.isLockFree","aoid":null,"title":"Atomics.isLockFree( _size_ )","number":"7.4.2.5","namespace":"<no location>","location":"","key":"Atomics.isLockFree( _size_ )"},{"type":"clause","id":"Atomics.load","aoid":null,"title":"Atomics.load( _typedArray_, _index_ )","number":"7.4.2.6","namespace":"<no location>","location":"","key":"Atomics.load( _typedArray_, _index_ )"},{"type":"clause","id":"Atomics.or","aoid":null,"title":"Atomics.or( _typedArray_, _index_, _value_ )","number":"7.4.2.7","namespace":"<no location>","location":"","key":"Atomics.or( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.store","aoid":null,"title":"Atomics.store( _typedArray_, _index_, _value_ )","number":"7.4.2.8","namespace":"<no location>","location":"","key":"Atomics.store( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.sub","aoid":null,"title":"Atomics.sub( _typedArray_, _index_, _value_ )","number":"7.4.2.9","namespace":"<no location>","location":"","key":"Atomics.sub( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.wait","aoid":null,"title":"Atomics.wait( _typedArray_, _index_, _value_, _timeout_ )","number":"7.4.2.10","namespace":"<no location>","location":"","key":"Atomics.wait( _typedArray_, _index_, _value_, _timeout_ )"},{"type":"clause","id":"Atomics.wake","aoid":null,"title":"Atomics.wake( _typedArray_, _index_, _count_ )","number":"7.4.2.11","namespace":"<no location>","location":"","key":"Atomics.wake( _typedArray_, _index_, _count_ )"},{"type":"clause","id":"Atomics.xor","aoid":null,"title":"Atomics.xor( _typedArray_, _index_, _value_ )","number":"7.4.2.12","namespace":"<no location>","location":"","key":"Atomics.xor( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"WebBrowserEmbedding","aoid":null,"title":"Web browser embedding (informative)","number":"7.5","namespace":"<no location>","location":"","key":"Web browser embedding (informative)"},{"type":"clause","id":"sec-copyright-and-software-license","aoid":null,"title":"Copyright & Software License","number":"A","namespace":"<no location>","location":"","key":"Copyright & Software License"},{"type":"table","id":"table-agent-record","number":1,"caption":"Table 1: Agent Record Fields","namespace":"<no location>","location":"","key":"Table 1: Agent Record Fields"},{"type":"term","term":"Shared Data Block","refId":"DataTypesValues.SpecTypes.DataBlocks","namespace":"<no location>","location":"","key":"Shared Data Block"},{"type":"term","term":"Agent Record","refId":"ExecutableCodeAndContexts.AgentCluster","namespace":"<no location>","location":"","key":"Agent Record"},{"type":"term","term":"%Atomics%","refId":"AtomicsObject","namespace":"<no location>","location":"","key":"%Atomics%"},{"type":"term","term":"WaiterList","refId":"GetWaiterList","namespace":"<no location>","location":"","key":"WaiterList"}]</script></head><body><div id="menu-toggle">☰</div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#intro" title="Introduction"><span class="secnum"></span> Introduction</a></li><li><span class="item-toggle">◢</span><a href="#Overview" title="Overview (ES7 4)"><span class="secnum">1</span> Overview (ES7 4)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#Overview.Overview" title="ECMAScript Overview (ES7 4.2)"><span class="secnum">1.1</span> ECMAScript Overview (ES7 4.2)</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#DataTypesValues" title="ECMAScript Data Types and Values (ES7 6)"><span class="secnum">2</span> ECMAScript Data Types and Values (ES7 6)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#DataTypesValues.LanguageTypes" title="ECMAScript Language Types (ES7 6.1)"><span class="secnum">2.1</span> ECMAScript Language Types (ES7 6.1)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#DataTypesValues.LanguageTypes.Number" title="The Number Type (ES7 6.1.6)"><span class="secnum">2.1.1</span> The Number Type (ES7 6.1.6)</a></li><li><span class="item-toggle">◢</span><a href="#DataTypesValues.LanguageTypes.Object" title="The Object Type (ES7 6.1.7)"><span class="secnum">2.1.2</span> The Object Type (ES7 6.1.7)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#DataTypesValues.LanguageTypes.Object.Intrinsic" title="Well-Known Intrinsic Objects (ES7 6.1.7.4)"><span class="secnum">2.1.2.1</span> Well-Known Intrinsic Objects (ES7 6.1.7.4)</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#DataTypesValues.SpecTypes" title="ECMAScript Specification Types (ES7 6.2)"><span class="secnum">2.2</span> ECMAScript Specification Types (ES7 6.2)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#DataTypesValues.SpecTypes.DataBlocks" title="Data blocks (ES7 6.2.6)"><span class="secnum">2.2.1</span> Data blocks (ES7 6.2.6)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes" title="CopyDataBlockBytes ( _toBlock_, _toIndex_, _fromBlock_, _fromIndex_, _count_ ) (ES7 6.2.6.2)"><span class="secnum">2.2.1.1</span> CopyDataBlockBytes ( <var>toBlock</var>, <var>toIndex</var>, <var>fromBlock</var>, <var>fromIndex</var>, <var>count</var> ) (ES7 6.2.6.2)</a></li><li><span class="item-toggle-none"></span><a href="#DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock" title="CreateSharedByteDataBlock( _size_ )"><span class="secnum">2.2.1.2</span> CreateSharedByteDataBlock( <var>size</var> )</a></li></ol></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#ExecutableCodeAndContexts" title="Executable Code and Execution Contexts (ES7 8)"><span class="secnum">3</span> Executable Code and Execution Contexts (ES7 8)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#ExecutableCodeAndContexts.JobsAndJobQueues" title="Jobs and Job Queues (ES7 8.4)"><span class="secnum">3.1</span> Jobs and Job Queues (ES7 8.4)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.JobsAndJobQueues.Progress" title="Forward Progress Guarantees"><span class="secnum">3.1.1</span> Forward Progress Guarantees</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.AgentCluster" title="Agents (AMENDMENTS)"><span class="secnum">3.2</span> Agents (AMENDMENTS)</a></li><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.AgentCluster" title="Agent Clusters (NEW)"><span class="secnum">3.3</span> Agent Clusters (NEW)</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-ordinary-and-exotic-objects-behaviours" title="Ordinary and Exotic Objects Behaviours (ES7 9)"><span class="secnum">4</span> Ordinary and Exotic Objects Behaviours (ES7 9)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-built-in-exotic-object-internal-methods-and-slots" title="Built-in Exotic Object Internal Methods and Slots (ES7 9.4)"><span class="secnum">4.1</span> Built-in Exotic Object Internal Methods and Slots (ES7 9.4)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-integer-indexed-exotic-objects" title="Integer Indexed Exotic Objects (ES7 9.4.5)"><span class="secnum">4.1.1</span> Integer Indexed Exotic Objects (ES7 9.4.5)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-integerindexedelementget" title="IntegerIndexedElementGet ( _O_, _index_ ) (ES7 9.4.5.8)"><span class="secnum">4.1.1.1</span> IntegerIndexedElementGet ( <var>O</var>, <var>index</var> ) (ES7 9.4.5.8)</a></li><li><span class="item-toggle-none"></span><a href="#sec-integerindexedelementset" title="IntegerIndexedElementSet ( _O_, _index_, _value_ ) (ES7 9.4.5.9)"><span class="secnum">4.1.1.2</span> IntegerIndexedElementSet ( <var>O</var>, <var>index</var>, <var>value</var> ) (ES7 9.4.5.9)</a></li></ol></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#GlobalObject" title="The Global Object (ES7 18)"><span class="secnum">5</span> The Global Object (ES7 18)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#GlobalObject.ConstructorProps" title="Constructor Properties of the Global Object (ES7 18.3)"><span class="secnum">5.1</span> Constructor Properties of the Global Object (ES7 18.3)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#GlobalObject.ConstructorProps.SharedArrayBuffer" title="SharedArrayBuffer"><span class="secnum">5.1.1</span> SharedArrayBuffer</a></li><li><span class="item-toggle-none"></span><a href="#GlobalObject.ConstructorProps.Atomics" title="Atomics"><span class="secnum">5.1.2</span> Atomics</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#IndexedCollections" title="Indexed Collections (ES7 22)"><span class="secnum">6</span> Indexed Collections (ES7 22)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray" title="TypedArray Objects (ES7 22.2)"><span class="secnum">6.1</span> TypedArray Objects (ES7 22.2)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray.prototype" title="Properties of the %TypedArrayPrototype% object (ES7 22.2.3)"><span class="secnum">6.1.1</span> Properties of the %TypedArrayPrototype% object (ES7 22.2.3)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray.prototype.set" title="%TypedArray%.prototype.set( _overloaded_ [ , _offset_ ] ) (ES7 22.2.3.23)"><span class="secnum">6.1.1.1</span> %TypedArray%.prototype.set( <var>overloaded</var> [ , <var>offset</var> ] ) (ES7 22.2.3.23)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#IndexedCollections.TypedArray.prototype.setFromTypedArray" title="%TypedArray%.prototype.set( _array_ [, _offset_ ] ) (ES7 22.2.3.23.1)"><span class="secnum">6.1.1.1.1</span> %TypedArray%.prototype.set( <var>array</var> [, <var>offset</var> ] ) (ES7 22.2.3.23.1)</a></li><li><span class="item-toggle-none"></span><a href="#IndexedCollections.TypedArray.prototype.setFromTypedArray" title="%TypedArray%.prototype.set( _typedArray_ [, _offset_ ] ) (ES7 22.2.3.23.2)"><span class="secnum">6.1.1.1.2</span> %TypedArray%.prototype.set( <var>typedArray</var> [, <var>offset</var> ] ) (ES7 22.2.3.23.2)</a></li><li><span class="item-toggle-none"></span><a href="#IndexedCollections.TypedArray.prototype.slice" title="%TypedArray%.prototype.slice( _start_, _end_ ) (ES7 22.2.3.24)"><span class="secnum">6.1.1.1.3</span> %TypedArray%.prototype.slice( <var>start</var>, <var>end</var> ) (ES7 22.2.3.24)</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray.constructors" title="The %TypedArray% constructors (ES7 22.2.4)"><span class="secnum">6.1.2</span> The %TypedArray% constructors (ES7 22.2.4)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-typedarray-typedarray" title="_TypedArray_ ( _typedArray_ ) (ES7 22.2.4.3)"><span class="secnum">6.1.2.1</span> <var>TypedArray</var> ( <var>typedArray</var> ) (ES7 22.2.4.3)</a></li></ol></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData" title="Structured Data (ES7 24)"><span class="secnum">7</span> Structured Data (ES7 24)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.ArrayBuffer" title="ArrayBuffer Objects (ES7 24.1)"><span class="secnum">7.1</span> ArrayBuffer Objects (ES7 24.1)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.ArrayBuffer.abstract" title="Abstract Operations for ArrayBuffer (ES7 24.1.1)"><span class="secnum">7.1.1</span> Abstract Operations for ArrayBuffer (ES7 24.1.1)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-detacharraybuffer" title="DetachArrayBuffer ( _arrayBuffer_ ) (ES7 24.1.1.3)"><span class="secnum">7.1.1.1</span> DetachArrayBuffer ( <var>arrayBuffer</var> ) (ES7 24.1.1.3)</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" title="GetValueFromBuffer( _arrayBuffer_, _byteIndex_, _type_, _isTypedArray_, _isLittleEndian_ ) (ES7 24.1.1.5)"><span class="secnum">7.1.1.2</span> GetValueFromBuffer( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>isTypedArray</var>, <var>isLittleEndian</var> ) (ES7 24.1.1.5)</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer" title="SetValueInBuffer( _arrayBuffer_, _byteIndex_, _type_, _isTypedArray_, _value_, _isLittleEndian_ ) (ES7 24.1.1.6)"><span class="secnum">7.1.1.3</span> SetValueInBuffer( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>isTypedArray</var>, <var>value</var>, <var>isLittleEndian</var> ) (ES7 24.1.1.6)</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-properties-of-the-arraybuffer-prototype-object" title="Properties of the ArrayBuffer Prototype Object (ES7 24.1.4)"><span class="secnum">7.1.2</span> Properties of the ArrayBuffer Prototype Object (ES7 24.1.4)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-get-arraybuffer.prototype.bytelength" title="get ArrayBuffer.prototype.byteLength (ES7 24.1.4.1)"><span class="secnum">7.1.2.1</span> get ArrayBuffer.prototype.byteLength (ES7 24.1.4.1)</a></li><li><span class="item-toggle-none"></span><a href="#sec-arraybuffer.prototype.slice" title="ArrayBuffer.prototype.slice ( _start_, _end_ ) (ES7 24.1.4.3)"><span class="secnum">7.1.2.2</span> ArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> ) (ES7 24.1.4.3)</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.DataView" title="DataView Objects (ES7 24.2)"><span class="secnum">7.2</span> DataView Objects (ES7 24.2)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-abstract-operations-for-dataview-objects" title="Abstract Operations For DataView Objects (ES7 24.2.1)"><span class="secnum">7.2.1</span> Abstract Operations For DataView Objects (ES7 24.2.1)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-getviewvalue" title="GetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_ ) (ES7 24.2.1.1)"><span class="secnum">7.2.1.1</span> GetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var> ) (ES7 24.2.1.1)</a></li><li><span class="item-toggle-none"></span><a href="#sec-setviewvalue" title="SetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_, _value_ ) (ES7 24.2.1.2)"><span class="secnum">7.2.1.2</span> SetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var>, <var>value</var> ) (ES7 24.2.1.2)</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer" title="SharedArrayBuffer Objects"><span class="secnum">7.3</span> SharedArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.abstract" title="Abstract Operations for SharedArrayBuffer"><span class="secnum">7.3.1</span> Abstract Operations for SharedArrayBuffer</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer" title="AllocateSharedArrayBuffer( _constructor_, _byteLength_ )"><span class="secnum">7.3.1.1</span> AllocateSharedArrayBuffer( <var>constructor</var>, <var>byteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer" title="IsSharedArrayBuffer( _obj_ )"><span class="secnum">7.3.1.2</span> IsSharedArrayBuffer( <var>obj</var> )</a></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.constructor" title="The SharedArrayBuffer Constructor"><span class="secnum">7.3.1.3</span> The SharedArrayBuffer Constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.constructor.withLength" title="SharedArrayBuffer( _length_ )"><span class="secnum">7.3.1.3.1</span> SharedArrayBuffer( <var>length</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.constructor.properties" title="Properties of the SharedArrayBuffer constructor"><span class="secnum">7.3.1.4</span> Properties of the SharedArrayBuffer constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.constructor.properties.prototype" title="SharedArrayBuffer.prototype"><span class="secnum">7.3.1.4.1</span> SharedArrayBuffer.prototype</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.constructor.properties.get_species" title="get SharedArrayBuffer [ @@species ]"><span class="secnum">7.3.1.4.2</span> get SharedArrayBuffer [ @@species ]</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.prototype" title="Properties of the SharedArrayBuffer prototype object"><span class="secnum">7.3.1.5</span> Properties of the SharedArrayBuffer prototype object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.get_byteLength" title="get SharedArrayBuffer.prototype.byteLength"><span class="secnum">7.3.1.5.1</span> get SharedArrayBuffer.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.constructor" title="SharedArrayBuffer.prototype.constructor"><span class="secnum">7.3.1.5.2</span> SharedArrayBuffer.prototype.constructor</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.slice" title="SharedArrayBuffer.prototype.slice( _start_, _end_ )"><span class="secnum">7.3.1.5.3</span> SharedArrayBuffer.prototype.slice( <var>start</var>, <var>end</var> )</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.toString" title="SharedArrayBuffer.prototype[ @@toStringTag ]"><span class="secnum">7.3.1.5.4</span> SharedArrayBuffer.prototype[ @@toStringTag ]</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.instances" title="Properties of the SharedArrayBuffer instances"><span class="secnum">7.3.1.6</span> Properties of the SharedArrayBuffer instances</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#AtomicsObject" title="The Atomics Object"><span class="secnum">7.4</span> The Atomics Object</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#AtomicsObject.FunctionProps.semantics" title="Runtime semantics"><span class="secnum">7.4.1</span> Runtime semantics</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#AtomicsObject.MemoryModel" title="Memory model"><span class="secnum">7.4.1.1</span> Memory model</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#AtomicsObject.Fundamentals" title="Fundamentals"><span class="secnum">7.4.1.1.1</span> Fundamentals</a></li><li><span class="item-toggle-none"></span><a href="#AtomicsObject.Formalization" title="Formalization framework"><span class="secnum">7.4.1.1.2</span> Formalization framework</a></li><li><span class="item-toggle-none"></span><a href="#AtomicsObject.Transformations" title="Program transformations"><span class="secnum">7.4.1.1.3</span> Program transformations</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.ReadSharedMemory" title="ReadSharedMemory(_block_, _byteIndex_, _accessAtomic_, _numBytes_)"><span class="secnum">7.4.1.1.4</span> ReadSharedMemory(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>numBytes</var>)</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.WriteSharedMemory" title="WriteSharedMemory(_block_, _byteIndex_, _accessAtomic_, _numBytes_, _rawBytes_)"><span class="secnum">7.4.1.1.5</span> WriteSharedMemory(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>numBytes</var>, <var>rawBytes</var>)</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.BeginAtomic" title="BeginAtomic(_block_, _byteIndex_, _elementSize_)"><span class="secnum">7.4.1.1.6</span> BeginAtomic(<var>block</var>, <var>byteIndex</var>, <var>elementSize</var>)</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.EndAtomic" title="EndAtomic(_timestamp_)"><span class="secnum">7.4.1.1.7</span> EndAtomic(<var>timestamp</var>)</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.BeginNonAtomic" title="BeginNonAtomic(_op_, _block_, _byteIndex_, _elementSize_)"><span class="secnum">7.4.1.1.8</span> BeginNonAtomic(<var>op</var>, <var>block</var>, <var>byteIndex</var>, <var>elementSize</var>)</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.EndNonAtomic" title="EndNonAtomic(_timestamp_)"><span class="secnum">7.4.1.1.9</span> EndNonAtomic(<var>timestamp</var>)</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.NonAtomicRead" title="NonAtomicRead(_block_, _byteIndex_, _accessAtomic_, _elementSize_)"><span class="secnum">7.4.1.1.10</span> NonAtomicRead(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>elementSize</var>)</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.NonAtomicWrite" title="NonAtomicWrite(_block_, _byteIndex_, _accessAtomic_, _elementSize_, _rawBytes_)"><span class="secnum">7.4.1.1.11</span> NonAtomicWrite(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>elementSize</var>, <var>rawBytes</var>)</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AtomicRead" title="AtomicRead(_buffer_, _byteIndex_, _type_)"><span class="secnum">7.4.1.1.12</span> AtomicRead(<var>buffer</var>, <var>byteIndex</var>, <var>type</var>)</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AtomicWrite" title="AtomicWrite(_buffer_, _byteIndex_, _type_, _v_)"><span class="secnum">7.4.1.1.13</span> AtomicWrite(<var>buffer</var>, <var>byteIndex</var>, <var>type</var>, <var>v</var>)</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AtomicReadModifyWrite" title="AtomicReadModifyWrite(_buffer_, _byteIndex_, _type_, _op_, _v_)"><span class="secnum">7.4.1.1.14</span> AtomicReadModifyWrite(<var>buffer</var>, <var>byteIndex</var>, <var>type</var>, <var>op</var>, <var>v</var>)</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AtomicCompareExchange" title="AtomicCompareExchange(_buffer_, _byteIndex_, _type_, _expected_, _replacement_)"><span class="secnum">7.4.1.1.15</span> AtomicCompareExchange(<var>buffer</var>, <var>byteIndex</var>, <var>type</var>, <var>expected</var>, <var>replacement</var>)</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#AtomicsObject.PropertiesOfMemModel" title="Properties of the Memory Model"><span class="secnum">7.4.1.2</span> Properties of the Memory Model</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#AtomicsObject.Properties2" title="Properties of Memory Operations"><span class="secnum">7.4.1.2.1</span> Properties of Memory Operations</a></li><li><span class="item-toggle-none"></span><a href="#AtomicsObject.Implementability" title="Implementability of the Semantics"><span class="secnum">7.4.1.2.2</span> Implementability of the Semantics</a></li><li><span class="item-toggle-none"></span><a href="#AtomicsObject.EventsAndSync" title="Events, Synchronization, Data Races, and Sequential Consistency"><span class="secnum">7.4.1.2.3</span> Events, Synchronization, Data Races, and Sequential Consistency</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#Atomics.ValidateSharedIntegerTypedArray" title="ValidateSharedIntegerTypedArray(_typedArray_ [, _onlyInt32_] )"><span class="secnum">7.4.1.3</span> ValidateSharedIntegerTypedArray(<var>typedArray</var> [, <var>onlyInt32</var>] )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.ValidateAtomicAccess" title="ValidateAtomicAccess( _typedArray_, _requestIndex_ )"><span class="secnum">7.4.1.4</span> ValidateAtomicAccess( <var>typedArray</var>, <var>requestIndex</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AgentSignifier" title="AgentSignifier( )"><span class="secnum">7.4.1.5</span> AgentSignifier( )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AgentCanSuspend" title="AgentCanSuspend( )"><span class="secnum">7.4.1.6</span> AgentCanSuspend( )</a></li><li><span class="item-toggle-none"></span><a href="#GetWaiterList" title="GetWaiterList( _block_, _i_ )"><span class="secnum">7.4.1.7</span> GetWaiterList( <var>block</var>, <var>i</var> )</a></li><li><span class="item-toggle-none"></span><a href="#EnterCriticalSection" title="EnterCriticalSection( _WL_ )"><span class="secnum">7.4.1.8</span> EnterCriticalSection( <var>WL</var> )</a></li><li><span class="item-toggle-none"></span><a href="#LeaveCriticalSection" title="LeaveCriticalSection( _WL_ )"><span class="secnum">7.4.1.9</span> LeaveCriticalSection( <var>WL</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AddWaiter" title="AddWaiter( _WL_, _W_ )"><span class="secnum">7.4.1.10</span> AddWaiter( <var>WL</var>, <var>W</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.RemoveWaiter" title="RemoveWaiter( _WL_, _W_ )"><span class="secnum">7.4.1.11</span> RemoveWaiter( <var>WL</var>, <var>W</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.RemoveWaiters" title="RemoveWaiters( _WL_, _c_ )"><span class="secnum">7.4.1.12</span> RemoveWaiters( <var>WL</var>, <var>c</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.Suspend" title="Suspend( _WL_, _W_, _timeout_ )"><span class="secnum">7.4.1.13</span> Suspend( <var>WL</var>, <var>W</var>, <var>timeout</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.WakeWaiter" title="WakeWaiter( _WL_, _W_ )"><span class="secnum">7.4.1.14</span> WakeWaiter( <var>WL</var>, <var>W</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.FetchOp" title="AtomicFetchOp( _typedArray_, _index_, _value_, _op_ )"><span class="secnum">7.4.1.15</span> AtomicFetchOp( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>op</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#AtomicsObject.FunctionProps" title="Function Properties of the Atomics Object"><span class="secnum">7.4.2</span> Function Properties of the Atomics Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#Atomics.add" title="Atomics.add( _typedArray_, _index_, _value_ )"><span class="secnum">7.4.2.1</span> Atomics.add( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.and" title="Atomics.and( _typedArray_, _index_, _value_ )"><span class="secnum">7.4.2.2</span> Atomics.and( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.compareExchange" title="Atomics.compareExchange( _typedArray_, _index_, _expectedValue_, _replacementValue_ )"><span class="secnum">7.4.2.3</span> Atomics.compareExchange( <var>typedArray</var>, <var>index</var>, <var>expectedValue</var>, <var>replacementValue</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.exchange" title="Atomics.exchange( _typedArray_, _index_, _value_ )"><span class="secnum">7.4.2.4</span> Atomics.exchange( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.isLockFree" title="Atomics.isLockFree( _size_ )"><span class="secnum">7.4.2.5</span> Atomics.isLockFree( <var>size</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.load" title="Atomics.load( _typedArray_, _index_ )"><span class="secnum">7.4.2.6</span> Atomics.load( <var>typedArray</var>, <var>index</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.or" title="Atomics.or( _typedArray_, _index_, _value_ )"><span class="secnum">7.4.2.7</span> Atomics.or( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.store" title="Atomics.store( _typedArray_, _index_, _value_ )"><span class="secnum">7.4.2.8</span> Atomics.store( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.sub" title="Atomics.sub( _typedArray_, _index_, _value_ )"><span class="secnum">7.4.2.9</span> Atomics.sub( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.wait" title="Atomics.wait( _typedArray_, _index_, _value_, _timeout_ )"><span class="secnum">7.4.2.10</span> Atomics.wait( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.wake" title="Atomics.wake( _typedArray_, _index_, _count_ )"><span class="secnum">7.4.2.11</span> Atomics.wake( <var>typedArray</var>, <var>index</var>, <var>count</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.xor" title="Atomics.xor( _typedArray_, _index_, _value_ )"><span class="secnum">7.4.2.12</span> Atomics.xor( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li></ol></li></ol></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding" title="Web browser embedding (informative)"><span class="secnum">7.5</span> Web browser embedding (informative)</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#sec-copyright-and-software-license" title="Copyright &amp; Software License"><span class="secnum">A</span> Copyright &amp; Software License</a></li></ol></div></div><h1 class="version">Stage 2 Draft / September 5, 2016</h1><h1 class="title">ECMAScript Shared Memory and Atomics</h1>
<script src="https://bterlson.github.io/ecmarkup/ecmarkup.js"></script>
<link rel="stylesheet" href="https://bterlson.github.io/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">

<p>Some algorithms and semantics in this proposal are presented as modifications to existing ES262 algorithms and semantics.  The base revision of ES262 for the modifications (here denoted "ES7") is currently f35248729043089b47ccf29e4c47559386f5f6fd (2016-06-29).  At the moment, ES7 (ES2016) section numbering differs from ES6 (ES2015) only for TypedArrays (section 22.2).</p>

<emu-intro id="intro">
<h1><span class="secnum"></span>Introduction<span class="utils"><span class="anchor"><a href="#intro">#</a></span></span></h1>

<p>This proposal adds a simple form of shared memory to ECMAScript.
Shared memory is being exposed in the form of a new SharedArrayBuffer
type; the existing TypedArray and DataView types are adapted in such a way
that they can be used to create views on shared memory.  The new
global Atomics object provides atomic operations on shared memory
locations, including operations that can be used to create blocking
synchronization primitives.  Though not a part of this specification,
we intend for the role of "threads" to be played by Web Workers in web
browser environments.</p><p>

</p><p>At this time the proposal adds only low-level primitives to
ECMAScript; we expect the developer community to put together
abstractions that are useful in specific domains.</p>

<p>The work has been driven by the following use cases:  </p><p>

</p><ul>
  <li>Support for threaded code in programs written in other
  languages that are translated to asm.js or plain JS or a combination
  of the two, notably C and C++ but also other, safe, languages. 

  </li><li>Support for hand-written JS or JS+asm.js that makes use of
  multiprocessing facilities for select tasks, such as image
  processing, asset management, or game AI.

</li></ul>

<p>The proposal makes only very basic assumptions about the required
hardware and should be broadly implementable with good performance.
Prototype implementations of the API are available in Firefox and in
Google Chrome.</p>

<p>This specification constitutes a restatement and formalization of
an earlier
work,  <a href="https://github.com/tc39/ecmascript_sharedmem/blob/master/historical/Spec_JavaScriptSharedMemoryAtomicsandLocks.pdf">the
spec document for which</a> also contains additional rationale,
background information, discussions, implementation notes, and
comments.</p>

<p>Changelog:</p>
<ul>
  <li>2016-07-22 -- Editorial fixes.
  
  </li><li>2016-07-21 -- Replace [[SharedArrayBufferData]] and [[SharedArrayBufferByteLength]] with [[ArrayBufferData]] and [[ArrayBufferByteLength]]; remove specialization that was based on the removed properties and instead use type checks with <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref> in ArrayBuffer, SharedArrayBuffer, and Atomics methods; spec that Shared Data Blocks are distinguishable (by unspecified means) from regular Data Blocks and use this to defined <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>.
  
  </li><li>2016-07-20 -- Editorial fix: clarify the operator passed to <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>.
  
  </li><li>2016-07-13 -- Editorial fixes.
  
  </li><li>2016-07-11 -- Rewrote the memory model section, which introduced separate access functions for shared memory, and caused many other changes.
  
  </li><li>2016-07-05 -- Rewrote (and shrunk) the informative Web Browser Embedding section so that it only addresses the requirements of this spec, not how HTML ought to evolve.
  
  </li><li>2016-07-05 -- Rephrased the wait/wake mutual exclusion in terms of critical sections named by (G,i), as the old specification was too strong.
  
  </li><li>2016-06-30 -- Algorithms that are modified relative to their ES262 forms include more context and are more clearly marked, and there's a defined ES262 base revision for those modifications.  Updated section references to reference that revision.
  
  </li><li>(Older changelog removed)

</li></ul>

</emu-intro>

<emu-clause id="Overview">
  <h1><span class="secnum">1</span>Overview (<a href="https://tc39.github.io/ecma262/#sec-overview">ES7 4</a>)<span class="utils"><span class="anchor"><a href="#Overview">#</a></span></span></h1>
  <emu-clause id="Overview.Overview">
    <h1><span class="secnum">1.1</span>ECMAScript Overview (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-overview">ES7 4.2</a>)<span class="utils"><span class="anchor"><a href="#Overview.Overview">#</a></span></span></h1>
    <p>In the third paragraph, include  <b>SharedArrayBuffer</b> after  <b>ArrayBuffer</b>.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="DataTypesValues">
  <h1><span class="secnum">2</span>ECMAScript Data Types and Values (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">ES7 6</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues">#</a></span></span></h1>

  <emu-clause id="DataTypesValues.LanguageTypes">
    <h1><span class="secnum">2.1</span>ECMAScript Language Types (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-language-types">ES7 6.1</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes">#</a></span></span></h1>
    <emu-clause id="DataTypesValues.LanguageTypes.Number">
      <h1><span class="secnum">2.1.1</span>The Number Type (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-language-types-number-type">ES7 6.1.6</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes.Number">#</a></span></span></h1>
      <p>In the NOTE, include  <b>SharedArrayBuffer</b> along with  <b>ArrayBuffer</b>.</p>
    </emu-clause>
    <emu-clause id="DataTypesValues.LanguageTypes.Object">
      <h1><span class="secnum">2.1.2</span>The Object Type (<a href="https://tc39.github.io/ecma262/#sec-object-type">ES7 6.1.7</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes.Object">#</a></span></span></h1>
      <emu-clause id="DataTypesValues.LanguageTypes.Object.Intrinsic">
        <h1><span class="secnum">2.1.2.1</span>Well-Known Intrinsic Objects (<a href="https://tc39.github.io/ecma262/#sec-well-known-intrinsic-objects">ES7 6.1.7.4</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes.Object.Intrinsic">#</a></span></span></h1>
        <p>In table 7, include rows for <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">%Atomics%</a></emu-xref>, %SharedArrayBuffer%, and %SharedArrayBufferPrototype% in the manner of the row for ArrayBuffer.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="DataTypesValues.SpecTypes">
    <h1><span class="secnum">2.2</span>ECMAScript Specification Types (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-specification-types">ES7 6.2</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes">#</a></span></span></h1>
    <emu-clause id="DataTypesValues.SpecTypes.DataBlocks">
      <h1><span class="secnum">2.2.1</span>Data blocks (<a href="https://tc39.github.io/ecma262/#sec-data-blocks">ES7 6.2.6</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks">#</a></span></span></h1>
      <p>Insert the following paragraph after the third:</p>

      <p>A data block that resides in memory that can be referenced from multiple agents concurrently is designated a  <dfn>Shared Data Block</dfn>.  A Shared Data Block has an identity (for the purposes of equality testing Shared Data Block values) that is  <em>address-free</em>: it is tied not to the virtual addresses the block is mapped to in any process, but to the set of locations in memory that the block represents.  Shared Data Blocks can also be distinguished from Data Blocks.</p>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes" aoid="CopyDataBlockBytes">
        <h1><span class="secnum">2.2.1.1</span>CopyDataBlockBytes ( <var>toBlock</var>, <var>toIndex</var>, <var>fromBlock</var>, <var>fromIndex</var>, <var>count</var> ) (<a href="https://tc39.github.io/ecma262/#sec-copydatablockbytes">ES7 6.2.6.2</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p>When the abstract operation CopyDataBlockBytes is called, the following steps are taken:</p>
        <emu-alg><ol><li>Assert: <var>fromBlock</var> and <var>toBlock</var> are distinct <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> <ins>or <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref></ins> values.</li><li>Assert: <var>fromIndex</var>, <var>toIndex</var>, and <var>count</var> are integer values ≥ 0.</li><li>Let <var>fromSize</var> be the number of bytes in <var>fromBlock</var>.</li><li>Assert: <var>fromIndex</var>+<var>count</var> ≤ <var>fromSize</var>.</li><li>Let <var>toSize</var> be the number of bytes in <var>toBlock</var>.</li><li>Assert: <var>toIndex</var>+<var>count</var> ≤ <var>toSize</var>.</li><li>Repeat, while <var>count</var>&gt;0<ol><li><del>Set <var>toBlock</var>[<var>toIndex</var>] to the value of <var>fromBlock</var>[<var>fromIndex</var>].</del><br><ins>If <var>fromBlock</var> is a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref>  then let <var>byte</var> be <emu-xref aoid="NonAtomicRead"><a href="#Atomics.NonAtomicRead">NonAtomicRead</a></emu-xref>(<var>fromBlock</var>, <var>fromIndex</var>, <emu-val>false</emu-val>, <emu-val>1</emu-val>), otherwise let <var>byte</var> be <var>fromBlock</var>[<var>fromIndex</var>].</ins></li><li><ins>If <var>toBlock</var> is a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> then perform <emu-xref aoid="NonAtomicWrite"><a href="#Atomics.NonAtomicWrite">NonAtomicWrite</a></emu-xref>(<var>toBlock</var>, <var>toIndex</var>, <emu-val>false</emu-val>, <emu-val>1</emu-val>, <var>byte</var>), otherwise set <var>toBlock</var>[<var>toIndex</var>] to <var>byte</var>.</ins></li><li>Increment <var>toIndex</var> and <var>fromIndex</var> each by 1.</li><li>Decrement <var>count</var> by 1.</li></ol></li><li>Return <emu-xref aoid="NormalCompletion"><a href="https://tc39.github.io/ecma262/#sec-normalcompletion">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock" aoid="CreateSharedByteDataBlock">
        <h1><span class="secnum">2.2.1.2</span>CreateSharedByteDataBlock( <var>size</var> )<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock">#</a></span></span></h1>
        <p>When the abstract operation CreateSharedByteDataBlock is called with integer argument size, the following steps are taken:</p>
        <emu-alg><ol><li>Assert: <var>size</var> &gt;= 0.</li><li>Let <var>db</var> be a new <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> value consisting of <var>size</var> bytes. If it is impossible to create such a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Set all of the bytes of <var>db</var> to 0 as if by calls to <emu-xref aoid="NonAtomicWrite"><a href="#Atomics.NonAtomicWrite">NonAtomicWrite</a></emu-xref>(<var>db</var>, <var>i</var>, <emu-val>false</emu-val>, <emu-val>1</emu-val>, <emu-val>0</emu-val>) for each index <var>i</var> in <var>db</var>.</li><li>Return <var>db</var>.
        </li></ol></emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="ExecutableCodeAndContexts">
  <h1><span class="secnum">3</span>Executable Code and Execution Contexts (<a href="https://tc39.github.io/ecma262/#sec-executable-code-and-execution-contexts">ES7 8</a>)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts">#</a></span></span></h1>
  <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues">

    <h1><span class="secnum">3.1</span>Jobs and Job Queues (<a href="https://tc39.github.io/ecma262/#sec-jobs-and-job-queues">ES7 8.4</a>)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.JobsAndJobQueues">#</a></span></span></h1>
    <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues.Progress">
      <h1><span class="secnum">3.1.1</span>Forward Progress Guarantees<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.JobsAndJobQueues.Progress">#</a></span></span></h1>
      <p>The forward progress guarantee is provided by  <a href="https://github.com/tc39/ecma262/pull/522">PR 522 on ES262</a>.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="ExecutableCodeAndContexts.AgentCluster">
    <h1><span class="secnum">3.2</span>Agents (AMENDMENTS)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.AgentCluster">#</a></span></span></h1>

    <p>Add the following properties to the  <dfn>Agent Record</dfn> (which is provided by  <a href="https://github.com/tc39/ecma262/pull/522">PR 522 on ES262</a>):</p>

    <emu-table id="table-agent-record" caption="Agent Record Fields"><figure><figcaption>Table 1: Agent Record Fields</figcaption>
      <table>
        <tbody>
          <tr>
            <th>Field name</th>
            <th>Value</th>
            <th>Meaning</th>
         </tr>
          <tr>
            <td>[[Signifier]]</td>
            <td>A value that admits equality testing</td>
            <td>Uniquely identifies the agent within its agent cluster.</td>
         </tr>
          <tr>
            <td>[[IsLockFree1]]</td>
            <td>Boolean</td>
            <td>True if and only if atomic operations on one-byte values are lock-free.</td>
         </tr>
          <tr>
            <td>[[IsLockFree2]]</td>
            <td>Boolean</td>
            <td>True if and only if atomic operations on two-byte values are lock-free.</td>
         </tr>
       </tbody>
     </table>
    </figure></emu-table>

    <p>Once the values of [[Signifier]], [[IsLockFree1]], and
    [[IsLockFree2]] have been observed by any agent in the agent
    cluster they cannot change.</p>

    <emu-note><span class="note">Note</span>
      <p>The values of [[IsLockFree1]] and [[IsLockFree2]] are not
        necessarily determined by the hardware, but may also reflect
        implementation choices that can vary over time and between
        ECMAScript implementations.</p>

      <p>There is no [[IsLockFree4]] property: 4-byte atomic
        operations are always lock-free.</p>

      <p>Atomic operations are lock-free if some atomic operation in the agent cluster can always make progress.  For example, an agent that performs a lock-free atomic add of need only ever wait for the CPU to perform the memory access.  In contrast, with a non-lock-free atomic, an agent that holds a lock will force all other agents to wait for the lock to be released; if the agent holding the lock is suspended by the operating system, no other agents can make progress until it is resumed.</p>

      <p>Lock-free does not imply wait-free: there is no upper bound on how many machine steps may be required to complete a lock-free atomic operation.  For example, if a lock-free atomic add is implemented with separate load and store instructions then the operation may need to be retried if some other agent updates the memory between the load and the store, and there is no bound on how many retries may be needed.</p>

      <p>That an atomic access of size  <em>n</em> is lock-free does
        not imply anything about the (perceived) atomicity of
        non-atomic accesses of size  <em>n</em>, specifically,
        non-atomic accesses may still be performed as a sequence of
        several separate memory accesses.  See the memory model
        section for details.</p>
    </emu-note>

  </emu-clause>

  <emu-clause id="ExecutableCodeAndContexts.AgentCluster">
    <h1><span class="secnum">3.3</span>Agent Clusters (NEW)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.AgentCluster">#</a></span></span></h1>

    <p>An  <em>agent cluster</em> is a maximal set of agents that can
      communicate by operating on shared memory.</p>

    <emu-note><span class="note">Note 1</span>
      <p>Programs within different agents may share memory by
        unspecified means.  At a minimum, the backing memory for
        SharedArrayBuffer objects can be shared among the agents in
        the cluster.</p>

      <p>There may be agents that can communicate by message passing
	that cannot share memory; they are never in the same
	cluster.</p>
    </emu-note>

    <p>Every agent belongs to exactly one agent cluster.</p>

    <emu-note><span class="note">Note 2</span>
      <p>The agents in a cluster need not all be alive at some
	particular point in time.  If agent  <b>A</b> creates another
	agent  <b>B</b>, after which  <b>A</b> terminates and  <b>B</b>
	creates agent  <b>C</b>, the three agents are in the same
	cluster if  <b>A</b> could share some memory with  <b>B</b>
	and  <b>B</b> could share some memory with  <b>C</b>.</p>
    </emu-note>

    <p>All agents within a cluster must have the same value for
      the [[LittleEndian]] property in their respective Agent Records.</p>

    <emu-note><span class="note">Note 3</span>
      <p>If different agents within an agent cluster have different
        values of [[LittleEndian]] it becomes hard to use shared
        memory for multi-byte data.</p>
    </emu-note>

    <p>All agents within a cluster must have the same values for
      the [[IsLockFree1]] property in their respective Agent Records; similarly for
      the [[IsLockFree2]] property.</p>

    <p>All agents within a cluster must have different values for
      the [[Signifier]] property in their respective Agent Records.</p>

    <p>An agent cluster is a specification mechanism and need not correspond to
      any particular artefact of an ECMAScript implementation.</p>

    <p>An embedding may deactivate (stop forward progress) or
      activate (resume forward progress) an agent without the agent's
      knowledge or cooperation.  If the embedding does so, it must not
      leave some agents in the cluster active while other agents in
      the cluster are deactivated indefinitely.</p>

    <emu-note><span class="note">Note 4</span>
      <p>The purpose of the preceding restriction is to avoid a
        situation where an agent deadlocks or starves because another
        agent has been suspended.  For example, if a DOM SharedWorker
        shares memory with a regular worker, and the regular worker is
        suspended while it holds a lock (because the web page the
        regular worker is in is pushed into the window history), and
        the SharedWorker tries to acquire the lock, then the
        SharedWorker will be blocked until the regular worker wakes up
        again, if ever.  Meanwhile other workers trying to access the
        SharedWorker from other web pages will starve.</p>

      <p>The implication of the restriction is that it will not be
        possible to share memory between agents that don't belong to
        the same suspend/wake collective within the embedding.</p>
    </emu-note>

    <p>An embedding may terminate an agent without any of the agent's
      cluster's other agents' prior knowledge or cooperation.  If an
      agent is terminated not by programmatic action of its own or of
      another agent in the cluster but by forces external to the
      cluster, then the embedding must choose one of two strategies:
      Either terminate all the agents in the cluster, or provide
      reliable APIs that allow the agents in the cluster to coordinate
      so that at least one remaining member of the cluster will be
      able to detect the termination, with the termination data
      containing enough information to identify the agent that was
      terminated.</p>

    <emu-note><span class="note">Note 5</span>
      <p>Examples of that type of termination are: operating systems
        or users terminating agents that are running in separate
        processes; the embedding itself terminating an agent that is
        running in-process with the other agents when per-agent
        resource accounting indicates that the agent is runaway.</p>
    </emu-note>

    <emu-note><span class="note">Note 6</span>
      <p>This proposal additionally suggests (see later text) that if
        termination is signaled then the signal creates a
        synchronizes-with edge in the memory ordering.</p>
    </emu-note>

  </emu-clause> <!-- agent cluster -->

</emu-clause>

<!-- es6num="9" -->
<emu-clause id="sec-ordinary-and-exotic-objects-behaviours">
  <h1><span class="secnum">4</span>Ordinary and Exotic Objects Behaviours (<a href="https://tc39.github.io/ecma262/#sec-ordinary-and-exotic-objects-behaviours">ES7 9</a>)<span class="utils"><span class="anchor"><a href="#sec-ordinary-and-exotic-objects-behaviours">#</a></span></span></h1>

  <!-- es6num="9.4" -->
  <emu-clause id="sec-built-in-exotic-object-internal-methods-and-slots">
    <h1><span class="secnum">4.1</span>Built-in Exotic Object Internal Methods and Slots (<a href="https://tc39.github.io/ecma262/#sec-built-in-exotic-object-internal-methods-and-slots">ES7 9.4</a>)<span class="utils"><span class="anchor"><a href="#sec-built-in-exotic-object-internal-methods-and-slots">#</a></span></span></h1>

    <!-- es6num="9.4.5" -->
    <emu-clause id="sec-integer-indexed-exotic-objects">
      <h1><span class="secnum">4.1.1</span>Integer Indexed Exotic Objects (<a href="https://tc39.github.io/ecma262/#sec-integer-indexed-exotic-objects">ES7 9.4.5</a>)<span class="utils"><span class="anchor"><a href="#sec-integer-indexed-exotic-objects">#</a></span></span></h1>

      <!-- es6num="9.4.5.8" -->
      <emu-clause id="sec-integerindexedelementget" aoid="IntegerIndexedElementGet">
        <h1><span class="secnum">4.1.1.1</span>IntegerIndexedElementGet ( <var>O</var>, <var>index</var> ) (<a href="https://tc39.github.io/ecma262/#sec-integerindexedelementget">ES7 9.4.5.8</a>)<span class="utils"><span class="anchor"><a href="#sec-integerindexedelementget">#</a></span></span></h1>

        <p>This algorithm is modified as follows:</p>

        <p>In the call to <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>, pass <emu-val>true</emu-val> as the fourth argument to indicate that the operation is performed on a TypedArray.</p>
      </emu-clause>

      <!-- es6num="9.4.5.9" -->
      <emu-clause id="sec-integerindexedelementset" aoid="IntegerIndexedElementSet">
        <h1><span class="secnum">4.1.1.2</span>IntegerIndexedElementSet ( <var>O</var>, <var>index</var>, <var>value</var> ) (<a href="https://tc39.github.io/ecma262/#sec-integerindexedelementset">ES7 9.4.5.9</a>)<span class="utils"><span class="anchor"><a href="#sec-integerindexedelementset">#</a></span></span></h1>

        <p>This algorithm is modified as follows:</p>

        <p>In the call to <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>, pass <emu-val>true</emu-val> as the fourth argument to indicate that the operation is performed on a TypedArray.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="GlobalObject">
  <h1><span class="secnum">5</span>The Global Object (<a href="https://tc39.github.io/ecma262/#sec-global-object">ES7 18</a>)<span class="utils"><span class="anchor"><a href="#GlobalObject">#</a></span></span></h1>
  <emu-clause id="GlobalObject.ConstructorProps">
    <h1><span class="secnum">5.1</span>Constructor Properties of the Global Object (<a href="https://tc39.github.io/ecma262/#sec-constructor-properties-of-the-global-object">ES7 18.3</a>)<span class="utils"><span class="anchor"><a href="#GlobalObject.ConstructorProps">#</a></span></span></h1>
    <emu-clause id="GlobalObject.ConstructorProps.SharedArrayBuffer">
      <h1><span class="secnum">5.1.1</span>SharedArrayBuffer<span class="utils"><span class="anchor"><a href="#GlobalObject.ConstructorProps.SharedArrayBuffer">#</a></span></span></h1>
      <p>Add a new subsection for SharedArrayBuffer, pointing to the appropriate new section (below).</p>
    </emu-clause>
    <emu-clause id="GlobalObject.ConstructorProps.Atomics">
      <h1><span class="secnum">5.1.2</span>Atomics<span class="utils"><span class="anchor"><a href="#GlobalObject.ConstructorProps.Atomics">#</a></span></span></h1>
      <p>Add a new subsection for Atomics, pointing to the appropriate new section (below).</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<!--
AllocateTypedArray only allocates an ArrayBuffer if length is specified.
These call AllocateTypedArray with a specified length:
  TypedArrayFrom (twice)
   called from:
     %TypedArray% ( object )
     %TypedArray%.from ( source [,mapFn [,thisArg]] )
  %TypedArray%.of ( ...items )
  %TypedArray%.prototype.filter ( callbackFn [, thisArg] )
  %TypedArray%.prototype.slice ( start, end )
  %TypedArray% ()
  %TypedArray% (length)
  -->

<emu-clause id="IndexedCollections">
  <h1><span class="secnum">6</span>Indexed Collections (<a href="https://tc39.github.io/ecma262/#sec-indexed-collections">ES7 22</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections">#</a></span></span></h1>
  <emu-clause id="IndexedCollections.TypedArray">
    <h1><span class="secnum">6.1</span>TypedArray Objects (<a href="https://tc39.github.io/ecma262/#sec-typedarray-objects">ES7 22.2</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray">#</a></span></span></h1>

    <emu-clause id="IndexedCollections.TypedArray.prototype">
      <h1><span class="secnum">6.1.1</span>Properties of the %TypedArrayPrototype% object (<a href="https://tc39.github.io/ecma262/#sec-properties-of-the-%typedarrayprototype%-object">ES7 22.2.3</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype">#</a></span></span></h1>
      <emu-clause id="IndexedCollections.TypedArray.prototype.set">
        <h1><span class="secnum">6.1.1.1</span>%TypedArray%.prototype.set( <var>overloaded</var> [ , <var>offset</var> ] ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-overloaded-offset">ES7 22.2.3.23</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype.set">#</a></span></span></h1>

        <emu-clause id="IndexedCollections.TypedArray.prototype.setFromTypedArray">
          <h1><span class="secnum">6.1.1.1.1</span>%TypedArray%.prototype.set( <var>array</var> [, <var>offset</var> ] ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-array-offset">ES7 22.2.3.23.1</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype.setFromTypedArray">#</a></span></span></h1>
          <p>This algorithm is modified as follows:</p>

          <p>In the call to <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>, pass <emu-val>true</emu-val> as the fourth argument to indicate that the operation is performed on a TypedArray.</p>
        </emu-clause>

        <emu-clause id="IndexedCollections.TypedArray.prototype.setFromTypedArray">
          <h1><span class="secnum">6.1.1.1.2</span>%TypedArray%.prototype.set( <var>typedArray</var> [, <var>offset</var> ] ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-typedarray-offset">ES7 22.2.3.23.2</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype.setFromTypedArray">#</a></span></span></h1>
          <p>This algorithm is modified as follows:</p>
          <p>Sets multiple values in this <var>TypedArray</var>, reading the values from the <var>typedArray</var> argument object. The optional <var>offset</var> value indicates the first element index in this <var>TypedArray</var> where values are written. If omitted, it is assumed to be 0.</p>
          <emu-alg><ol><li>Assert: <var>typedArray</var> has a [[TypedArrayName]] internal slot. If it does not, the definition in <emu-xref href="#sec-%typedarray%.prototype.set-array-offset"><a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-array-offset">22.2.3.23.1</a></emu-xref> applies.</li><li>Let <var>target</var> be the <emu-val>this</emu-val> value.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>target</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>target</var> does not have a [[TypedArrayName]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>Assert: <var>target</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>targetOffset</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>offset</var>).</li><li>If <var>targetOffset</var> &lt; 0, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>targetBuffer</var> be <var>target</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.github.io/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>targetBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>targetLength</var> be <var>target</var>.[[ArrayLength]].</li><li>Let <var>srcBuffer</var> be <var>typedArray</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.github.io/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>srcBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>targetName</var> be the String value of <var>target</var>.[[TypedArrayName]].</li><li>Let <var>targetType</var> be the String value of the Element Type value in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>targetName</var>.</li><li>Let <var>targetElementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>targetName</var>.</li><li>Let <var>targetByteOffset</var> be <var>target</var>.[[ByteOffset]].</li><li>Let <var>srcName</var> be the String value of <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>srcType</var> be the String value of the Element Type value in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcElementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcLength</var> be <var>typedArray</var>.[[ArrayLength]].</li><li>Let <var>srcByteOffset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>If <var>srcLength</var> + <var>targetOffset</var> &gt; <var>targetLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li><ins>If both <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>srcBuffer</var>) and <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>targetBuffer</var>) are <emu-val>true</emu-val>, then let <var>same</var> be <emu-val>true</emu-val> if <var>srcBuffer</var>.[[ArrayBufferData]] equals <var>targetBuffer</var>.[[ArrayBufferData]]; otherwise let <var>same</var> be <emu-xref aoid="SameValue"><a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>srcBuffer</var>, <var>targetBuffer</var>).</ins></li><li><del>If <emu-xref aoid="SameValue"><a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>srcBuffer</var>, <var>targetBuffer</var>)</del> <ins><var>same</var></ins> is <emu-val>true</emu-val>, then<ol><li>Let <var>srcBuffer</var> be ? <emu-xref aoid="CloneArrayBuffer"><a href="https://tc39.github.io/ecma262/#sec-clonearraybuffer">CloneArrayBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteOffset</var>, <var>srcLength</var>, <emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.github.io/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>).</li><li>NOTE: <emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.github.io/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref> is used to clone <var>srcBuffer</var> because is it known to not have any observable side-effects.</li><li>Let <var>srcByteIndex</var> be 0.</li></ol></li><li>Else, let <var>srcByteIndex</var> be <var>srcByteOffset</var>.</li><li>Let <var>targetByteIndex</var> be <var>targetOffset</var> × <var>targetElementSize</var> + <var>targetByteOffset</var>.</li><li>Let <var>limit</var> be <var>targetByteIndex</var> + <var>targetElementSize</var> × <var>srcLength</var>.</li><li>If <emu-xref aoid="SameValue"><a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>srcType</var>, <var>targetType</var>) is <emu-val>true</emu-val>, then<ol><li>NOTE: If <var>srcType</var> and <var>targetType</var> are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.</li><li>Repeat, while <var>targetByteIndex</var> &lt; <var>limit</var><ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteIndex</var>, <code>"Uint8"</code>, <ins><emu-val>true</emu-val></ins>).</li><li>Perform <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>(<var>targetBuffer</var>, <var>targetByteIndex</var>, <code>"Uint8"</code>, <ins><emu-val>true</emu-val></ins>, <var>value</var>).</li><li>...</li></ol></li></ol></li><li>Else,<ol><li>Repeat, while <var>targetByteIndex</var> &lt; <var>limit</var><ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteIndex</var>, <var>srcType</var>, <ins><emu-val>true</emu-val></ins>).</li><li>Perform <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>(<var>targetBuffer</var>, <var>targetByteIndex</var>, <var>targetType</var>, <ins><emu-val>true</emu-val></ins>, <var>value</var>).</li><li>...</li></ol></li></ol></li><li>Return <emu-val>undefined</emu-val>.
          </li></ol></emu-alg>
        </emu-clause>

        <emu-clause id="IndexedCollections.TypedArray.prototype.slice">
          <h1><span class="secnum">6.1.1.1.3</span>%TypedArray%.prototype.slice( <var>start</var>, <var>end</var> ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice">ES7 22.2.3.24</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype.slice">#</a></span></span></h1>
          <p>This algorithm is modified as follows:</p>

          <p>In the calls to <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref> and <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>, pass <emu-val>true</emu-val> as the fourth argument to indicate that the operations are
            performed on a TypedArray.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="IndexedCollections.TypedArray.constructors">
      <h1><span class="secnum">6.1.2</span>The %TypedArray% constructors (<a href="https://tc39.github.io/ecma262/#sec-typedarray-constructors">ES7 22.2.4</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.constructors">#</a></span></span></h1>

      <!-- es6num="22.2.1.3" -->
      <emu-clause id="sec-typedarray-typedarray">
        <h1><span class="secnum">6.1.2.1</span><var>TypedArray</var> ( <var>typedArray</var> ) (<a href="https://tc39.github.io/ecma262/#sec-typedarray-typedarray">ES7 22.2.4.3</a>)<span class="utils"><span class="anchor"><a href="#sec-typedarray-typedarray">#</a></span></span></h1>

        <p>This algorithm is modified as follows:</p>

        <p>In the calls to <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref> and <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>, pass <emu-val>true</emu-val> as the fourth argument to indicate that the operations are performed on a TypedArray.</p>
      </emu-clause>

    </emu-clause> <!-- intrinsic object -->

  </emu-clause>
</emu-clause>

<emu-clause id="StructuredData">
  <h1><span class="secnum">7</span>Structured Data (<a href="https://tc39.github.io/ecma262/#sec-structured-data">ES7 24</a>)<span class="utils"><span class="anchor"><a href="#StructuredData">#</a></span></span></h1>

  <emu-clause id="StructuredData.ArrayBuffer">
    <h1><span class="secnum">7.1</span>ArrayBuffer Objects (<a href="https://tc39.github.io/ecma262/#sec-arraybuffer-objects">ES7 24.1</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer">#</a></span></span></h1>

    <emu-clause id="StructuredData.ArrayBuffer.abstract">
      <h1><span class="secnum">7.1.1</span>Abstract Operations for ArrayBuffer (<a href="https://tc39.github.io/ecma262/#sec-abstract-operations-for-arraybuffer-objects">ES7 24.1.1</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract">#</a></span></span></h1>

      <emu-clause id="sec-detacharraybuffer" aoid="DetachArrayBuffer">
        <h1><span class="secnum">7.1.1.1</span>DetachArrayBuffer ( <var>arrayBuffer</var> ) (<a href="https://tc39.github.io/ecma262/#sec-detacharraybuffer">ES7 24.1.1.3</a>)<span class="utils"><span class="anchor"><a href="#sec-detacharraybuffer">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p>The abstract operation DetachArrayBuffer with argument <var>arrayBuffer</var> performs the following steps:</p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>arrayBuffer</var>) is Object and it has [[ArrayBufferData]] and [[ArrayBufferByteLength]] internal slots.</li><li><ins>Assert: <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</ins></li><li>...
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" aoid="GetValueFromBuffer">
        <h1><span class="secnum">7.1.1.2</span>GetValueFromBuffer( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>,  <ins><var>isTypedArray</var>,</ins> <var>isLittleEndian</var> ) (<a href="https://tc39.github.io/ecma262/#sec-getvaluefrombuffer">ES7 24.1.1.5</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p>The abstract operation GetValueFromBuffer takes  <del>four</del><ins>five</ins> parameters, an ArrayBuffer  <ins>or SharedArrayBuffer</ins> <var>arrayBuffer</var>, an integer <var>byteIndex</var>, a String <var>type</var>,  <ins>a Boolean <var>isTypedArray</var>,</ins> and optionally a Boolean <var>isLittleEndian</var>. This operation performs the following steps:</p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.github.io/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li>Assert: There are sufficient bytes in <var>arrayBuffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li>Assert: <var>byteIndex</var> is an integer value ≥ 0.</li><li>Let <var>block</var> be <var>arrayBuffer</var>.[[ArrayBufferData]].</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for Element Type <var>type</var>.</li><li><del>Let <var>rawValue</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of <var>elementSize</var> containing, in order, the <var>elementSize</var> sequence of bytes starting with <var>block</var>[<var>byteIndex</var>].</del><br><ins>If <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>true</emu-val> then:</ins><ol><li><ins>Let <var>accessAtomic</var> be <emu-val>true</emu-val> if <var>isTypedArray</var> is <emu-val>true</emu-val> and <var>type</var> is <code>"Int8"</code>, <code>"Uint8"</code>, <code>"Int16"</code>, <code>"Uint16"</code>, <code>"Int32"</code>, or <code>"Uint32"</code>, otherwise <emu-val>false</emu-val>.</ins></li><li><ins>Let <var>rawValue</var> be <emu-xref aoid="NonAtomicRead"><a href="#Atomics.NonAtomicRead">NonAtomicRead</a></emu-xref>(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>elementSize</var>).</ins></li><li><ins>Assert: <var>rawValue</var> is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of size <var>elementSize</var>.</ins></li></ol></li><li><ins>Else, let <var>rawValue</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> containing, in order, the <var>elementSize</var> sequence of bytes starting with <var>block</var>[<var>byteIndex</var>].</ins></li><li>If <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to <del>either <emu-val>true</emu-val> or <emu-val>false</emu-val>. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref> abstract operation</del> <ins>the value of the [[LittleEndian]] internal slot of the surrounding agent's <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref></ins>.</li><li>...
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.SetValueInBuffer" aoid="SetValueInBuffer">
        <h1><span class="secnum">7.1.1.3</span>SetValueInBuffer( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>,  <ins><var>isTypedArray</var>,</ins> <var>value</var>, <var>isLittleEndian</var> ) (<a href="https://tc39.github.io/ecma262/#sec-setvalueinbuffer">ES7 24.1.1.6</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p>The abstract operation SetValueInBuffer takes  <del>five</del><ins>six</ins> parameters, an ArrayBuffer  <ins>or SharedArrayBuffer</ins> <var>arrayBuffer</var>, an integer <var>byteIndex</var>, a String <var>type</var>,  <ins>a Boolean <var>isTypedArray</var>,</ins> a Number <var>value</var>, and optionally a Boolean <var>isLittleEndian</var>. This operation performs the following steps:</p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.github.io/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li>Assert: There are sufficient bytes in <var>arrayBuffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li>Assert: <var>byteIndex</var> is an integer value ≥ 0.</li><li>Assert: <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>value</var>) is Number.</li><li>Let <var>block</var> be <var>arrayBuffer</var>.[[ArrayBufferData]].</li><li>Assert: <var>block</var> is not <emu-val>undefined</emu-val>.</li><li>If <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to <del>either <emu-val>true</emu-val> or <emu-val>false</emu-val>. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref> abstract operation</del> <ins>the value of the [[LittleEndian]] internal slot of the surrounding agent's <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref></ins>.</li><li>If <var>type</var> is <code>"Float32"</code>, then<ol><li>...</li></ol></li><li>Else if <var>type</var> is <code>"Float64"</code>, then<ol><li>...</li></ol></li><li>Else,<ol><li>...</li></ol></li><li><del>Store the individual bytes of <var>rawBytes</var> into <var>block</var>, in order, starting at <var>block</var>[<var>byteIndex</var>].</del><br><ins>If <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>true</emu-val>, then:</ins><ol><li><ins>Let <var>accessAtomic</var> be <emu-val>true</emu-val> if <var>isTypedArray</var> is <emu-val>true</emu-val> and <var>type</var> is <code>"Int8"</code>, <code>"Uint8"</code>, <code>"Int16"</code>, <code>"Uint16"</code>, <code>"Int32"</code>, or <code>"Uint32"</code>, otherwise <emu-val>false</emu-val>.</ins></li><li><ins>Perform <emu-xref aoid="NonAtomicWrite"><a href="#Atomics.NonAtomicWrite">NonAtomicWrite</a></emu-xref>(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>elementSize</var>, <var>rawBytes</var>).</ins></li></ol></li><li><ins>Else, Store the individual bytes of <var>rawBytes</var> into <var>block</var>, in order, starting at <var>block</var>[<var>byteIndex</var>].</ins></li><li>Return <emu-xref aoid="NormalCompletion"><a href="https://tc39.github.io/ecma262/#sec-normalcompletion">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).
        </li></ol></emu-alg>
      </emu-clause>

    </emu-clause> <!-- abstract -->

    <emu-clause id="sec-properties-of-the-arraybuffer-prototype-object">
      <h1><span class="secnum">7.1.2</span>Properties of the ArrayBuffer Prototype Object (<a href="https://tc39.github.io/ecma262/#sec-properties-of-the-arraybuffer-prototype-object">ES7 24.1.4</a>)<span class="utils"><span class="anchor"><a href="#sec-properties-of-the-arraybuffer-prototype-object">#</a></span></span></h1>

      <emu-clause id="sec-get-arraybuffer.prototype.bytelength">
        <h1><span class="secnum">7.1.2.1</span>get ArrayBuffer.prototype.byteLength (<a href="https://tc39.github.io/ecma262/#sec-get-arraybuffer.prototype.bytelength">ES7 24.1.4.1</a>)<span class="utils"><span class="anchor"><a href="#sec-get-arraybuffer.prototype.bytelength">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p><code>ArrayBuffer.prototype.byteLength</code> is an accessor property whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
        <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>O</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>O</var> does not have an [[ArrayBufferData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>If <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>...
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.slice">
        <h1><span class="secnum">7.1.2.2</span>ArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> ) (<a href="https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice">ES7 24.1.4.3</a>)<span class="utils"><span class="anchor"><a href="#sec-arraybuffer.prototype.slice">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p>The following steps are taken:</p>
        <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>O</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>O</var> does not have an [[ArrayBufferData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>If <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>...
        </li></ol></emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause> <!-- ArrayBuffer -->

  <emu-clause id="StructuredData.DataView">
    <h1><span class="secnum">7.2</span>DataView Objects (<a href="https://tc39.github.io/ecma262/#sec-dataview-objects">ES7 24.2</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.DataView">#</a></span></span></h1>

    <!-- es6num="24.2.1" -->
    <emu-clause id="sec-abstract-operations-for-dataview-objects">
      <h1><span class="secnum">7.2.1</span>Abstract Operations For DataView Objects (<a href="https://tc39.github.io/ecma262/#sec-abstract-operations-for-dataview-objects">ES7 24.2.1</a>)<span class="utils"><span class="anchor"><a href="#sec-abstract-operations-for-dataview-objects">#</a></span></span></h1>

      <!-- es6num="24.2.1.1" -->
      <emu-clause id="sec-getviewvalue" aoid="GetViewValue">
        <h1><span class="secnum">7.2.1.1</span>GetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var> ) (<a href="https://tc39.github.io/ecma262/#sec-getviewvalue">ES7 24.2.1.1</a>)<span class="utils"><span class="anchor"><a href="#sec-getviewvalue">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>

        <p>In the call to <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>, pass <emu-val>false</emu-val> as the fourth argument to indicate that the operation is performed on a DataView.</p>
      </emu-clause>

      <!-- es6num="24.2.1.2" -->
      <emu-clause id="sec-setviewvalue" aoid="SetViewValue">
        <h1><span class="secnum">7.2.1.2</span>SetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var>, <var>value</var> ) (<a href="https://tc39.github.io/ecma262/#sec-setviewvalue">ES7 24.2.1.2</a>)<span class="utils"><span class="anchor"><a href="#sec-setviewvalue">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>

        <p>In the call to <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>, pass <emu-val>false</emu-val> as the fourth argument to indicate that the operation is performed on a DataView.</p>
      </emu-clause>

    </emu-clause>
  </emu-clause> <!-- DataView -->

  <emu-clause id="StructuredData.SharedArrayBuffer">
    <h1><span class="secnum">7.3</span>SharedArrayBuffer Objects<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer">#</a></span></span></h1>

    <emu-clause id="StructuredData.SharedArrayBuffer.abstract">
      <h1><span class="secnum">7.3.1</span>Abstract Operations for SharedArrayBuffer<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.abstract">#</a></span></span></h1>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer">
        <h1><span class="secnum">7.3.1.1</span>AllocateSharedArrayBuffer( <var>constructor</var>, <var>byteLength</var> )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer">#</a></span></span></h1>
        <p>The abstract operation AllocateSharedArrayBuffer with arguments <var>constructor</var> and <var>byteLength</var> is used to create a SharedArrayBuffer object. It performs the following steps:</p>

        <emu-alg><ol><li>Let <var>obj</var> be ? <emu-xref aoid="OrdinaryCreateFromConstructor"><a href="https://tc39.github.io/ecma262/#sec-ordinarycreatefromconstructor">OrdinaryCreateFromConstructor</a></emu-xref>(constructor, "%SharedArrayBufferPrototype%", «‍[[ArrayBufferData]], [[ArrayBufferByteLength]]» ).</li><li>Assert: <var>byteLength</var> is a nonnegative integer.</li><li>Let <var>block</var> be ? <emu-xref aoid="CreateSharedByteDataBlock"><a href="#DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock">CreateSharedByteDataBlock</a></emu-xref>(<var>byteLength</var>).</li><li>Set <var>obj</var>.[[ArrayBufferData]] to <var>block</var>.</li><li>Set <var>obj</var>.[[ArrayBufferByteLength]] to <var>byteLength</var>.</li><li>Return <var>obj</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer" aoid="IsSharedArrayBuffer">
        <h1><span class="secnum">7.3.1.2</span>IsSharedArrayBuffer( <var>obj</var> )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">#</a></span></span></h1>
        <p>IsSharedArrayBuffer tests whether an object that is an ArrayBuffer, a SharedArrayBuffer, or a subtype of either is a SharedArrayBuffer or a subtype of it.  It performs the following steps:</p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>obj</var>) is Object and it has an [[ArrayBufferData]] internal slot.</li><li>Let <var>bufferData</var> be <var>obj</var>.[[ArrayBufferData]].</li><li>If <var>bufferData</var> is <emu-val>null</emu-val> or <emu-val>undefined</emu-val> then return <emu-val>false</emu-val>.</li><li>If <var>bufferData</var> is a <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> then return <emu-val>false</emu-val>.</li><li>Assert: <var>bufferData</var> is a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref>.</li><li>Return <emu-val>true</emu-val>.
        </li></ol></emu-alg>
      </emu-clause>

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor">
      <h1><span class="secnum">7.3.1.3</span>The SharedArrayBuffer Constructor<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor">#</a></span></span></h1>
      <p>The SharedArrayBuffer constructor is the %SharedArrayBuffer% intrinsic object and the initial value of the <code>SharedArrayBuffer</code> property of the <emu-xref href="#global-object"><a href="https://tc39.github.io/ecma262/#global-object">global object</a></emu-xref>. When called as a constructor it creates and initializes a new SharedArrayBuffer object.  The SharedArrayBuffer constructor is not intended to be called as a function and will throw an exception when called in that manner.</p>

      <p>The SharedArrayBuffer constructor is designed to be subclassable. It may be used as the value of an <code>extends</code> clause of a class definition. Subclass constructors that intend to inherit the specified SharedArrayBuffer behaviour must include a <code>super</code> call to the SharedArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support the <code>SharedArrayBuffer.prototype</code> built-in methods.</p>

      <emu-note><span class="note">Note</span>
        <p>Unlike an ArrayBuffer, a SharedArrayBuffer cannot become detached, and its internal [[ArrayBufferData]] slot is never <emu-val>null</emu-val> or <emu-val>undefined</emu-val>.</p>
      </emu-note>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.withLength">
        <h1><span class="secnum">7.3.1.3.1</span>SharedArrayBuffer( <var>length</var> )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.withLength">#</a></span></span></h1>
        <p>SharedArrayBuffer called with argument <var>length</var> performs the following steps:</p>
        <emu-alg><ol><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>numberLength</var> be ? <emu-xref aoid="ToNumber"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>length</var>).</li><li>Let <var>byteLength</var> be <emu-xref aoid="ToLength"><a href="https://tc39.github.io/ecma262/#sec-tolength">ToLength</a></emu-xref>(<var>numberLength</var>).</li><li>If <emu-xref aoid="SameValueZero"><a href="https://tc39.github.io/ecma262/#sec-samevaluezero">SameValueZero</a></emu-xref>(<var>numberLength</var>, <var>byteLength</var>) is <emu-val>false</emu-val>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Return AllocateSharedArrayBuffer(NewTarget, <var>byteLength</var>).
        </li></ol></emu-alg>
      </emu-clause>
    </emu-clause> <!-- constructor -->

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties">
      <h1><span class="secnum">7.3.1.4</span>Properties of the SharedArrayBuffer constructor<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.properties">#</a></span></span></h1>

      <p>The value of the [[Prototype]] internal slot of the SharedArrayBuffer constructor is the intrinsic object <emu-xref href="#sec-properties-of-the-function-constructor"><a href="https://tc39.github.io/ecma262/#sec-properties-of-the-function-constructor">%FunctionPrototype%</a></emu-xref> (q.v.).</p>

      <p>Besides its <code>length</code> property (whose value is 1), the SharedArrayBuffer constructor has the following properties:</p>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.prototype">
        <h1><span class="secnum">7.3.1.4.1</span>SharedArrayBuffer.prototype<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.properties.prototype">#</a></span></span></h1>
        <p>The initial value of SharedArrayBuffer.prototype is the intrinsic object %SharedArrayBufferPrototype% (q.v.).</p>
        <p>This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>false</emu-val> }.</p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.get_species">
        <h1><span class="secnum">7.3.1.4.2</span>get SharedArrayBuffer [ @@species ]<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.properties.get_species">#</a></span></span></h1>
        <p><code>SharedArrayBuffer[@@species]</code> is an accessor property whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
        <emu-alg><ol><li>Return the <emu-val>this</emu-val> value.
        </li></ol></emu-alg>
        <p>The value of the name property of this function is "<code>get [Symbol.species]</code>".</p>
      </emu-clause>
    </emu-clause> <!-- properties -->

    <emu-clause id="StructuredData.SharedArrayBuffer.prototype">
      <h1><span class="secnum">7.3.1.5</span>Properties of the SharedArrayBuffer prototype object<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype">#</a></span></span></h1>

      <p>The SharedArrayBuffer prototype object is the intrinsic object %SharedArrayBufferPrototype%. The value of the [[Prototype]] internal slot of the SharedArrayBuffer prototype object is the intrinsic object <emu-xref href="#sec-properties-of-the-object-prototype-object"><a href="https://tc39.github.io/ecma262/#sec-properties-of-the-object-prototype-object">%ObjectPrototype%</a></emu-xref> (19.1.3). The SharedArrayBuffer prototype object is an ordinary object. It does not have an [[ArrayBufferData]] or [[ArrayBufferByteLength]] internal slot.</p>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.get_byteLength">
        <h1><span class="secnum">7.3.1.5.1</span>get SharedArrayBuffer.prototype.byteLength<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.get_byteLength">#</a></span></span></h1>

        <p>SharedArrayBuffer.prototype.byteLength is an accessor property whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>

        <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>O</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>O</var> does not have a [[ArrayBufferData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>length</var> be <var>O</var>.[[ArrayBufferByteLength]].</li><li>Return <var>length</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.constructor">
        <h1><span class="secnum">7.3.1.5.2</span>SharedArrayBuffer.prototype.constructor<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.constructor">#</a></span></span></h1>
        <p>The initial value of <code>SharedArrayBuffer.prototype.constructor</code> is the intrinsic object %SharedArrayBuffer%.</p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.slice">
        <h1><span class="secnum">7.3.1.5.3</span>SharedArrayBuffer.prototype.slice( <var>start</var>, <var>end</var> )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.slice">#</a></span></span></h1>
        <p>The following steps are taken:</p>
        <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>O</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>O</var> does not have an [[ArrayBufferData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>len</var> be <var>O</var>.[[ArrayBufferByteLength]].</li><li>Let <var>relativeStart</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>start</var>).</li><li>If <var>relativeStart</var> &lt; 0, let first be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>((<var>len</var> + <var>relativeStart</var>), 0); else let first be <emu-xref aoid="min"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>end</var>).</li><li>If <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>((<var>len</var> + <var>relativeEnd</var>), 0); else let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li>Let <var>newLen</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(<var>final</var> - <var>first</var>, 0).</li><li>Let <var>ctor</var> be ? <emu-xref aoid="SpeciesConstructor"><a href="https://tc39.github.io/ecma262/#sec-speciesconstructor">SpeciesConstructor</a></emu-xref>(<var>O</var>, %SharedArrayBuffer%).</li><li>Let <var>new</var> be ? <emu-xref aoid="Construct"><a href="https://tc39.github.io/ecma262/#sec-construct">Construct</a></emu-xref>(<var>ctor</var>, «newLen»).</li><li>If <var>new</var> does not have an [[ArrayBufferData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="SameValue"><a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>new</var>, <var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>new</var>.[[ArrayBufferByteLength]] &lt; <var>newLen</var>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>fromBuf</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>toBuf</var> be <var>new</var>.[[ArrayBufferData]].</li><li>Perform <emu-xref aoid="CopyDataBlockBytes"><a href="#DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes">CopyDataBlockBytes</a></emu-xref>(<var>toBuf</var>, 0, <var>fromBuf</var>, <var>first</var>, <var>newLen</var>).</li><li>Return <var>new</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.toString">
        <h1><span class="secnum">7.3.1.5.4</span>SharedArrayBuffer.prototype[ @@toStringTag ]<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.toString">#</a></span></span></h1>
        <p>The initial value of the @@toStringTag property is the String value <code>"SharedArrayBuffer"</code>.</p>

        <p>This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>true</emu-val> }.</p>
      </emu-clause>
    </emu-clause> <!-- prototype -->

    <emu-clause id="StructuredData.SharedArrayBuffer.instances">
      <h1><span class="secnum">7.3.1.6</span>Properties of the SharedArrayBuffer instances<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.instances">#</a></span></span></h1>

      <p>SharedArrayBuffer instances inherit properties from the SharedArrayBuffer prototype object. SharedArrayBuffer instances each have an [[ArrayBufferData]] internal slot and a [[ArrayBufferByteLength]] internal slot.</p>

      <emu-note><span class="note">Note</span>
        <p>SharedArrayBuffer instances, unlike ArrayBuffer instances, are never detached.</p>
      </emu-note>
    </emu-clause> <!-- instances -->

  </emu-clause> <!-- SharedArrayBuffer -->
</emu-clause> <!-- Structured data -->

<emu-clause id="AtomicsObject">
  <h1><span class="secnum">7.4</span>The Atomics Object<span class="utils"><span class="anchor"><a href="#AtomicsObject">#</a></span></span></h1>

  <p>The Atomics object is the  <dfn>%Atomics%</dfn> intrinsic object and the initial value of the <code>Atomics</code> property of the <emu-xref href="#global-object"><a href="https://tc39.github.io/ecma262/#global-object">global object</a></emu-xref>. The Atomics object is a single ordinary object.</p>

  <p>The Atomics object provides functions that operate indivisibly (atomically) on shared memory array cells as well as functions that let agents wait for and dispatch primitive events.  When used with discipline, the Atomics functions allow multi-agent programs that communicate through shared memory to execute in a well-understood order even on parallel CPUs.  The rules that govern shared-memory communication are provided by the  <em>memory model</em>, see  <emu-xref href="#AtomicsObject.MemoryModel"><a href="#AtomicsObject.MemoryModel">7.4.1.1</a></emu-xref>.</p>

  <p>The value of the [[Prototype]] internal slot of the Atomics object is the intrinsic object <emu-xref href="#sec-properties-of-the-object-prototype-object"><a href="https://tc39.github.io/ecma262/#sec-properties-of-the-object-prototype-object">%ObjectPrototype%</a></emu-xref>.</p>

  <p>The Atomics object is not a function object. It does not have a [[Construct]] internal method; it is not possible to use the Atomics object as a constructor with the <code>new</code> operator. The Atomics object also does not have a [[Call]] internal method; it is not possible to invoke the Atomics object as a function.</p>

  <emu-clause id="AtomicsObject.FunctionProps.semantics">
    <h1><span class="secnum">7.4.1</span>Runtime semantics<span class="utils"><span class="anchor"><a href="#AtomicsObject.FunctionProps.semantics">#</a></span></span></h1>

    <emu-clause id="AtomicsObject.MemoryModel">
      <h1><span class="secnum">7.4.1.1</span>Memory model<span class="utils"><span class="anchor"><a href="#AtomicsObject.MemoryModel">#</a></span></span></h1>

      <p>The memory model determines when a particular read from shared memory may observe a particular write to shared memory.  Programs  <em>synchronize</em> to ensure that reads and writes to shared memory happen in a meaningful order.  Synchronization happens chiefly by means of  <em>atomic operations</em> to shared memory wherein an atomic read observes the value written by an atomic write.</p>

      <p>ECMAScript shared memory obeys very weak type discipline, in that the byte array of a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> can be aliased by TypedArrays of different types and accessed without natural alignment via DataViews, and also in that atomic operations are applied to cells that are also accessed non-atomically.  For atomic operations to be useful for synchronization they must not be interfered with by incompatible atomic operations or by non-atomic operations, and this specification therefore describes the conditions under which memory operations interfere as well as the observable effects of interfering and non-interfering operations.</p>

      <emu-note><span class="note">Note 1</span>
        <p>In many other programming languages, non-interference is just a consequence of strong typing.</p>
      </emu-note>

      <p>Non-interfering atomic operations (later called  <em>viable</em> atomic operations) are executed in a well-defined order, and that order will allow programmers to reason about program synchronization, causality, and data races in a conventional way.</p>

      <p>The purpose of viability is to describe conditions under which the implementation of atomic operations need not concern itself with the problems resulting from the weak type discipline; atomic operations can simply be implemented in conventional ways on current hardware and operations that are deemed viable in the semantics will always be observed as being executed atomically and in the desired well-defined order.</p>

      <emu-note><span class="note">Note 2</span>
        <p>(Programming advice)  If the program obeys some simple rules then most of the complexities of the memory model can be ignored by programmers, and program behavior can be inferred from the description in  <emu-xref href="#AtomicsObject.EventsAndSync"><a href="#AtomicsObject.EventsAndSync">7.4.1.2.3</a></emu-xref>.  These rules amount to segregating atomic and non-atomic locations and strongly typing the atomic locations:</p>

        <ol>
          <li> A variable in shared memory that is used with atomic operations should always be of a specific type, eg, <code>Int32</code>, and this fact should be implemented by always accessing the variable's memory through a view of that type, never through aliasing views of other types or DataViews. 

          </li><li> All accesses to the variable should be with atomic operations (of the selected type).
        
        </li></ol>

        <p>(Advanced programming advice) Initializing stores to the variable's memory can safely be made by non-atomic operations and through views of other types, provided there is other synchronization in the program that ensures that the initialization is finished before the program uses the variable for synchronization in any thread.</p>
      </emu-note>

      <emu-clause id="AtomicsObject.Fundamentals">
        <h1><span class="secnum">7.4.1.1.1</span>Fundamentals<span class="utils"><span class="anchor"><a href="#AtomicsObject.Fundamentals">#</a></span></span></h1>

        <p>Shared memory access is always performed by designated  <em>memory operations</em>: the  <em>atomic operations</em> <emu-xref aoid="AtomicRead"><a href="#Atomics.AtomicRead">AtomicRead</a></emu-xref>, <emu-xref aoid="AtomicWrite"><a href="#Atomics.AtomicWrite">AtomicWrite</a></emu-xref>, <emu-xref aoid="AtomicReadModifyWrite"><a href="#Atomics.AtomicReadModifyWrite">AtomicReadModifyWrite</a></emu-xref>, and <emu-xref aoid="AtomicCompareExchange"><a href="#Atomics.AtomicCompareExchange">AtomicCompareExchange</a></emu-xref>, and the  <em>non-atomic operations</em> <emu-xref aoid="NonAtomicRead"><a href="#Atomics.NonAtomicRead">NonAtomicRead</a></emu-xref> and <emu-xref aoid="NonAtomicWrite"><a href="#Atomics.NonAtomicWrite">NonAtomicWrite</a></emu-xref>.  The memory operations never perform non-shared-memory access.</p>

        <p>The  <em>access range</em> of a memory operation comprises the memory cells read or written by the operation.  These cells are always consecutive and within a single <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref>.</p>

        <p>An atomic operation to some access range is  <em>viable</em> in an execution only if all other memory operations that intersect with that access range while the atomic operation is being performed are atomic operations or non-atomic read operations on the same access range, in a manner that is made precise in the following.</p>

        <emu-note><span class="note">Note 1</span>
          <p>(Spec draft note)</p>

          <p>Below, we provide a precise operational definition of viability that is based on transactions on a shared state; each memory operation has distinct start and end points, allowing us to discuss interference and to state clearly when an atomic operation is viable.</p>

          <p>Our eventual purpose is to define the synchronization order of an execution, which is a total order of the viable atomic operations of the execution.  In selecting the viable atomic operations we have to consider the following interacting problems:</p>

          <ul>
            <li> <b>Cells that are not exclusively atomic:</b> Instead of having typed atomic cells that are disjoint from non-atomic cells, we allow atomic and non-atomic operations to operate on the same cells, and it is possible to have simultaneous atomic and non-atomic operations on the same cell. 

            </li><li> <b>Aliasing:</b> The TypedArray system allows one-byte, two-byte, and four-byte cells to overlap, and it is possible to have simultaneous memory operations on (say) a two-byte cell and the four-byte cell it aliases. 

            </li><li> <b>Non-atomic initialization of memory:</b> In practice, programs translated from C, and from C++ with low-level atomics, will assume that it's legal to perform an atomic read from memory that was initialized with non-atomic writes, so long as the read is properly ordered after the writes by some other mechanism. 

            </li><li> <b>Lock-free and non-lock-free atomics:</b> Lock-free and non-lock-free atomics do not use compatible mutual exclusion mechanisms, so even if hardware can be relied on to properly order different-sized lock-free atomic operations on aliased memory, it may not be counted on to also order lock-free and non-lock-free atomic operations on aliased memory.
          
          </li></ul>

          <p>For example, suppose an eight-byte non-lock-free atomic write operation E attempts to interact with the memory system at the same time as a four-byte lock-free atomic write operation F, and that the access ranges overlap.  (We don't have eight-byte atomics at present but we may have them in the future, and there are 32-bit platforms, such as MIPS, that do not have 64-bit atomics.)  E acquires a lock, then writes the data bytes in some arbitrary order, then releases the lock.  While E holds the lock, F interacts directly with the memory system to write its four bytes as a unit.  The result may easily be that some of the bytes written for E are written before the four bytes of F, and some after.  As a result, the bytes in memory at the location of F may be a jumble of the two values, contrary to the desire that atomic operations execute atomically.</p>

          <p>(In the case of a non-lock-free atomic in a practical implementation, the lock and unlock operations may themselves not be atomic operations in the sense used here; the only requirement is that the combination of the lock and the unlock should enter into the global atomic order on behalf of the non-lock-free atomic access.)</p>

          <p>In the semantics, the difference between lock-free and non-lock free is not visible, but some of the choices in the semantics are a consequence of having to deal with both implementation strategies.</p>

          <p>The purpose of viability is therefore to describe conditions under which the implementation of atomic operations  <em>need not concern</em> itself with the problems listed above, ie, we do not wish to order the operations in the example above, but rather to make it plain that there are no atomicity or ordering guarantees when the atomic operations are non-viable.</p>

          <p>Ours is a lightweight notion of viability in that it is strictly per atomic operation.  If what is syntactically a single atomic operation in the program is executed more than once, the operation can be viable in one case and non-viable in another.  It is also per execution: even if two programs execute the same atomic operations in the same order, an operation may be viable in one execution and not in another.  We also do not consider the provenance of the bytes read by an atomic read -- they could have been written by an atomic write to the access range, an atomic write to a larger access range, a non-atomic write, or a combination of those.  A stronger notion of viability could require a viable atomic read to see only a value that was written by a single atomic write to the same access range (but we would then need to add some mechanism for dealing with non-atomic initializing writes).</p>

          <p>The term "viable" is used in preference to e.g. "non-racy" since we want to reserve the term "data race" for the conventional notion of operations unordered by the happens-before relation, see later.</p>

          <p>(End spec draft note)</p>
        </emu-note>

        <p>Inter-agent communication actions that are not memory operations (such as Atomics.wake and Atomics.wait, or host-specific communication actions) are in the following considered to be memory operations, with an <emu-xref aoid="AtomicWrite"><a href="#Atomics.AtomicWrite">AtomicWrite</a></emu-xref> (to some hidden location in shared memory, with an arbitrary value) occuring as part of the action that sends a communication and an <emu-xref aoid="AtomicRead"><a href="#Atomics.AtomicRead">AtomicRead</a></emu-xref> (to the same location) occuring as part of the action that receives a communication.  These synthesized atomic operations are viable, by construction.</p>

        <emu-note><span class="note">Note 2</span>
          <p>Examples of host-specific inter-agent communication actions are: sending a SharedArrayBuffer from one agent and receiving it in another (e.g., by <code>postMessage</code> in a web browser), starting and stopping agents, and communicating within the agent cluster via channels other than shared memory.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="AtomicsObject.Formalization">
        <h1><span class="secnum">7.4.1.1.2</span>Formalization framework<span class="utils"><span class="anchor"><a href="#AtomicsObject.Formalization">#</a></span></span></h1>

        <p>We use the following semantic data structures to determine viability of atomic operations and to express the ordering of viable atomic operations.</p>

        <p>The memory system for the agent cluster comprises a byte-addressable shared memory and a critical section (the  <em>Memory Critical Section</em>) that protects a generator of timestamps and a transaction set.  The critical section is a specification device that exists outside the program-visible shared memory; it does not have effects beyond mutual exclusion.</p>

        <p>The semantic operations <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref>, <emu-xref aoid="EndAtomic"><a href="#Atomics.EndAtomic">EndAtomic</a></emu-xref>, <emu-xref aoid="BeginNonAtomic"><a href="#Atomics.BeginNonAtomic">BeginNonAtomic</a></emu-xref>, and <emu-xref aoid="EndNonAtomic"><a href="#Atomics.EndNonAtomic">EndNonAtomic</a></emu-xref> operate on the memory system and denote the start and end of atomic and non-atomic operations, respectively.  The memory operations are defined in terms of these abstract operations and of the memory access primitives <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref> and <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref>.</p>

        <emu-note><span class="note">Note 1</span>
          <p>Operationally, an atomic access is viable if and only if the <emu-xref aoid="EndAtomic"><a href="#Atomics.EndAtomic">EndAtomic</a></emu-xref> operation returns <emu-val>true</emu-val>.</p>
        </emu-note>

        <p>A  <em>transaction</em> on shared memory is a quintuple (<var>t</var>, <var>op</var>, <var>block</var>, <var>byteIndex</var>, <var>elementSize</var>).  The transaction set stores transactions.  The <var>t</var> is a value from the stream of timestamps.  The <var>op</var> is a String, denoting the operation. An  <em>atomic transaction</em> is a transaction whose operation is <code>"Atomic"</code> or <code>"Invalid"</code>. A  <em>non-atomic transaction</em> is a transaction whose operation is <code>"Read"</code> or <code>"Write"</code>.  The <var>block</var> is a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> value, the <var>byteIndex</var> a nonnegative integer, and the <var>elementSize</var> a positive integer.</p>

        <p>The initial value of the transaction set is the empty set. To  <em>invalidate</em> the transaction set for atomics means for each atomic transaction (<var>t</var>, <code>"Atomic"</code>, <var>block</var>, <var>byteIndex</var>, <var>elementSize</var>) in the transaction set, replace it with a transaction (<var>t</var>, <code>"Invalid"</code>, <var>block</var>, <var>byteIndex</var>, <var>elementSize</var>). 

        </p><p>Two memory transactions (<var>t1</var>, <var>op1</var>, <var>block1</var>, <var>byteIndex1</var>, <var>elementSize1</var>) and (<var>t2</var>, <var>op2</var>, <var>block2</var>, <var>byteIndex2</var>, <var>elementSize2</var>)  <em>overlap</em> if <var>block1</var> and <var>block2</var> are the same, and the sequence [<var>byteIndex1</var>, <var>byteIndex1</var>+1, ..., <var>byteIndex1</var>+<var>elementSize1</var>-1] overlaps with but is not equal to the sequence [<var>byteIndex2</var>, <var>byteIndex2</var>+1, ..., <var>byteIndex2</var>+<var>elementSize2</var>-1].  Two transactions  <em>match</em> if their <var>block</var>, <var>byteIndex</var>, and <var>elementSize</var> fields are pairwise equal.  Two transactions are  <em>disjoint</em> if they neither overlap nor match.</p>

        <p>Two memory operations are  <em>concurrent</em> if one operation's Begin step happens between the other's Begin and End steps (as determined by the order those steps enter the Memory Critical Section).</p>

        <p>Two memory operations  <em>conflict</em> if they are concurrent and are not disjoint.</p>

        <p><emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref>, <emu-xref aoid="EndAtomic"><a href="#Atomics.EndAtomic">EndAtomic</a></emu-xref>, <emu-xref aoid="BeginNonAtomic"><a href="#Atomics.BeginNonAtomic">BeginNonAtomic</a></emu-xref>, and <emu-xref aoid="EndNonAtomic"><a href="#Atomics.EndNonAtomic">EndNonAtomic</a></emu-xref> implement a state machine whose state is either Clear, Atomic, or Invalid, with Clear the initial state.  The Begin operations add transactions to the transaction set, and the End operations remove them.  The machine is in the Clear state when there are no atomic transaction in the set; the Atomic state when there is exactly one atomic transaction in the set and it has an operation of <code>"Atomic"</code>; the Invalid state when there is an atomic transaction in the set that has an operation of <code>"Invalid"</code> (in this case all atomic transactions in the set have the operation <code>"Invalid"</code>).  When all atomic operations are viable, the machine alternates between the Clear and Atomic states, but a memory operation that makes an atomic operation non-viable will move the machine into the Invalid state.  Atomic operations that occur while the machine is in the Invalid state are also non-viable.  The machine transitions out of the Invalid state only when there are no more atomic transactions left in the set.</p>

        <emu-note><span class="note">Note 2</span>
          <p>The state machine is conservative in that, when it is in the Atomic state, an overlapping <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref> will move the machine into the Invalid state even if both atomic operations are reads.  This is deemed acceptable as the utility of allowing non-matching reading atomics to be viable is highly questionable.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="AtomicsObject.Transformations">
        <h1><span class="secnum">7.4.1.1.3</span>Program transformations<span class="utils"><span class="anchor"><a href="#AtomicsObject.Transformations">#</a></span></span></h1>

        <p>Program transformations (by a compiler or the hardware) must not reorder an agent's atomic operations with its non-atomic operations, nor reorder its atomic operations with each other.</p>

        <emu-note><span class="note">Note 1</span>
          <p>In practice, the prohibition on reorderings forces a compiler to assume that every atomic operation is viable, which it would usually have to assume anyway in the absence of inter-agent program analysis.</p>
        </emu-note>

        <p>Almost all intra-agent semantics-preserving program transformations remain valid when accessing shared memory, so long as the reordering rule is obeyed.  The following rules additionally restrict intra-agent program transformations:</p>

        <ul>
          <li><b>Stable reads:</b> Any given shared memory read must only observe a single value.  (For example, if what is semantically a single read in the program is executed multiple times then the program is subsequently allowed to observe only one of the values read.) 

          </li><li><b>Stable writes:</b> Any given shared memory read must only observe value changes in memory that follow from program semantics.  (For example, the compiler or hardware may not introduce certain observable writes, such as using read-modify-write operations on a larger location to write a smaller datum, writing a value to memory that the program could not have written, or spuriously writing a just-read value back to the location it was read from.  Note that byte interleaving resulting from conflicting writes, see  <emu-xref href="#Atomics.WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">7.4.1.1.5</a></emu-xref>, is within program semantics.) 

          </li><li><b>Actual values:</b> Any given shared memory read must only observe values that have been produced by the program's execution.  (For example, the compiler or hardware may not speculate about a value in shared memory and then use that value to justify the speculation.)
        
        </li></ul>

        <emu-note><span class="note">Note 2</span>
          <p>It is generally desirable to allow transformations that are legal for non-shared-memory programs to continue to be legal in shared-memory programs.  However, some of those transformations lead to programs that are nonsensical in the presence of side effects in shared memory.</p>

          <p>The preceding rules can be seen as expressing restrictions on the program's interaction with shared memory.  They are expressed in the context of transformations since mainly transformed or optimized programs would encounter the problems.</p>
        </emu-note>

        <emu-note><span class="note">Note 3</span>
          <p>(Spec draft note)</p>

          <p>For example, the transformation from this:</p>
          <pre>    let x = mem[n]
    if (x) print(x)</pre>
          <p>to this:</p>
          <pre>    if (mem[n]) print(mem[n])</pre>
          <p>is legal in a non-shared-memory program (if <code>mem</code> and <code>n</code> are side-effect free) but if <code>mem</code> is shared memory and is updated by another agent in the middle of the execution of the statement the transformed program may end up printing <emu-val>0</emu-val>, and that is nonsensical.</p>

          <p>The restrictions apply only to shared memory accesses, so an implementation that knows the program is not accessing shared memory will not be affected by them.  In practice, the optimizations that are affected by the restrictions (rematerialization, certain local optimizations) are of limited value, and a practical implementation could avoid those optimizations even for non-shared memory without significant impact.</p>

          <p>Examples of transformations that remain valid are: merging multiple non-atomic reads from the same location, reordering non-atomic reads from different locations, introducing speculative non-atomic reads, merging multiple non-atomic writes to the same location, and reordering non-atomic writes to different locations.  These transformations can be performed by a compiler or the hardware; in the latter case they take the form of speculative loads and buffered stores.</p>

          <p>The "Actual values" was introduced to prohibit out-of-thin-air values but it is not obvious that it is necessary in our operational model.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="Atomics.ReadSharedMemory" aoid="ReadSharedMemory">
        <h1><span class="secnum">7.4.1.1.4</span>ReadSharedMemory(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>numBytes</var>)<span class="utils"><span class="anchor"><a href="#Atomics.ReadSharedMemory">#</a></span></span></h1>

        <p>ReadSharedMemory takes four arguments, a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> <var>block</var>, a nonnegative integer <var>byteIndex</var>, a Boolean <var>accessAtomic</var>, and a positive integer <var>numBytes</var>, and returns a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of length <var>numBytes</var> containing bytes.</p>

        <p>We say the invocation of ReadSharedMemory is  <em>tidy</em> if and only if:</p>
        <ol>
          <li> The read operation that called ReadSharedMemory conflicts only with (possibly zero) write operations that all match the read operation (and optionally the read operation can conflict with arbitrary other read operations), and
          
          </li><li> <var>accessAtomic</var> is <emu-val>true</emu-val>, and
          
          </li><li> <var>accessAtomic</var> is <emu-val>true</emu-val> in all the <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref> calls for the conflicting writes.
        
        </li></ol>

        <emu-note><span class="note">Note</span>
          <p>The tidiness condition is present here, and a similar condition is present in <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref>, to ensure that certain conflicts are resolved in a predictable way: matching conflicting writes to integer-typed TypedArrays end up writing one value before the other, not a byte-wise mix of the values.  All hardware supports the behavior and it is valuable to programs in practice.</p>
        </emu-note>

        <p>Perform the following operations:</p>

        <emu-alg><ol><li>Assert: If <var>accessAtomic</var> is true then <var>numBytes</var> is a power of two and <var>byteIndex</var> <emu-xref aoid="modulo"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">modulo</a></emu-xref> <var>numBytes</var> is zero.</li><li>Assert: The length of <var>block</var> is at least <var>byteIndex</var>+<var>numBytes</var>.</li><li>If the invocation of <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref> is tidy, then:<ol><li>Wait for some arbitrary number of the conflicting writes to complete, one after the other.</li></ol></li><li>Otherwise:<ol><li>Wait for some arbitrary number of bytes to be written by the conflicting writes in some arbitrary order.</li></ol></li><li>Let <var>rawValue</var> be the <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of <var>numBytes</var> bytes in memory starting at <var>block</var>[<var>byteIndex</var>], in order, obtained before any further conflicting write gets to perform its write.</li><li>Return <var>rawValue</var>.
        </li></ol></emu-alg>

      </emu-clause>

      <emu-clause id="Atomics.WriteSharedMemory" aoid="WriteSharedMemory">
        <h1><span class="secnum">7.4.1.1.5</span>WriteSharedMemory(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>numBytes</var>, <var>rawBytes</var>)<span class="utils"><span class="anchor"><a href="#Atomics.WriteSharedMemory">#</a></span></span></h1>

        <p>WriteSharedMemory takes five arguments, a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> <var>block</var>, a nonnegative integer <var>byteIndex</var>, a Boolean <var>accessAtomic</var>, a positive integer <var>numBytes</var>, and a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> <var>rawBytes</var> of length <var>numBytes</var> containing bytes, and stores the individual bytes of <var>rawBytes</var> into <var>block</var>, in order, starting at <var>block</var>[<var>byteIndex</var>].</p>

        <p>We say the invocation of WriteSharedMemory is  <em>tidy</em> if and only if:</p>
        <ol>
          <li> The write operation that called WriteSharedMemory conflicts only with (possibly zero) write operations that all match the write operation (and optionally the write operation can conflict with arbitrary other read operations), and
          
          </li><li> <var>accessAtomic</var> is <emu-val>true</emu-val>, and
          
          </li><li> <var>accessAtomic</var> is <emu-val>true</emu-val> in all the WriteSharedMemory calls for the conflicting writes.
        
        </li></ol>

        <p>Perform the following operations:</p>

        <emu-alg><ol><li>Assert: If <var>accessAtomic</var> is true then <var>numBytes</var> is a power of two and <var>byteIndex</var> <emu-xref aoid="modulo"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">modulo</a></emu-xref> <var>numBytes</var> is zero.</li><li>Assert: The length of <var>block</var> is at least <var>byteIndex</var>+<var>numBytes</var>.</li><li>If the invocation of <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref> is tidy, then:<ol><li>Wait for some arbitrary number of the conflicting writes to complete, one after the other.</li><li>Write the bytes of <var>rawBytes</var> before any remaining conflicting write gets to perform its write.</li></ol></li><li>Otherwise:<ol><li>While there are unwritten bytes in <var>rawBytes</var>:<ol><li>Select a byte to write from <var>rawBytes</var>.</li><li>Wait for some arbitrary number of bytes to be written by the conflicting writes.</li><li>Write the selected byte at its proper location in <var>block</var>.
        </li></ol></li></ol></li></ol></emu-alg>

      </emu-clause>

      <emu-clause id="Atomics.BeginAtomic" aoid="BeginAtomic">
        <h1><span class="secnum">7.4.1.1.6</span>BeginAtomic(<var>block</var>, <var>byteIndex</var>, <var>elementSize</var>)<span class="utils"><span class="anchor"><a href="#Atomics.BeginAtomic">#</a></span></span></h1>
        <p>BeginAtomic takes three arguments, a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> <var>block</var>, a nonnegative integer <var>byteIndex</var>, and a positive integer <var>elementSize</var>, and does the following:</p>

        <emu-alg><ol><li>Enter the Memory Critical Section.</li><li>Let <var>t</var> be the next value from the timestamp stream; advance the stream.</li><li>Let <var>atomicTxns</var> be the set of atomic transactions in the transaction set.</li><li>While <var>atomicTxns</var> is the singleton set containing an atomic transaction whose operation is <code>"Atomic"</code> and that either matches or is disjoint from (<var>block</var>, <var>byteIndex</var>, <var>elementSize</var>):<ol><li>Leave the Memory Critical Section and wait until the transaction set changes.</li><li>Enter the Memory Critical Section.</li><li>Let <var>atomicTxns</var> be the set of all atomic transactions in the transaction set.</li></ol></li><li>Let <var>interferingTxns</var> be the set of transactions in the transaction set that are not disjoint from (<var>block</var>, <var>byteIndex</var>, <var>elementSize</var>).</li><li>Remove transactions that match (<var>block</var>, <var>byteIndex</var>, <var>elementSize</var>) and whose operation is <code>"Read"</code> from <var>interferingTxns</var>.</li><li>If <var>interferingTxns</var> is not the empty set, then:<ol><li>Invalidate the transaction set for atomics.</li><li>Add (<var>t</var>, <code>"Invalid"</code>, <var>block</var>, <var>byteIndex</var>, <var>elementSize</var>) to the transaction set.</li><li>Leave the Memory Critical Section.</li><li>Return <var>t</var>.</li></ol></li><li>Assert: <var>atomicTxns</var> is the empty set.</li><li>Add (<var>t</var>, <code>"Atomic"</code>, <var>block</var>, <var>byteIndex</var>, <var>elementSize</var>) to the transaction set.</li><li>Leave the Memory Critical Section.</li><li>Return <var>t</var>.
        </li></ol></emu-alg>

        <emu-note><span class="note">Note 1</span>
          <p>Here and in <emu-xref aoid="BeginNonAtomic"><a href="#Atomics.BeginNonAtomic">BeginNonAtomic</a></emu-xref>, we implement the rule that an atomic access will be invalidated by a concurrent non-atomic read that overlaps with the atomic access, but will not be invalidated by a concurrent non-atomic read that matches the atomic access.</p>
        </emu-note>

        <emu-note><span class="note">Note 2</span>
          <p>(Spec draft note)</p>

          <p>An argument could be made for making non-disjoint non-atomic accesses always invalidate the atomic access, and not have the special case here where matching non-atomic reads are allowed.  In particular, a matching non-atomic read can be used to observe that a non-lock-free atomic write is not  executed atomically.  This is expected in racy programs (and this is a race), so maybe it is no big deal, but it seems unnecessary to consider the atomic operation viable in that situation.</p>

          <p>A stronger rule than we have now, but weaker than the preceding paragraph suggests, is to make  a read that matches an atomic write break viability for the atomic operation, but allow the conflict between a non-atomic read and an atomic read.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="Atomics.EndAtomic" aoid="EndAtomic">
        <h1><span class="secnum">7.4.1.1.7</span>EndAtomic(<var>timestamp</var>)<span class="utils"><span class="anchor"><a href="#Atomics.EndAtomic">#</a></span></span></h1>
        <p>EndAtomic takes a timestamp value <var>timestamp</var> and does the following:</p>

        <emu-alg><ol><li>Enter the Memory Critical Section.</li><li>Let <var>txn</var> be the transaction in the transaction set with timestamp <var>timestamp</var>.</li><li>Assert: <var>txn</var> exists and is an atomic transaction.</li><li>Remove <var>txn</var> from the transaction set.</li><li>Let <var>block</var>, <var>byteIndex</var>, and <var>elementSize</var> be those fields of the transaction.</li><li>Let <var>interferingTxns</var> be the set of transactions in the transaction set that are not disjoint from (<var>block</var>, <var>byteIndex</var>, <var>elementSize</var>).</li><li>Remove transactions that match (<var>block</var>, <var>byteIndex</var>, <var>elementSize</var>) and whose operation is <code>"Read"</code> from <var>interferingTxns</var>.</li><li>Leave the Memory Critical Section.</li><li>If the operation of <var>txn</var> is <code>"Invalid"</code>, then:<ol><li>Return <emu-val>false</emu-val>.</li></ol></li><li>Assert: <var>interferingTxns</var> is the empty set.</li><li>Return <emu-val>true</emu-val>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="Atomics.BeginNonAtomic" aoid="BeginNonAtomic">
        <h1><span class="secnum">7.4.1.1.8</span>BeginNonAtomic(<var>op</var>, <var>block</var>, <var>byteIndex</var>, <var>elementSize</var>)<span class="utils"><span class="anchor"><a href="#Atomics.BeginNonAtomic">#</a></span></span></h1>
        <p>BeginNonAtomic takes four arguments, a String <var>op</var>, a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> <var>block</var>, a nonnegative integer <var>byteIndex</var>, and a positive integer <var>elementSize</var>, and does the following:</p>

        <emu-alg><ol><li>Enter the Memory Critical Section.</li><li>Let <var>t</var> be the next value from the timestamp stream; advance the stream.</li><li>Add a transaction (<var>t</var>, <var>op</var>, <var>block</var>, <var>byteIndex</var>, <var>elementSize</var>) to the transaction set.</li><li>Let <var>atomicTxns</var> be the set of atomic transactions in the transaction set.</li><li>Let <var>interferingAtomicTxns</var> be the set of transactions in <var>atomicTxns</var> that are not disjoint from (<var>block</var>, <var>byteIndex</var>, <var>elementSize</var>).</li><li>If <var>op</var> is <code>"Read"</code> then:<ol><li>Remove transactions that match (<var>block</var>, <var>byteIndex</var>, <var>elementSize</var>) from <var>interferingAtomicTxns</var>.</li></ol></li><li>If <var>interferingAtomicTxns</var> is not the empty set then:<ol><li>Invalidate the transaction set for atomics.</li></ol></li><li>Leave the Memory Critical Section.</li><li>Return <var>t</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="Atomics.EndNonAtomic" aoid="EndNonAtomic">
        <h1><span class="secnum">7.4.1.1.9</span>EndNonAtomic(<var>timestamp</var>)<span class="utils"><span class="anchor"><a href="#Atomics.EndNonAtomic">#</a></span></span></h1>
        <p>EndNonAtomic takes a timestamp value <var>timestamp</var> and does the following:</p>

        <emu-alg><ol><li>Enter the Memory Critical Section.</li><li>Let <var>txn</var> the transaction in the transaction set with timestamp <var>timestamp</var>.</li><li>Assert: <var>txn</var> exists and is a non-atomic transaction.</li><li>Remove <var>txn</var> from the transaction set.</li><li>Leave the Memory Critical Section.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="Atomics.NonAtomicRead" aoid="NonAtomicRead">
        <h1><span class="secnum">7.4.1.1.10</span>NonAtomicRead(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>elementSize</var>)<span class="utils"><span class="anchor"><a href="#Atomics.NonAtomicRead">#</a></span></span></h1>

        <p>NonAtomicRead takes four arguments, a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> <var>block</var>, a nonnegative integer <var>byteIndex</var>, a Boolean <var>accessAtomic</var>, and a positive integer <var>elementSize</var>. The following steps are taken:</p>

        <emu-alg><ol><li>Let <var>timestamp</var> be <emu-xref aoid="BeginNonAtomic"><a href="#Atomics.BeginNonAtomic">BeginNonAtomic</a></emu-xref>(<code>"Read"</code>, <var>block</var>, <var>byteIndex</var>, <var>elementSize</var>).</li><li>Let <var>rawValue</var> be <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref>(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>elementSize</var>).</li><li>Perform <emu-xref aoid="EndNonAtomic"><a href="#Atomics.EndNonAtomic">EndNonAtomic</a></emu-xref>(<var>timestamp</var>).</li><li>Assert: <var>rawValue</var> is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of size <var>elementSize</var>.</li><li>Let <var>r</var> be a Number constructed from <var>rawValue</var> as for <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>. (TODO: Elucidate.)</li><li>Return <var>r</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="Atomics.NonAtomicWrite" aoid="NonAtomicWrite">
        <h1><span class="secnum">7.4.1.1.11</span>NonAtomicWrite(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>elementSize</var>, <var>rawBytes</var>)<span class="utils"><span class="anchor"><a href="#Atomics.NonAtomicWrite">#</a></span></span></h1>

        <p>NonAtomicWrite takes five arguments, a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> <var>block</var>, a nonnegative integer <var>byteIndex</var>, a Boolean <var>accessAtomic</var>, a positive integer <var>elementSize</var>, and a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> <var>rawBytes</var> of <var>elementSize</var>. The following steps are taken:</p>

        <emu-alg><ol><li>Let <var>timestamp</var> be <emu-xref aoid="BeginNonAtomic"><a href="#Atomics.BeginNonAtomic">BeginNonAtomic</a></emu-xref>(<code>"Write"</code>, <var>block</var>, <var>byteIndex</var>, <var>elementSize</var>).</li><li>Perform <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref>(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>elementSize</var>, <var>rawBytes</var>).</li><li>Perform <emu-xref aoid="EndNonAtomic"><a href="#Atomics.EndNonAtomic">EndNonAtomic</a></emu-xref>(<var>timestamp</var>).
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="Atomics.AtomicRead" aoid="AtomicRead">
        <h1><span class="secnum">7.4.1.1.12</span>AtomicRead(<var>buffer</var>, <var>byteIndex</var>, <var>type</var>)<span class="utils"><span class="anchor"><a href="#Atomics.AtomicRead">#</a></span></span></h1>

        <p>AtomicRead takes three arguments, a SharedArrayBuffer <var>buffer</var>, a nonnegative integer <var>byteIndex</var>, and a String <var>type</var>.  The following steps are taken:</p>

        <emu-alg><ol><li>Assert: There are sufficient bytes in <var>buffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for Element Type <var>type</var>.</li><li>Let <var>timestamp</var> be <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref>(<var>block</var>, <var>byteIndex</var>, <var>elementSize</var>).</li><li>Let <var>rawValue</var> be <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref>(<var>block</var>, <var>byteIndex</var>, <emu-val>true</emu-val>, <var>elementSize</var>).</li><li>Let <var>success</var> be <emu-xref aoid="EndAtomic"><a href="#Atomics.EndAtomic">EndAtomic</a></emu-xref>(<var>timestamp</var>).</li><li>Note: If <var>success</var> is <emu-val>true</emu-val> then the <emu-xref aoid="AtomicRead"><a href="#Atomics.AtomicRead">AtomicRead</a></emu-xref> is viable: it executed atomically in the cluster-wide total order.</li><li>Assert: <var>rawValue</var> is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of size <var>elementSize</var>.</li><li>Let <var>r</var> be a Number constructed from <var>rawValue</var> as for <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>. (TODO: Elucidate.)</li><li>Return <var>r</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="Atomics.AtomicWrite" aoid="AtomicWrite">
        <h1><span class="secnum">7.4.1.1.13</span>AtomicWrite(<var>buffer</var>, <var>byteIndex</var>, <var>type</var>, <var>v</var>)<span class="utils"><span class="anchor"><a href="#Atomics.AtomicWrite">#</a></span></span></h1>

        <p>AtomicWrite takes four arguments, a SharedArrayBuffer <var>buffer</var>, a nonnegative integer <var>byteIndex</var>, a String <var>type</var>, and a Number <var>v</var>.  The following steps are taken:</p>

        <emu-alg><ol><li>Assert: There are sufficient bytes in <var>buffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for Element Type <var>type</var>.</li><li>Let <var>rawBytes</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of size <var>elementSize</var> bytes constructed from <var>v</var> as for <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>. (TODO: Elucidate.)</li><li>Let <var>timestamp</var> be <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref>(<var>block</var>, <var>byteIndex</var>, <var>elementSize</var>).</li><li>Perform <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref>(<var>block</var>, <var>byteIndex</var>, <emu-val>true</emu-val>, <var>elementSize</var>, <var>rawBytes</var>).</li><li>Let <var>success</var> be <emu-xref aoid="EndAtomic"><a href="#Atomics.EndAtomic">EndAtomic</a></emu-xref>(<var>timestamp</var>).</li><li>Note: If <var>success</var> is <emu-val>true</emu-val> then the <emu-xref aoid="AtomicWrite"><a href="#Atomics.AtomicWrite">AtomicWrite</a></emu-xref> is viable: it executed atomically in the cluster-wide total order.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="Atomics.AtomicReadModifyWrite" aoid="AtomicReadModifyWrite">
        <h1><span class="secnum">7.4.1.1.14</span>AtomicReadModifyWrite(<var>buffer</var>, <var>byteIndex</var>, <var>type</var>, <var>op</var>, <var>v</var>)<span class="utils"><span class="anchor"><a href="#Atomics.AtomicReadModifyWrite">#</a></span></span></h1>

        <p>AtomicReadModifyWrite takes five arguments, a SharedArrayBuffer <var>buffer</var>, a nonnegative integer <var>byteIndex</var>, a String <var>type</var>, a semantic function <var>op</var>, and a Number <var>v</var>.  The following steps are taken:</p>

        <emu-alg><ol><li>Assert: There are sufficient bytes in <var>buffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for Element Type <var>type</var>.</li><li>Let <var>timestamp</var> be <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref>(<var>block</var>, <var>byteIndex</var>, <var>elementSize</var>).</li><li>Let <var>rawValue</var> be <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref>(<var>block</var>, <var>byteIndex</var>, <emu-val>true</emu-val>, <var>elementSize</var>).</li><li>Assert: <var>rawValue</var> is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of size <var>elementSize</var>.</li><li>Let <var>r</var> be a Number constructed from <var>rawValue</var> as for <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>. (TODO: Elucidate.)</li><li>Compute: Let <var>w</var> be <var>op</var>(<var>r</var>, <var>v</var>).</li><li>Let <var>rawBytes</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of size <var>elementSize</var> bytes constructed from <var>w</var> as for <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>. (TODO: Elucidate.)</li><li>Perform <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref>(<var>block</var>, <var>byteIndex</var>, <emu-val>true</emu-val>, <var>elementSize</var>, <var>rawBytes</var>).</li><li>Let <var>success</var> be <emu-xref aoid="EndAtomic"><a href="#Atomics.EndAtomic">EndAtomic</a></emu-xref>(<var>timestamp</var>).</li><li>Note: If <var>success</var> is <emu-val>true</emu-val> then the <emu-xref aoid="AtomicReadModifyWrite"><a href="#Atomics.AtomicReadModifyWrite">AtomicReadModifyWrite</a></emu-xref> is viable: it executed atomically in the cluster-wide total order.</li><li>Return <var>r</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="Atomics.AtomicCompareExchange" aoid="AtomicCompareExchange">
        <h1><span class="secnum">7.4.1.1.15</span>AtomicCompareExchange(<var>buffer</var>, <var>byteIndex</var>, <var>type</var>, <var>expected</var>, <var>replacement</var>)<span class="utils"><span class="anchor"><a href="#Atomics.AtomicCompareExchange">#</a></span></span></h1>

        <p>AtomicCompareExchange takes five arguments, a SharedArrayBuffer <var>buffer</var>, a nonnegative integer <var>byteIndex</var>, a String <var>type</var>, and two Numbers <var>expected</var> and <var>replacement</var>.  The following steps are taken:</p>

        <emu-alg><ol><li>Assert: There are sufficient bytes in <var>buffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for Element Type <var>type</var>.</li><li>Let <var>timestamp</var> be <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref>(<var>block</var>, <var>byteIndex</var>, <var>elementSize</var>).</li><li>Let <var>rawValue</var> be <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref>(<var>block</var>, <var>byteIndex</var>, <emu-val>true</emu-val>, <var>elementSize</var>).</li><li>Assert: <var>rawValue</var> is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of size <var>elementSize</var>.</li><li>Let <var>r</var> be a Number constructed from <var>rawValue</var> as for <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>. (TODO: Elucidate.)</li><li>If <var>r</var> is the same as <var>expected</var> then:<ol><li>Let <var>rawBytes</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of size <var>elementSize</var> bytes constructed from <var>replacement</var> as for <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>. (TODO: Elucidate.)</li><li>Perform <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref>(<var>block</var>, <var>byteIndex</var>, <emu-val>true</emu-val>, <var>elementSize</var>, <var>rawBytes</var>).</li></ol></li><li>Let <var>success</var> be <emu-xref aoid="EndAtomic"><a href="#Atomics.EndAtomic">EndAtomic</a></emu-xref>(<var>timestamp</var>).</li><li>Note: If <var>success</var> is <emu-val>true</emu-val> then the <emu-xref aoid="AtomicCompareExchange"><a href="#Atomics.AtomicCompareExchange">AtomicCompareExchange</a></emu-xref> is viable: it executed atomically in the cluster-wide total order.</li><li>Return <var>r</var>
        </li></ol></emu-alg>
      </emu-clause>

    </emu-clause>

    <emu-clause id="AtomicsObject.PropertiesOfMemModel">
      <h1><span class="secnum">7.4.1.2</span>Properties of the Memory Model<span class="utils"><span class="anchor"><a href="#AtomicsObject.PropertiesOfMemModel">#</a></span></span></h1>

      <emu-note><span class="note">Note</span>
        <p>(Spec draft note) 

        </p><p>This section states properties that follow from the memory model, it does not introduce any new semantics.  It is probably useful to have this section in some form in the final spec, though not necessarily in the form it has now.</p>
      </emu-note>

      <emu-clause id="AtomicsObject.Properties2">
        <h1><span class="secnum">7.4.1.2.1</span>Properties of Memory Operations<span class="utils"><span class="anchor"><a href="#AtomicsObject.Properties2">#</a></span></span></h1>

        <p>The following properties of the memory operations hold (in the absence of other interfering operations).  For details, see the definitions of <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref>, <emu-xref aoid="EndAtomic"><a href="#Atomics.EndAtomic">EndAtomic</a></emu-xref>, <emu-xref aoid="BeginNonAtomic"><a href="#Atomics.BeginNonAtomic">BeginNonAtomic</a></emu-xref>, <emu-xref aoid="EndNonAtomic"><a href="#Atomics.EndNonAtomic">EndNonAtomic</a></emu-xref>, <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref>, and <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref>.</p>

        <p>The system of memory operations always makes progress (does not deadlock).</p>

        <emu-note><span class="note">Note 1</span>
          <p>The only of the memory operation steps to wait is <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref>, which waits while the transaction set contains a transaction <var>T</var> for an ongoing, matching or disjoint, atomic operation <var>O</var>.  Since <var>T</var> was stored into the transaction set following a possible wait, <var>O</var> will be making progress and will reach its <emu-xref aoid="EndAtomic"><a href="#Atomics.EndAtomic">EndAtomic</a></emu-xref> step, unless an interfering operation starts first and changes the operation of <var>T</var> to <code>"Invalid"</code>, thus changing the set of atomic transactions in the transaction set.  In either case <var>O</var> is released from the wait.</p>
        </emu-note>

        <p>If a non-atomic write conflicts with an atomic operation then the atomic operation is not viable.</p>

        <emu-note><span class="note">Note 2</span>
          <p>Suppose the non-atomic operation starts first.  <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref> will detect that there is a conflicting write in the transaction set and will add an <code>"Invalid"</code> atomic transaction.  Suppose the atomic operation starts first.  <emu-xref aoid="BeginNonAtomic"><a href="#Atomics.BeginNonAtomic">BeginNonAtomic</a></emu-xref> will detect that there is an atomic transaction with operation <code>"Atomic"</code> and that the write is not disjoint with the atomic transaction, and will change the operation of the atomic transaction to <code>"Invalid"</code>.  In either case <emu-xref aoid="EndAtomic"><a href="#Atomics.EndAtomic">EndAtomic</a></emu-xref> will see an <code>"Invalid"</code> operation for its transaction and return <emu-val>false</emu-val>, making the atomic non-viable.</p>
        </emu-note>

        <p>If a non-atomic read is concurrent with an atomic operation and the two operations match or are disjoint, then the atomic operation is viable.</p>

        <emu-note><span class="note">Note 3</span>
          <p>This is like the non-atomic write case, but since the non-atomic operation is a matching or disjoint read, neither will <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref> add an <code>"Invalid"</code> atomic transaction, nor will <emu-xref aoid="BeginNonAtomic"><a href="#Atomics.BeginNonAtomic">BeginNonAtomic</a></emu-xref> invalidate any existing atomic transactions.  Hence <emu-xref aoid="EndAtomic"><a href="#Atomics.EndAtomic">EndAtomic</a></emu-xref> will see an <code>"Atomic"</code> operation for its transaction and return <emu-val>true</emu-val>.</p>
        </emu-note>

        <p>If a non-atomic read conflicts with an atomic operation and the two operations overlap then the atomic operation is not viable.</p>

        <emu-note><span class="note">Note 4</span>
          <p>This is like the non-atomic write case above: an overlapping read is considered interfering.</p>
        </emu-note>

        <p>If two atomic operations are concurrent and do not overlap then they are both viable, and executed one after the other.</p>

        <emu-note><span class="note">Note 5</span>
          <p>The <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref> calls are ordered by the Memory Critical Section.  The first will leave the critical section having added an <code>"Atomic"</code> transaction and having asserted that it is now the only atomic transaction in the set.  The second call will enter the critical section and determine that there is exactly one <code>"Atomic"</code> transaction and that is matching or disjoint, and enter a wait until the set of atomic transactions changes (leaving the critical section).  Meanwhile the first agent makes progress and eventually calls <emu-xref aoid="EndAtomic"><a href="#Atomics.EndAtomic">EndAtomic</a></emu-xref>, which removes its <code>"Atomic"</code> transaction and returns <emu-val>true</emu-val> (indicating viability).  That breaks the wait for the second atomic, which now is alone, and therefore trivially viable, and also clearly executes after the first atomic is done.</p>
        </emu-note>

        <p>If two atomic operations aren't concurrent then they are both viable.</p>

        <emu-note><span class="note">Note 6</span>
          <p>The first of the operations calls <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref> and <emu-xref aoid="EndAtomic"><a href="#Atomics.EndAtomic">EndAtomic</a></emu-xref> before the second calls <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref>.  Hence both <emu-xref aoid="EndAtomic"><a href="#Atomics.EndAtomic">EndAtomic</a></emu-xref> calls return <emu-val>true</emu-val>, indicating viability.</p>
        </emu-note>

        <p>If two or more atomic operations conflict and overlap then none are viable; and, if an atomic operation is concurrent with a non-viable atomic then the former atomic is also non-viable.</p>

        <emu-note><span class="note">Note 7</span>
          <p>The first <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref> adds an <code>"Atomic"</code> transaction, after which it is the only atomic transaction in the set. The second <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref> will not wait (because the operations overlap) and will discover that it overlaps an existing transaction whose operation is not <code>"Read"</code>.  It will then invalidate all atomic transactions and add its own <code>"Invalid"</code> transaction.  Now either the first operation calls <emu-xref aoid="EndAtomic"><a href="#Atomics.EndAtomic">EndAtomic</a></emu-xref> first or the second operation does.  In both cases, since the second <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref> altered both atomic transactions to <code>"Invalid"</code>, <emu-xref aoid="EndAtomic"><a href="#Atomics.EndAtomic">EndAtomic</a></emu-xref> will see an operation of <code>"Invalid"</code> for its transaction, returning <emu-val>false</emu-val> for both operations, making neither viable.</p>

          <p>This generalizes to multiple conflicting atomic operations, even when they only overlap pairwise: the presence of an <code>"Invalid"</code> atomic transaction in the set ensures that a new operation also becomes non-viable.</p>

          <p>The above is true even if the overlapping operations are reads; see  <emu-xref href="#AtomicsObject.Formalization"><a href="#AtomicsObject.Formalization">7.4.1.1.2</a></emu-xref> for a discussion.</p>
        </emu-note>

        <p>Non-viable atomic operations have the same memory effects as corresponding non-atomic operations on the same TypedArrays.</p>

        <emu-note><span class="note">Note 8</span>
          <p>The only effect of <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref>, <emu-xref aoid="EndAtomic"><a href="#Atomics.EndAtomic">EndAtomic</a></emu-xref>, <emu-xref aoid="BeginNonAtomic"><a href="#Atomics.BeginNonAtomic">BeginNonAtomic</a></emu-xref>, and <emu-xref aoid="EndNonAtomic"><a href="#Atomics.EndNonAtomic">EndNonAtomic</a></emu-xref> is that <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref> serializes non-overlapping atomic operations by pausing an operation until a previous operation is finished.  A non-viable atomic operation may or may not execute this wait step; if it does, the wait step will be aborted early.  Either way, the effect will be that <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref> will not wait until some concurrent, overlapping access is finished, and so <emu-xref aoid="BeginAtomic"><a href="#Atomics.BeginAtomic">BeginAtomic</a></emu-xref> will effectively be a no-op.  This makes all four of those semantic operations no-ops, as far as memory effects are concerned.  The callers of those operations all defer the actual work to <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref> and <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref>, with <var>accessAtomic</var> <emu-val>true</emu-val>.  Hence non-viable atomics (eg <code>Atomics.store(ta, k, v)</code> or <code>Atomics.add(ta, k, v)</code>) and corresponding non-atomics (eg <code>ta[k]=v</code> or <code>ta[k] += v</code>) have the same memory effects.</p>
        </emu-note>

      </emu-clause>

      <emu-clause id="AtomicsObject.Implementability">
        <h1><span class="secnum">7.4.1.2.2</span>Implementability of the Semantics<span class="utils"><span class="anchor"><a href="#AtomicsObject.Implementability">#</a></span></span></h1>

        <p>The claim is that atomic operations that are deemed viable in the semantics of  <emu-xref href="#AtomicsObject.MemoryModel"><a href="#AtomicsObject.MemoryModel">7.4.1.1</a></emu-xref> will always be observed as being executed atomically and in some total order (within the agent cluster) on hardware, for any mix of lock-free and non-lock-free viable atomics, using  conventional implementations of sequentially consistent atomics on each platform.</p>

        <emu-note><span class="note">Note</span>
          <p>(Spec draft note)</p>

          <p>This is the first attempt.  This is fairly elaborate and a little messy, but the idea is to establish first that lock-free atomics "just work" on all platforms and then to argue that non-lock-free atomics fit properly into it.  The hardware discussion may not need to discuss local reorderings; I'm not sure.</p>
        </emu-note>

        <p>The claim begs the question of the nature of the observer and its method of observation.  The observers must be additional agents in the system that always agree on the order in which updates become visible to them.  A meaningful mechanism for the observation seems to be a non-atomic (yet access-atomic) read whenever the observed atomic is lock-free, and a non-blocking lock acquisition whenever the observed atomic is non-lock-free (ie a failure to take the lock means the value has not yet changed).  As a thought experiment, imagine there are four agents, two of them perform atomic operations on separate atomics, the other two record the observed order of changes by looking first for changes to one atomic and then checking to see if the other have changed (one examining the atomics in one order, the other examining them in the other order.)  Both observers should see compatible orders always.</p>

        <p>When necessary we will use x86 and ARMv7 as our sample architectures.  For practical purposes, SPARC is equivalent to x86, and POWER, MIPS, and Itanium are equivalent to ARMv7.</p>

        <p>Observe first that if all the atomic sizes have lock-free implementations then the argument is straightforward and can rely on the memory system as the observer:</p>

        <ul>
          <li> On x86, an atomic load is a <code>MOV</code>, an atomic store is a <code>MOV</code> followed by <code>MFENCE</code>, an atomic read-modify-write is a <code>LOCK</code>-prefixed arithmetic operation, and an atomic compare-exchange is a <code>LOCK</code>-prefixed <code>CMPXCHG</code>.  The <code>MFENCE</code> after the atomic store and look-ahead in the write buffer for loads prevent local reordering.  The <code>LOCK</code>s ensure atomicity of read-write operations.  Access-atomicity in the hardware ensures that loads and stores don't tear and ensure that operations to memory happen in a total order.  That is, x86 has stronger semantics than we require. 

          </li><li> On ARMv7, atomics are preceded and succeeded by <code>DMB</code> instructions that prevent local reordering.  Between the two <code>DMB</code>s, an atomic load is an <code>LDR</code>, an atomic store an <code>STR</code>, and atomic read-modify-write and compare-exchange are written as loops using <code>LDREX</code> and <code>STREX</code> to ensure atomicity of the read-write pair (any interfering store from another CPU will make the <code>STREX</code> fail and cause the loaded value to be discarded).  Access-atomicity in the hardware ensures that accesses don't tear and ensure that operations to memory happen in a total order.  Like x86, ARM has stronger semantics than we require.
        
        </li></ul>

        <p>Suppose that we also have non-lock-free atomics for some sizes.  To make it interesting, assume we have non-lock-free <code>Float64</code> atomics, since some CPUs may load and store floating values one byte at a time (ARM allows this).  There will be a lock (either per SharedArrayBuffer, or per region of memory) that is acquired by the atomic operation before the operation and released after.  Assuming an operation <var>A</var> is viable, we need to show that a concurrent viable atomic operation <var>B</var> is perceived as executing before or after <var>A</var>.  If <var>B</var> is to the same access range as <var>A</var> then <var>B</var> will wait for the lock, and <var>B</var> will clearly execute after <var>A</var>.  If <var>B</var> is to a disjoint access range from <var>A</var> then the memory transactions from the two (including the transactions for lock and unlock) may actually execute interleaved, however.  This is the interesting case, because the semantics model this as a blocking wait for whichever operation starts second, but the implementation can't do that.</p>

        <p>Assume first that <var>A</var> is lock-free.  <var>A</var> will be executed as a single memory transaction.</p>
        <ul>
          <li>Assume <var>A</var> occurs before the lock for <var>B</var>.  The observer that observes <var>A</var> before <var>B</var> will see the change to <var>A</var> and sometimes that <var>B</var> has not changed; ergo, <var>A</var> first.  The observer that observes <var>B</var> before <var>A</var> will see the change to <var>B</var> first and always that <var>A</var> has changed; inconclusive.  In sum, <var>A</var> first.
          
          </li><li> For the case where <var>A</var> occurs after the unlock for <var>B</var>, the same argument, but <var>B</var> first.
          
          </li><li> Assume that <var>A</var> occurs between the lock and the unlock for <var>B</var>.  The observer that observes <var>A</var> before <var>B</var> will sometimes observe that <var>B</var> has not changed (it will fail to aquire the lock on <var>B</var>); ergo <var>A</var> before <var>B</var>.  The observer that observes <var>B</var> before <var>A</var> will always observe that <var>A</var> has changed; inconclusive.  In sum, <var>A</var> first.
        
        </li></ul>

        <p>Assume next that <var>A</var> and <var>B</var> are both non-lock-free, with different locks (or the result is trivial).  The lock and unlock operations are themselves atomic memory operations and part of the memory system's total order of operations.  The interesting cases are when the lock/unlock pair for <var>A</var> overlaps partially with the lock/unlock pair for <var>B</var>, and when the lock/unlock pair for <var>A</var> is wholly within the lock/unlock pair for <var>B</var>.</p>
        <ul>
          <li>Assume the lock/unlock pairs overlap and that <var>A</var>'s lock is acquired and released first.  The agent observing <var>A</var> before <var>B</var> will observe that <var>A</var> has changed and that sometimes, <var>B</var> has not; hence <var>A</var> before <var>B</var>.  The agent observing <var>B</var> before <var>A</var> will always observe that <var>A</var> has changed once <var>B</var> has changed; inconclusive.  In sum, <var>A</var> first.
          
          </li><li>Assume <var>A</var>'s lock/unlock pair is nested within <var>B</var>'s.  The agent observing <var>A</var> before <var>B</var> will observe that when <var>A</var> has changed, <var>B</var> sometimes has not; hence <var>A</var> before <var>B</var>.  The agent observing <var>B</var> before <var>A</var> will observe that when <var>B</var> has changed, <var>A</var> also has; hence inconclusive.  In sum, <var>A</var> first.
        
        </li></ul>

        <p>In effect, we can say that it is the unlock operation of a non-lock-free atomic that enters into the total order of viable atomic operations.</p>
      </emu-clause>

      <emu-clause id="AtomicsObject.EventsAndSync">
        <h1><span class="secnum">7.4.1.2.3</span>Events, Synchronization, Data Races, and Sequential Consistency<span class="utils"><span class="anchor"><a href="#AtomicsObject.EventsAndSync">#</a></span></span></h1>

        <p>An  <em>event</em> in an agent is either a  <em>synchronizing event</em> (a viable atomic operation or the communication action it represents) or a  <em>non-synchronizing event</em> (a non-viable atomic operation or a non-atomic operation).</p>

        <p>A  <em>program order</em> of an agent is a total ordering of the agent's events that is consistent with the semantics of the ECMAScript program running in that agent.</p>

        <emu-note><span class="note">Note 1</span>
          <p>There are usually many possible legal program orders for a program, representing legal transformations of the program.  Note that transformations may be dynamic, and multiple executions of a program fragment may give rise to different sequences of events.</p>
        </emu-note>

        <p>An  <em>execution</em> of an agent cluster is a partial ordering of the agents' events that is consistent with each agent's program order.</p>

        <p>Synchronizing events in an execution will be performed in a total order -- known as the  <em>synchronization order</em> for the execution -- that is consistent with each agent's program order.</p>

        <emu-note><span class="note">Note 2</span>
          <p>The total order exists by construction: viable atomic operations are executed in a total order, and only viable atomic operations are part of the synchronization order.</p>
        </emu-note>

        <p>The synchronization order induces a  <em>synchronized-with</em> relation on events for the execution: A viable atomic write of a location synchronizes-with all subsequent (later in the synchronization order) viable atomic reads of that location.</p>

        <emu-note><span class="note">Note 3</span>
          <p>Since there is aliasing, it is possible for (say) a two-byte write to be observed by two subsequent one-byte reads, or for two one-byte writes to be observed by a subsequent two-byte read, or indeed for a one-byte write to be observed by a subsequent two-byte read.  Despite there not being a clean one-to-one relationship between writes and reads, the writes synchronize-with the subsequent reads in all those cases.</p>
        </emu-note>

        <p>An event A  <em>happens before</em> another event B in an execution if either:</p>

        <ul>
          <li>A precedes B in an agent's program order,
          
          </li><li>A synchronizes-with B, or
          
          </li><li>A happens before C and C happens before B (transitivity).
        
        </li></ul>

        <p>Executions must be such that  <em>happens before</em> is irreflexive (acyclic).</p>

        <p>Two memory operations constitute a  <em>data race</em> if neither happens before the other, at least one of them is a write, and either they overlap, or they match but are not both viable atomic operations.</p>

        <emu-note><span class="note">Note 4</span>
          <p>An execution that is free of data races will also be free of conflicts (except conflicts between matching atomic operations, all of which will be viable, and conflicts between atomics that match non-atomic reads) and will appear to be sequentially consistent.</p>
        </emu-note>

        <p>If every execution of an agent cluster is free of data races then the agent cluster will appear to be sequentially consistent.</p>

        <emu-note><span class="note">Note 5</span>
          <p>If the agent cluster appears sequentially consistent it is not necessary for the programmer to reason about program transformations.</p>

          <p>Data races expose non-intuitive and platform-specific effects of program transformations performed by the compiler or the hardware.  ECMAScript programs with data races are safe (races cannot subvert the language implementation, they affect only the memory locations in Shared Data Blocks), but the values resulting from a program with a data race are often hard to predict.  The effects of data races include observing values that, within limits, appear to come from the past (because they should have been written before other values, which have not been seen) or from the future (because they should have been written after other values, which have not been seen), or which should not exist at all (because conflicting writes may interleave the bytes being written).</p>
        </emu-note>

        <p>If a program has a data race, the semantics guarantee two things.  First, if the racing accesses are all integer-typed TypedArray accesses and all have the same access size then the writes that race will be performed in some order (their values will not be mixed somehow) and the reads that race will observe one of the writes or the value in memory before any of the writes (if there are multiple reads they may observe different values).  Second, if the values that are written are mixed then they are mixed at the byte level (as opposed to the bit level), and all bytes of all the racing writes will eventually be written to memory in their correct locations, in an unspecified order.</p>
      </emu-clause>

    </emu-clause>

    <emu-clause id="Atomics.ValidateSharedIntegerTypedArray" aoid="ValidateSharedIntegerTypedArray">
      <h1><span class="secnum">7.4.1.3</span>ValidateSharedIntegerTypedArray(<var>typedArray</var> [, <var>onlyInt32</var>] )<span class="utils"><span class="anchor"><a href="#Atomics.ValidateSharedIntegerTypedArray">#</a></span></span></h1>
      <emu-alg><ol><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>typedArray</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>typedArray</var> does not have a [[TypedArrayName]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>typeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>If <var>onlyInt32</var> is <emu-val>true</emu-val> then<ol><li>If <var>typeName</var> is not <code>"Int32Array"</code> then throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>Else<ol><li>If <var>typeName</var> is not <code>"Int8Array"</code>, <code>"Uint8Array"</code>, <code>"Int16Array"</code>, <code>"Uint16Array"</code>, <code>"Int32Array"</code>, or <code>"Uint32Array"</code> then throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>If <var>typedArray</var> does not have a [[ViewedArrayBuffer]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>buffer</var> be <var>typedArray</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>buffer</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>buffer</var> does not have an [[ArrayBufferData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return <var>buffer</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.ValidateAtomicAccess" aoid="ValidateAtomicAccess">
      <h1><span class="secnum">7.4.1.4</span>ValidateAtomicAccess( <var>typedArray</var>, <var>requestIndex</var> )<span class="utils"><span class="anchor"><a href="#Atomics.ValidateAtomicAccess">#</a></span></span></h1>
      <p>Perform the following steps:</p>
      <emu-alg><ol><li>Assert: <var>typedArray</var> is an Object that has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>numberIndex</var> be ? <emu-xref aoid="ToNumber"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>requestIndex</var>).</li><li>Let <var>accessIndex</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>numberIndex</var>).</li><li>If <var>numberIndex</var> ≠ <var>accessIndex</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>length</var> be <var>typedArray</var>.[[ArrayLength]].</li><li>If <var>accessIndex</var> &lt; 0 or <var>accessIndex</var> ≥ <var>length</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Return <var>accessIndex</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.AgentSignifier" aoid="AgentSignifier">
      <h1><span class="secnum">7.4.1.5</span>AgentSignifier( )<span class="utils"><span class="anchor"><a href="#Atomics.AgentSignifier">#</a></span></span></h1>
      <p>When AgentSignifier is called without arguments then the following steps are taken.</p>
      <emu-alg><ol><li>Let <var>AR</var> be the <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref> of the <em>surrounding agent</em>.</li><li>Let <var>W</var> be <var>AR</var>.[[Signifier]].</li><li>Return <var>W</var>.
      </li></ol></emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.AgentCanSuspend" aoid="AgentCanSuspend">
      <h1><span class="secnum">7.4.1.6</span>AgentCanSuspend( )<span class="utils"><span class="anchor"><a href="#Atomics.AgentCanSuspend">#</a></span></span></h1>
      <p>When AgentCanSuspend is called without arguments then the following steps are taken.</p>
      <emu-alg><ol><li>Let <var>AR</var> be the <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref> of the <em>surrounding agent</em>.</li><li>Let <var>B</var> be <var>AR</var>.[[CanBlock]].</li><li>Return <var>B</var>.
      </li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p>In some environments it may not be reasonable for a given agent to suspend.  For example,
          in a web browser environment, it may be reasonable to disallow suspending a document's main event
          handling thread, while still allowing workers' event handling threads to suspend.</p>
      </emu-note>

    </emu-clause>

    <emu-clause id="GetWaiterList" aoid="GetWaiterList">
      <h1><span class="secnum">7.4.1.7</span>GetWaiterList( <var>block</var>, <var>i</var> )<span class="utils"><span class="anchor"><a href="#GetWaiterList">#</a></span></span></h1>
      <p>A  <dfn>WaiterList</dfn> is a semantic object that contains an ordered list of those agents that are waiting on a location (<var>block</var>, <var>i</var>) in shared memory; <var>block</var> is a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> and <var>i</var> a byte offset into the memory of <var>block</var>.</p>
      <p>The agent cluster has a store of WaiterList objects; the store is indexed by (<var>block</var>, <var>i</var>).  WaiterLists are agent-independent: a lookup in the store of WaiterLists by (<var>block</var>, <var>i</var>) will result in the same WaiterList object in any agent in the agent cluster.</p>
      <p>Operations on a WaiterList -- adding and removing waiting agents, traversing the list of agents, suspending and waking agents on the list -- may only be performed by agents that have entered the WaiterList's critical section.</p>
      <p>When GetWaiterList is called with <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> <var>block</var> and nonnegative integer <var>i</var>, then the following steps are taken.</p>
      <emu-alg><ol><li>Assert: <var>block</var> is a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref>.</li><li>Assert: <var>i</var> and <var>i</var>+3 are valid byte offsets within the memory of <var>block</var>.</li><li>Assert: <var>i</var> is divisible by 4.</li><li>Return the <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> that is referenced by the pair (<var>block</var>, <var>i</var>).
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="EnterCriticalSection" aoid="EnterCriticalSection">
      <h1><span class="secnum">7.4.1.8</span>EnterCriticalSection( <var>WL</var> )<span class="utils"><span class="anchor"><a href="#EnterCriticalSection">#</a></span></span></h1>
      <p>When EnterCriticalSection is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var>, then the following steps are taken.</p>
      <emu-alg><ol><li>Assert: The calling agent is not in the critical section for any <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref>.</li><li>Wait until no agent is in the critical section for <var>WL</var>, then enter the critical section for <var>WL</var> (without allowing any other agent to enter).
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="LeaveCriticalSection" aoid="LeaveCriticalSection">
      <h1><span class="secnum">7.4.1.9</span>LeaveCriticalSection( <var>WL</var> )<span class="utils"><span class="anchor"><a href="#LeaveCriticalSection">#</a></span></span></h1>
      <p>When LeaveCriticalSection is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var>, then the following steps are taken.</p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Leave the critical section for <var>WL</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.AddWaiter" aoid="AddWaiter">
      <h1><span class="secnum">7.4.1.10</span>AddWaiter( <var>WL</var>, <var>W</var> )<span class="utils"><span class="anchor"><a href="#Atomics.AddWaiter">#</a></span></span></h1>
      <p>When AddWaiter is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var> and agent signifier <var>W</var>, then the following steps are taken.</p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <var>W</var> is not on the list of waiters in any <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref>.</li><li>Add <var>W</var> to the end of the list of waiters in <var>WL</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.RemoveWaiter" aoid="RemoveWaiter">
      <h1><span class="secnum">7.4.1.11</span>RemoveWaiter( <var>WL</var>, <var>W</var> )<span class="utils"><span class="anchor"><a href="#Atomics.RemoveWaiter">#</a></span></span></h1>
      <p>When RemoveWaiter is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var> and agent signifier <var>W</var>, then the following steps are taken.</p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <var>W</var> is on the list of waiters in <var>WL</var>.</li><li>Remove <var>W</var> from the list of waiters in <var>WL</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.RemoveWaiters" aoid="RemoveWaiters">
      <h1><span class="secnum">7.4.1.12</span>RemoveWaiters( <var>WL</var>, <var>c</var> )<span class="utils"><span class="anchor"><a href="#Atomics.RemoveWaiters">#</a></span></span></h1>
      <p>When RemoveWaiters is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var> and nonnegative integer <var>c</var>, then the following steps are taken.</p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Let <var>L</var> be the empty list.</li><li>Let <var>S</var> be a reference to the list of waiters in <var>WL</var>.</li><li>While <var>c</var> &gt; 0 and <var>S</var> is not the empty list:<ol><li>Let <var>W</var> be the first waiter in <var>S</var>.</li><li>Add <var>W</var> to the end of <var>L</var>.</li><li>Remove <var>W</var> from <var>S</var>.</li><li>Subtract 1 from <var>c</var>.</li></ol></li><li>Return <var>L</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.Suspend" aoid="Suspend">
      <h1><span class="secnum">7.4.1.13</span>Suspend( <var>WL</var>, <var>W</var>, <var>timeout</var> )<span class="utils"><span class="anchor"><a href="#Atomics.Suspend">#</a></span></span></h1>
      <p>When Suspend is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var>, agent signifier <var>W</var>, and nonnegative, non-<emu-val>NaN</emu-val> Number <var>timeout</var>, then the following steps are taken.</p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <var>W</var> is equal to <emu-xref aoid="AgentSignifier"><a href="#Atomics.AgentSignifier">AgentSignifier</a></emu-xref>().</li><li>Assert: <var>W</var> is on the list of waiters in <var>WL</var>.</li><li>Assert: <emu-xref aoid="AgentCanSuspend"><a href="#Atomics.AgentCanSuspend">AgentCanSuspend</a></emu-xref>() is equal to true.</li><li>Perform <emu-xref aoid="LeaveCriticalSection"><a href="#LeaveCriticalSection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>) and suspend <var>W</var> for up to <var>timeout</var> milliseconds, performing the combined operation in such a way that a wakeup that arrives after the critical section is exited but before the suspension takes effect is not lost.  <var>W</var> can wake up either because the timeout expired or because it was woken explicitly by another agent calling <emu-xref aoid="WakeWaiter"><a href="#Atomics.WakeWaiter">WakeWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>), and not for any other reasons at all.</li><li>Perform <emu-xref aoid="EnterCriticalSection"><a href="#EnterCriticalSection">EnterCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>If <var>W</var> was woken explicitly by another agent calling <emu-xref aoid="WakeWaiter"><a href="#Atomics.WakeWaiter">WakeWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>), then return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.WakeWaiter" aoid="WakeWaiter">
      <h1><span class="secnum">7.4.1.14</span>WakeWaiter( <var>WL</var>, <var>W</var> )<span class="utils"><span class="anchor"><a href="#Atomics.WakeWaiter">#</a></span></span></h1>
      <p>When WakeWaiter is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var> and agent signifier <var>W</var>, then the following steps are taken.</p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <var>W</var> is on the list of waiters in <var>WL</var>.</li><li>Wake the agent <var>W</var>.
      </li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p>The embedding may delay waking <var>W</var>, eg for resource management reasons, but <var>W</var> must eventually be woken in order to guarantee forward progress.</p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.FetchOp" aoid="AtomicFetchOp">
      <h1><span class="secnum">7.4.1.15</span>AtomicFetchOp( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>op</var> )<span class="utils"><span class="anchor"><a href="#Atomics.FetchOp">#</a></span></span></h1>
      <p>AtomicFetchOp is a semantic function that atomically loads a value, combines it with another value, and stores the result of the combination.  It returns the loaded value.  It is parameterized by the (pure) combining operation <var>op</var> that takes two Number arguments and returns a Number.  The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>buffer</var> be ? <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>).</li><li>Let <var>i</var> be ? <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>v</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>value</var>).</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var>.</li><li>Let <var>r</var> be <emu-xref aoid="AtomicReadModifyWrite"><a href="#Atomics.AtomicReadModifyWrite">AtomicReadModifyWrite</a></emu-xref>(<var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>op</var>, <var>v</var>)</li><li>Return <var>r</var>.
      </li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p>The combining operation is restricted to addition, subtraction, bitwise and, or, and xor, and argument selection, and the element types are exclusively integer types.  The store in step 9.c truncates any overflowed result by discarding the overflowed bits.  The combined effect is that the computation in step 9.b is a simple integer operation with ignored overflow, and the entire atomic operation in step 9 can be executed with maximal efficiency on all platforms.</p>
    </emu-note></emu-clause>
  </emu-clause> <!-- runtime semantics -->

  <emu-clause id="AtomicsObject.FunctionProps">
    <h1><span class="secnum">7.4.2</span>Function Properties of the Atomics Object<span class="utils"><span class="anchor"><a href="#AtomicsObject.FunctionProps">#</a></span></span></h1>

    <emu-clause id="Atomics.add">
      <h1><span class="secnum">7.4.2.1</span>Atomics.add( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.add">#</a></span></span></h1>
      <p>Let <code>add</code> denote a semantic function of two Number arguments that applies the addition operation to the arguments and returns the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Return <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>(<var>typedArray</var>, <var>index</var>, <var>value</var>, <code>add</code>).
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.and">
      <h1><span class="secnum">7.4.2.2</span>Atomics.and( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.and">#</a></span></span></h1>
      <p>Let <code>and</code> denote a semantic function of two Number arguments that converts both arguments to Int32 by the <emu-xref aoid="ToInt32"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref> operation, then applies the bitwise-and operation to the converted values, and returns the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Return <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>(<var>typedArray</var>, <var>index</var>, <var>value</var>, <code>and</code>).
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.compareExchange">
      <h1><span class="secnum">7.4.2.3</span>Atomics.compareExchange( <var>typedArray</var>, <var>index</var>, <var>expectedValue</var>, <var>replacementValue</var> )<span class="utils"><span class="anchor"><a href="#Atomics.compareExchange">#</a></span></span></h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>buffer</var> be ? <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>).</li><li>Let <var>i</var> be ? <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>expected</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>expectedValue</var>).</li><li>Let <var>replacement</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>replacedValue</var>).</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>convOp</var> be the conversion operation specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>x</var> be <var>convOp</var> (<var>expected</var>).</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var>.</li><li>Let <var>r</var> be <emu-xref aoid="AtomicCompareExchange"><a href="#Atomics.AtomicCompareExchange">AtomicCompareExchange</a></emu-xref>(<var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>x</var>, <var>replacement</var>)</li><li>Return <var>r</var>.
      </li></ol></emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.exchange">
      <h1><span class="secnum">7.4.2.4</span>Atomics.exchange( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.exchange">#</a></span></span></h1>
      <p>Let <code>second</code> denote a semantic function of two Number arguments that returns its second argument.</p>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Return <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>(<var>typedArray</var>, <var>index</var>, <var>value</var>, <code>second</code>).
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.isLockFree">
      <h1><span class="secnum">7.4.2.5</span>Atomics.isLockFree( <var>size</var> )<span class="utils"><span class="anchor"><a href="#Atomics.isLockFree">#</a></span></span></h1>

      <emu-alg><ol><li>Let <var>n</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>size</var>).</li><li>Let <var>AR</var> be the <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref> of the <em>surrounding agent</em>.</li><li>If <var>n</var> equals 1 then return <var>AR</var>.[[IsLockFree1]].</li><li>If <var>n</var> equals 2 then return <var>AR</var>.[[IsLockFree2]].</li><li>If <var>n</var> equals 4 then return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.
      </li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p>Atomics.isLockFree() is an optimization primitive.  The
          intuition is that if the atomic step of an atomic primitive
          (<code>compareExchange</code>, <code>load</code>, <code>store</code>, <code>add</code>, <code>sub</code>, <code>and</code>,
          <code>or</code>, <code>xor</code>, or <code>exchange</code>) on a datum of size <var>n</var> bytes
          will be performed without the calling agent acquiring a lock
          outside the <var>n</var> bytes comprising the datum, then
          Atomics.isLockFree(<var>n</var>) will return <emu-val>true</emu-val>.
          High-performance algorithms will use Atomics.isLockFree to
          determine whether to use locks or atomic operations in
          critical sections.  If an atomic primitive is not lock-free
          then it is often more efficient for an algorithm to provide
          its own locking.</p>

        <p>Atomics.isLockFree(4) always returns <emu-val>true</emu-val> as that can be
          supported on all known relevant hardware.  Being able to
          assume this will generally simplify programs.</p>

      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.load">
      <h1><span class="secnum">7.4.2.6</span>Atomics.load( <var>typedArray</var>, <var>index</var> )<span class="utils"><span class="anchor"><a href="#Atomics.load">#</a></span></span></h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>buffer</var> be ? <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>).</li><li>Let <var>i</var> be ? <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var>.</li><li>Let <var>r</var> be <emu-xref aoid="AtomicRead"><a href="#Atomics.AtomicRead">AtomicRead</a></emu-xref>(<var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>).</li><li>Return <var>r</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.or">
      <h1><span class="secnum">7.4.2.7</span>Atomics.or( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.or">#</a></span></span></h1>
      <p>Let <code>or</code> denote a semantic function of two Number arguments that converts both arguments to Int32 by the <emu-xref aoid="ToInt32"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref> operation, then applies the bitwise-or operation to the converted values, and returns the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Return <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>(<var>typedArray</var>, <var>index</var>, <var>value</var>, <code>or</code>).
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.store">
      <h1><span class="secnum">7.4.2.8</span>Atomics.store( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.store">#</a></span></span></h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>buffer</var> be ? <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>).</li><li>Let <var>i</var> be ? <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>v</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>value</var>).</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var>.</li><li>Perform <emu-xref aoid="AtomicWrite"><a href="#Atomics.AtomicWrite">AtomicWrite</a></emu-xref>(<var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>v</var>).</li><li>Return <var>v</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.sub">
      <h1><span class="secnum">7.4.2.9</span>Atomics.sub( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.sub">#</a></span></span></h1>
      <p>Let <code>subtract</code> denote a semantic function of two Number arguments that applies the subtraction operation to the arguments and returns the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Return <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>(<var>typedArray</var>, <var>index</var>, <var>value</var>, <code>subtract</code>).
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.wait">
      <h1><span class="secnum">7.4.2.10</span>Atomics.wait( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )<span class="utils"><span class="anchor"><a href="#Atomics.wait">#</a></span></span></h1>
      <p>Atomics.wait puts the calling agent in a wait queue and puts it to sleep until it is awoken or the sleep times out. The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>buffer</var> be ? <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>, <emu-val>true</emu-val>).</li><li>Let <var>i</var> be ? <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>v</var> be ? <emu-xref aoid="ToInt32"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref>(<var>value</var>).</li><li>If <var>timeout</var> is not provided or is <emu-val>undefined</emu-val> then let <var>t</var> be <emu-val>+∞</emu-val>.  Otherwise:<ol><li>Let <var>q</var> be ? <emu-xref aoid="ToNumber"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>timeout</var>).</li><li>If <var>q</var> is <emu-val>NaN</emu-val> then let <var>t</var> be <emu-val>+∞</emu-val>, otherwise let <var>t</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(0, <var>q</var>).</li></ol></li><li>Let <var>B</var> be <emu-xref aoid="AgentCanSuspend"><a href="#Atomics.AgentCanSuspend">AgentCanSuspend</a></emu-xref>().</li><li>If <var>B</var> is <emu-val>false</emu-val> then throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>bufferVal</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × 4) + <var>offset</var>.</li><li>Let <var>WL</var> be <emu-xref aoid="GetWaiterList"><a href="#GetWaiterList">GetWaiterList</a></emu-xref>(<var>block</var>, <var>indexedPosition</var>).</li><li>Perform <emu-xref aoid="EnterCriticalSection"><a href="#EnterCriticalSection">EnterCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>Let <var>w</var> be <emu-xref aoid="AtomicRead"><a href="#Atomics.AtomicRead">AtomicRead</a></emu-xref>(<var>buffer</var>, <var>indexedPosition</var>, <code>"Int32"</code>).</li><li>If <var>v</var> does not equal <var>w</var> then:<ol><li>Perform <emu-xref aoid="LeaveCriticalSection"><a href="#LeaveCriticalSection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>Return the string <code>"not-equal"</code>.</li></ol></li><li>Let <var>W</var> be <emu-xref aoid="AgentSignifier"><a href="#Atomics.AgentSignifier">AgentSignifier</a></emu-xref>().</li><li>Perform <emu-xref aoid="AddWaiter"><a href="#Atomics.AddWaiter">AddWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>).</li><li>Let awoken be <emu-xref aoid="Suspend"><a href="#Atomics.Suspend">Suspend</a></emu-xref>(<var>WL</var>, <var>W</var>, <var>t</var>).</li><li>Perform <emu-xref aoid="RemoveWaiter"><a href="#Atomics.RemoveWaiter">RemoveWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>).</li><li>Perform <emu-xref aoid="LeaveCriticalSection"><a href="#LeaveCriticalSection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>If awoken is <emu-val>true</emu-val> then return the string <code>"ok"</code>.</li><li>Return the string <code>"timed-out"</code>.
      </li></ol></emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.wake">
      <h1><span class="secnum">7.4.2.11</span>Atomics.wake( <var>typedArray</var>, <var>index</var>, <var>count</var> )<span class="utils"><span class="anchor"><a href="#Atomics.wake">#</a></span></span></h1>
      <p>Atomics.wake wakes up some agents that are sleeping in the wait queue.  The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>buffer</var> be ? <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>, <emu-val>true</emu-val>).</li><li>Let <var>i</var> be ? <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</li><li>If <var>count</var> is not provided or is <emu-val>undefined</emu-val> then let <var>c</var> be <emu-val>+∞</emu-val>.  Otherwise:<ol><li>Let <var>tmp</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>count</var>).</li><li>Let <var>c</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(<emu-val>+0</emu-val>, <var>tmp</var>).</li></ol></li><li>Let <var>bufferVal</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × 4) + <var>offset</var>.</li><li>Let <var>WL</var> be <emu-xref aoid="GetWaiterList"><a href="#GetWaiterList">GetWaiterList</a></emu-xref>(<var>block</var>, <var>indexedPosition</var>).</li><li>Let <var>n</var> be 0.</li><li>Perform <emu-xref aoid="EnterCriticalSection"><a href="#EnterCriticalSection">EnterCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>Let <var>S</var> be <emu-xref aoid="RemoveWaiters"><a href="#Atomics.RemoveWaiters">RemoveWaiters</a></emu-xref>(<var>WL</var>, <var>c</var>).</li><li>While <var>S</var> is not the empty list:<ol><li>Let <var>W</var> be the first agent in <var>S</var>.</li><li>Remove <var>W</var> from the front of <var>S</var>.</li><li>Perform <emu-xref aoid="WakeWaiter"><a href="#Atomics.WakeWaiter">WakeWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>).</li><li>Add 1 to <var>n</var>.</li></ol></li><li>Perform <emu-xref aoid="LeaveCriticalSection"><a href="#LeaveCriticalSection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>Return <var>n</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.xor">
      <h1><span class="secnum">7.4.2.12</span>Atomics.xor( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.xor">#</a></span></span></h1>
      <p>Let <code>xor</code> denote a semantic function of two Number arguments that converts both arguments to Int32 by the <emu-xref aoid="ToInt32"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref> operation, then applies the bitwise-xor operation to the converted values, and returns the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Return <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>(<var>typedArray</var>, <var>index</var>, <var>value</var>, <code>xor</code>).
      </li></ol></emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="WebBrowserEmbedding">
  <h1><span class="secnum">7.5</span>Web browser embedding (informative)<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding">#</a></span></span></h1>

  <p>This section outlines how the Shared Memory and Atomics
    specification fits into the current web ecosystem with the minimum
    amount of change to that ecosystem.  This section is not part of
    the proposal, it is informative only.</p>

  <p>In a web browser an  <em>agent</em> is an HTML  <em>event
    loop</em> <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">[here]</a>.
    The event loop is realized as either a main thread (which may be
    shared among tabs, as it is in Firefox) or some type of worker
    thread.  The event loops are running jobs in the sense of ES262,
    and the forward-progress requirement of this specification
    (section&nbsp;3.1.1) is generally met as long as each agent has
    its own dedicated operating system thread or shared-thread agents
    can't block.</p>

  <p>Browsers will typically let agents that run on the browser's
    main thread have [[CanBlock]] equal to <emu-val>false</emu-val>, to prevent blocking the
    UI and to allow the main thread to do work on behalf of other
    threads.</p>

  <p>Normal ("dedicated") <code>Worker</code>s must be supported as agents for
    this proposal to make much sense.</p>

  <p>Memory will be shared among agents by using <code>postMessage</code> to
    transmit SharedArrayBuffer objects or TypedArray objects that
    have SharedArrayBuffer buffers; this requires an extension to
    the Structured Clone mechanism.  There is agreement on the general
    syntax and semantics for that extension.</p>

  <p>Agent-to-agent communication extends the synchronizes-with relation
    of the program, as follows:</p>

  <ul>
    <li>The call to the <code>Worker</code> constructor in the parent
      synchronizes-with the execution of the main script in the worker. 

    </li><li>(Worker termination is not directly observable in current
      browsers, but this is a moot point; see below.) 

    </li><li>A <code>postMessage</code> to another agent synchronizes-with the event
      that fires in the agent.
 
 </li></ul>

  <p>So long as the browser does not allow a <code>ServiceWorker</code> or
    <code>SharedWorker</code> ("non-page worker") to share memory with a <code>Worker</code>
    it will not violate the suspend/wake cohort rule of this
    specification (section&nbsp;3.3).  The restriction on sharing
    memory can be implemented in the extension to the Structured Clone
    mechanism.  For example, a non-page worker may simply not be
    allowed to receive shared memory (leading to a null value or an
    error signal).  There is not yet any agreement on this point, but
    it is clear that the restriction must be on the receiving side of
    the communication, as the sender may be sending on a <code>MessagePort</code>
    that is not yet connected, but may in the future be connected to
    either a valid or invalid recipient.</p>

  <p>At the moment, I believe dedicated workers are in the same
    process as their owning tab in all browsers, so if the process
    crashes then the workers will crash too.  I also don't know any
    reason a browser should forcibly terminate a worker except when a
    tab is closed.  In sum, the termination signaling requirement of
    this specification (section&nbsp;3.3) is probably met by existing
    browsers.</p>

  <p>The web platform should evolve to serve the shared memory use
    case better: by incorporating inspectable worker state and worker
    lifecycle events, and by tightening the wording in the HTML spec
    (currently the browser is allowed to kill a worker at any time for
    any reason, which is not quite what we want).  WebIDL should
    evolve to allow Web APIs to be described as to when they can and
    cannot receive shared memory parameters.  However, only an
    extension to the Structured Clone algorithm is needed to support
    the Shared Memory and Atomics specification in practice on current
    browsers.</p>

</emu-clause>
</emu-clause><emu-annex id="sec-copyright-and-software-license">
      <h1><span class="secnum">A</span>Copyright &amp; Software License<span class="utils"><span class="anchor"><a href="#sec-copyright-and-software-license">#</a></span></span></h1>
      
      <h2>Copyright Notice</h2>
      <p>© 2016 Mozilla, Inc.</p>

      <h2>Software License</h2>
      <p>All Software contained in this document ("Software") is protected by copyright and is being made available under the "BSD License", included below. This Software may be subject to third party rights (rights from parties other than Ecma International), including patent rights, and no licenses under such third party rights are granted under this license even if the third party concerned is a member of Ecma International. SEE THE ECMA CODE OF CONDUCT IN PATENT MATTERS AVAILABLE AT http://www.ecma-international.org/memento/codeofconduct.htm FOR INFORMATION REGARDING THE LICENSING OF PATENT CLAIMS THAT ARE REQUIRED TO IMPLEMENT ECMA INTERNATIONAL STANDARDS.</p>

<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>

<ol>
  <li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
  <li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
  <li>Neither the name of the authors nor Ecma International may be used to endorse or promote products derived from this software without specific prior written permission.</li>
</ol>

<p>THIS SOFTWARE IS PROVIDED BY THE ECMA INTERNATIONAL "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ECMA INTERNATIONAL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

    </emu-annex></body>
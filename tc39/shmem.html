<!doctype html>
<head><meta charset="utf-8">
<title>ECMAScript Shared Memory and Atomics</title>
<script src="https://bterlson.github.io/ecmarkup/ecmarkup.js"></script>
<link rel="stylesheet" href="https://bterlson.github.io/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">

<script type="application/json" id="menu-search-biblio">{"clauses":{"intro":{"location":"","id":"intro","aoid":null,"title":"Introduction","number":""},"Overview":{"location":"","id":"Overview","aoid":null,"title":"Overview (ES6 4)","number":"1"},"Overview.Overview":{"location":"","id":"Overview.Overview","aoid":null,"title":"ECMAScript Overview (ES6 4.2)","number":"1.1"},"Overview.Terms":{"location":"","id":"Overview.Terms","aoid":null,"title":"Terms and Definitions (ES6 4.3)","number":"1.2"},"Overview.Terms.Agent":{"location":"","id":"Overview.Terms.Agent","aoid":null,"title":"Agent","number":"1.2.1"},"Overview.Terms.AgentComm":{"location":"","id":"Overview.Terms.AgentComm","aoid":null,"title":"Agent communication","number":"1.2.2"},"Overview.Terms.Cluster":{"location":"","id":"Overview.Terms.Cluster","aoid":null,"title":"Agent cluster","number":"1.2.3"},"DataTypesValues":{"location":"","id":"DataTypesValues","aoid":null,"title":"ECMAScript Data Types and Values (ES6 6)","number":"2"},"DataTypesValues.LanguageTypes":{"location":"","id":"DataTypesValues.LanguageTypes","aoid":null,"title":"ECMAScript Language Types (ES6 6.1)","number":"2.1"},"DataTypesValues.LanguageTypes.Number":{"location":"","id":"DataTypesValues.LanguageTypes.Number","aoid":null,"title":"The Number Type (ES6 6.1.6)","number":"2.1.1"},"DataTypesValues.LanguageTypes.Object":{"location":"","id":"DataTypesValues.LanguageTypes.Object","aoid":null,"title":"The Object Type (ES6 6.1.7)","number":"2.1.2"},"DataTypesValues.LanguageTypes.Object.Intrinsic":{"location":"","id":"DataTypesValues.LanguageTypes.Object.Intrinsic","aoid":null,"title":"Well-Known Intrinsic Objects (ES6 6.1.7.4)","number":"2.1.2.1"},"DataTypesValues.SpecTypes":{"location":"","id":"DataTypesValues.SpecTypes","aoid":null,"title":"ECMAScript Specification Types (ES6 6.2)","number":"2.2"},"DataTypesValues.SpecTypes.DataBlocks":{"location":"","id":"DataTypesValues.SpecTypes.DataBlocks","aoid":null,"title":"Data blocks (ES6 6.2.6)","number":"2.2.1"},"DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes":{"location":"","id":"DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes","aoid":null,"title":"CopyDataBlockBytes( toBlock, toIndex, fromBlock, fromIndex, count ) (ES6 6.2.6.2)","number":"2.2.1.1"},"DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock":{"location":"","id":"DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock","aoid":null,"title":"CreateSharedByteDataBlock( size )","number":"2.2.1.2"},"DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID":{"location":"","id":"DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID","aoid":"SharedDataBlockID","title":"SharedDataBlockID( block )","number":"2.2.1.3"},"ExecutableCodeAndContexts":{"location":"","id":"ExecutableCodeAndContexts","aoid":null,"title":"Executable Code and Execution Contexts (ES6 8)","number":"3"},"ExecutableCodeAndContexts.JobsAndJobQueues":{"location":"","id":"ExecutableCodeAndContexts.JobsAndJobQueues","aoid":null,"title":"Jobs and Job Queues (ES6 8.4)","number":"3.1"},"ExecutableCodeAndContexts.JobsAndJobQueues.Progress":{"location":"","id":"ExecutableCodeAndContexts.JobsAndJobQueues.Progress","aoid":null,"title":"Forward Progress Guarantees","number":"3.1.1"},"GlobalObject":{"location":"","id":"GlobalObject","aoid":null,"title":"The Global Object (ES6 18)","number":"4"},"GlobalObject.ConstructorProps":{"location":"","id":"GlobalObject.ConstructorProps","aoid":null,"title":"Constructor Properties of the Global Object (ES6 18.3)","number":"4.1"},"GlobalObject.ConstructorProps.SharedArrayBuffer":{"location":"","id":"GlobalObject.ConstructorProps.SharedArrayBuffer","aoid":null,"title":"SharedArrayBuffer","number":"4.1.1"},"GlobalObject.ConstructorProps.Atomics":{"location":"","id":"GlobalObject.ConstructorProps.Atomics","aoid":null,"title":"Atomics","number":"4.1.2"},"IndexedCollections":{"location":"","id":"IndexedCollections","aoid":null,"title":"Indexed Collections (ES6 22)","number":"5"},"IndexedCollections.TypedArray":{"location":"","id":"IndexedCollections.TypedArray","aoid":null,"title":"TypedArray Objects (ES6 22.2)","number":"5.1"},"IndexedCollections.TypedArray.intrinsic":{"location":"","id":"IndexedCollections.TypedArray.intrinsic","aoid":null,"title":"The %TypedArray% intrinsic object (ES6 22.2.1)","number":"5.1.1"},"IndexedCollections.TypedArray.intrinsic.constructFromObject":{"location":"","id":"IndexedCollections.TypedArray.intrinsic.constructFromObject","aoid":null,"title":"%TypedArray%( object ) (ES6 22.2.1.4)","number":"5.1.1.1"},"IndexedCollections.TypedArray.intrinsic.constructFromBuffer":{"location":"","id":"IndexedCollections.TypedArray.intrinsic.constructFromBuffer","aoid":null,"title":"%TypedArray%( buffer [ , byteOffset [ , length ] ] ) (ES6 22.2.1.5)","number":"5.1.1.2"},"IndexedCollections.TypedArray.prototype":{"location":"","id":"IndexedCollections.TypedArray.prototype","aoid":null,"title":"Properties of the %TypedArrayPrototype% object (ES6 22.2.3)","number":"5.1.2"},"IndexedCollections.TypedArray.prototype.set":{"location":"","id":"IndexedCollections.TypedArray.prototype.set","aoid":null,"title":" %TypedArray%.prototype.set( overloaded [ , offset ] ) (ES6 22.2.3.22)","number":"5.1.2.1"},"IndexedCollections.TypedArray.prototype.setFromTypedArray":{"location":"","id":"IndexedCollections.TypedArray.prototype.setFromTypedArray","aoid":null,"title":"%TypedArray%.prototype.set( typedArray [, offset ] ) (ES6 22.2.3.22.2)","number":"5.1.2.1.1"},"StructuredData":{"location":"","id":"StructuredData","aoid":null,"title":"Structured Data (ES6 24)","number":"6"},"StructuredData.ArrayBuffer":{"location":"","id":"StructuredData.ArrayBuffer","aoid":null,"title":"ArrayBuffer Objects (ES6 24.1)","number":"6.1"},"StructuredData.ArrayBuffer.abstract":{"location":"","id":"StructuredData.ArrayBuffer.abstract","aoid":null,"title":"Abstract Operations for ArrayBuffer (ES6 24.1.1)","number":"6.1.1"},"StructuredData.ArrayBuffer.abstract.IsDetachedBuffer":{"location":"","id":"StructuredData.ArrayBuffer.abstract.IsDetachedBuffer","aoid":"IsDetachedBuffer","title":"IsDetachedBuffer( arrayBuffer ) (ES6 24.1.1.2)","number":"6.1.1.1"},"StructuredData.ArrayBuffer.abstract.CloneArrayBuffer":{"location":"","id":"StructuredData.ArrayBuffer.abstract.CloneArrayBuffer","aoid":"CloneArrayBuffer","title":"CloneArrayBuffer( srcBuffer, srcByteOffset [, cloneConstructor] ) (ES6 24.1.1.4)","number":"6.1.1.2"},"StructuredData.ArrayBuffer.abstract.GetValueFromBuffer":{"location":"","id":"StructuredData.ArrayBuffer.abstract.GetValueFromBuffer","aoid":"GetValueFromBuffer","title":"GetValueFromBuffer( arrayBuffer, byteIndex, type, isLittleEndian ) (ES6 24.1.1.5)","number":"6.1.1.3"},"StructuredData.ArrayBuffer.abstract.SetValueInBuffer":{"location":"","id":"StructuredData.ArrayBuffer.abstract.SetValueInBuffer","aoid":"SetValueInBuffer","title":"SetValueInBuffer( arrayBuffer, byteIndex, type, value, isLittleEndian ) (ES6 24.1.1.6)","number":"6.1.1.4"},"StructuredData.DataView":{"location":"","id":"StructuredData.DataView","aoid":null,"title":"DataView Objects (ES6 24.2)","number":"6.2"},"StructuredData.DataView.constructor":{"location":"","id":"StructuredData.DataView.constructor","aoid":null,"title":"The DataView Constructor (ES6 24.2.2)","number":"6.2.1"},"StructuredData.DataView.constructor.detail":{"location":"","id":"StructuredData.DataView.constructor.detail","aoid":null,"title":"DataView( buffer [ , byteOffset [ , byteLength ] ] ) (ES6 24.2.2.1)","number":"6.2.1.1"},"StructuredData.SharedArrayBuffer":{"location":"","id":"StructuredData.SharedArrayBuffer","aoid":null,"title":"SharedArrayBuffer Objects","number":"6.3"},"StructuredData.SharedArrayBuffer.abstract":{"location":"","id":"StructuredData.SharedArrayBuffer.abstract","aoid":null,"title":"Abstract Operations for SharedArrayBuffer","number":"6.3.1"},"StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer":{"location":"","id":"StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer","aoid":null,"title":"AllocateSharedArrayBuffer( constructor, byteLength )","number":"6.3.1.1"},"StructuredData.SharedArrayBuffer.abstract.IsSharedMemory":{"location":"","id":"StructuredData.SharedArrayBuffer.abstract.IsSharedMemory","aoid":"IsSharedMemory","title":"IsSharedMemory( obj )","number":"6.3.1.2"},"StructuredData.SharedArrayBuffer.constructor":{"location":"","id":"StructuredData.SharedArrayBuffer.constructor","aoid":null,"title":"The SharedArrayBuffer Constructor","number":"6.3.2"},"StructuredData.SharedArrayBuffer.constructor.withLength":{"location":"","id":"StructuredData.SharedArrayBuffer.constructor.withLength","aoid":null,"title":"SharedArrayBuffer( length )","number":"6.3.2.1"},"StructuredData.SharedArrayBuffer.constructor.properties":{"location":"","id":"StructuredData.SharedArrayBuffer.constructor.properties","aoid":null,"title":"Properties of the SharedArrayBuffer constructor","number":"6.3.3"},"StructuredData.SharedArrayBuffer.constructor.properties.isView":{"location":"","id":"StructuredData.SharedArrayBuffer.constructor.properties.isView","aoid":null,"title":"SharedArrayBuffer.isView( arg )","number":"6.3.3.1"},"StructuredData.SharedArrayBuffer.constructor.properties.prototype":{"location":"","id":"StructuredData.SharedArrayBuffer.constructor.properties.prototype","aoid":null,"title":"SharedArrayBuffer.prototype","number":"6.3.3.2"},"StructuredData.SharedArrayBuffer.constructor.properties.get_species":{"location":"","id":"StructuredData.SharedArrayBuffer.constructor.properties.get_species","aoid":null,"title":"get SharedArrayBuffer [ @@species ]","number":"6.3.3.3"},"StructuredData.SharedArrayBuffer.prototype":{"location":"","id":"StructuredData.SharedArrayBuffer.prototype","aoid":null,"title":"Properties of the SharedArrayBuffer prototype object","number":"6.3.4"},"StructuredData.SharedArrayBuffer.prototype.get_byteLength":{"location":"","id":"StructuredData.SharedArrayBuffer.prototype.get_byteLength","aoid":null,"title":"get SharedArrayBuffer.prototype.byteLength","number":"6.3.4.1"},"StructuredData.SharedArrayBuffer.prototype.constructor":{"location":"","id":"StructuredData.SharedArrayBuffer.prototype.constructor","aoid":null,"title":"SharedArrayBuffer.prototype.constructor","number":"6.3.4.2"},"StructuredData.SharedArrayBuffer.prototype.slice":{"location":"","id":"StructuredData.SharedArrayBuffer.prototype.slice","aoid":null,"title":"SharedArrayBuffer.prototype.slice( start, end )","number":"6.3.4.3"},"StructuredData.SharedArrayBuffer.prototype.toString":{"location":"","id":"StructuredData.SharedArrayBuffer.prototype.toString","aoid":null,"title":"SharedArrayBuffer.prototype[ @@toStringTag ]","number":"6.3.4.4"},"StructuredData.SharedArrayBuffer.instances":{"location":"","id":"StructuredData.SharedArrayBuffer.instances","aoid":null,"title":"Properties of the SharedArrayBuffer instances","number":"6.3.5"},"AtomicsObject":{"location":"","id":"AtomicsObject","aoid":null,"title":"The Atomics Object","number":"7"},"AtomicsObjectValueProps":{"location":"","id":"AtomicsObjectValueProps","aoid":null,"title":"Value Properties of the Atomics Object","number":"7.1"},"Atomics.OK":{"location":"","id":"Atomics.OK","aoid":null,"title":"Atomics.OK","number":"7.1.1"},"Atomics.NOTEQUAL":{"location":"","id":"Atomics.NOTEQUAL","aoid":null,"title":"Atomics.NOTEQUAL","number":"7.1.2"},"Atomics.TIMEDOUT":{"location":"","id":"Atomics.TIMEDOUT","aoid":null,"title":"Atomics.TIMEDOUT","number":"7.1.3"},"AtomicsObjectFunctionProps.semantics":{"location":"","id":"AtomicsObjectFunctionProps.semantics","aoid":null,"title":"Runtime semantics","number":"7.2"},"Atomics.WithAtomicAccessTo":{"location":"","id":"Atomics.WithAtomicAccessTo","aoid":null,"title":"With atomic access to ( buffer, indexedPosition, elementSize )","number":"7.2.1"},"Atomics.ValidateSharedIntegerTypedArray":{"location":"","id":"Atomics.ValidateSharedIntegerTypedArray","aoid":"ValidateSharedIntegerTypedArray","title":"Runtime semantics: ValidateSharedIntegerTypedArray( typedArray [, onlyInt32] )","number":"7.2.2"},"Atomics.ValidateAtomicAccess":{"location":"","id":"Atomics.ValidateAtomicAccess","aoid":"ValidateAtomicAccess","title":"Runtime semantics: ValidateAtomicAccess( typedArray, index )","number":"7.2.3"},"WithinTheFutexCriticalSection":{"location":"","id":"WithinTheFutexCriticalSection","aoid":null,"title":"Within the futex critical section ...","number":"7.2.4"},"Atomics.AgentSignifier":{"location":"","id":"Atomics.AgentSignifier","aoid":"AgentSignifier","title":"Runtime semantics: AgentSignifier( )","number":"7.2.5"},"Atomics.AgentCanSuspend":{"location":"","id":"Atomics.AgentCanSuspend","aoid":"AgentCanSuspend","title":"Runtime semantics: AgentCanSuspend( )","number":"7.2.6"},"Atomics.AddWaiter":{"location":"","id":"Atomics.AddWaiter","aoid":"AddWaiter","title":"Runtime semantics: AddWaiter( W, G, i )","number":"7.2.7"},"Atomics.RemoveWaiter":{"location":"","id":"Atomics.RemoveWaiter","aoid":"RemoveWaiter","title":"Runtime semantics: RemoveWaiter( W, G, i )","number":"7.2.8"},"Atomics.RemoveWaiters":{"location":"","id":"Atomics.RemoveWaiters","aoid":"RemoveWaiters","title":"Runtime semantics: RemoveWaiters( G, i)","number":"7.2.9"},"Atomics.Suspend":{"location":"","id":"Atomics.Suspend","aoid":"Suspend","title":"Runtime semantics: Suspend( W, timeout )","number":"7.2.10"},"Atomics.WakeWaiter":{"location":"","id":"Atomics.WakeWaiter","aoid":"WakeWaiter","title":"Runtime semantics: WakeWaiter( W )","number":"7.2.11"},"AtomicsObjectFunctionProps":{"location":"","id":"AtomicsObjectFunctionProps","aoid":null,"title":"Function Properties of the Atomics Object","number":"7.3"},"Atomics.add":{"location":"","id":"Atomics.add","aoid":null,"title":"Atomics.add( typedArray, index, value )","number":"7.3.1"},"Atomics.and":{"location":"","id":"Atomics.and","aoid":null,"title":"Atomics.and( typedArray, index, value )","number":"7.3.2"},"Atomics.compareExchange":{"location":"","id":"Atomics.compareExchange","aoid":null,"title":"Atomics.compareExchange( typedArray, index, expectedValue, replacementValue )","number":"7.3.3"},"Atomics.exchange":{"location":"","id":"Atomics.exchange","aoid":null,"title":"Atomics.exchange( typedArray, index, value )","number":"7.3.4"},"Atomics.futexWait":{"location":"","id":"Atomics.futexWait","aoid":null,"title":"Atomics.futexWait( typedArray, index, value, timeout )","number":"7.3.5"},"Atomics.futexWake":{"location":"","id":"Atomics.futexWake","aoid":null,"title":"Atomics.futexWake( typedArray, index, count )","number":"7.3.6"},"Atomics.futexWakeOrRequeue":{"location":"","id":"Atomics.futexWakeOrRequeue","aoid":null,"title":"Atomics.futexWakeOrRequeue( typedArray, index1, count, index2, value )","number":"7.3.7"},"Atomics.isLockFree":{"location":"","id":"Atomics.isLockFree","aoid":null,"title":"Atomics.isLockFree( size )","number":"7.3.8"},"Atomics.load":{"location":"","id":"Atomics.load","aoid":null,"title":"Atomics.load( typedArray, index )","number":"7.3.9"},"Atomics.or":{"location":"","id":"Atomics.or","aoid":null,"title":"Atomics.or( typedArray, index, value )","number":"7.3.10"},"Atomics.store":{"location":"","id":"Atomics.store","aoid":null,"title":"Atomics.store( typedArray, index, value )","number":"7.3.11"},"Atomics.sub":{"location":"","id":"Atomics.sub","aoid":null,"title":"Atomics.sub( typedArray, index, value )","number":"7.3.12"},"Atomics.xor":{"location":"","id":"Atomics.xor","aoid":null,"title":"Atomics.xor( typedArray, index, value )","number":"7.3.13"},"WebBrowserEmbedding":{"location":"","id":"WebBrowserEmbedding","aoid":null,"title":"Web browser embedding (informative)","number":"8"},"WebBrowserEmbedding.Agents":{"location":"","id":"WebBrowserEmbedding.Agents","aoid":null,"title":"Agent mapping","number":"8.1"},"WebBrowserEmbedding.WorkerSemantics":{"location":"","id":"WebBrowserEmbedding.WorkerSemantics","aoid":null,"title":"Clarifications and changes to Web Worker semantics","number":"8.2"},"WebBrowserEmbedding.WorkerSemantics.Start":{"location":"","id":"WebBrowserEmbedding.WorkerSemantics.Start","aoid":null,"title":"Actions to start a worker","number":"8.2.1"},"WebBrowserEmbedding.WorkerSemantics.Jobs":{"location":"","id":"WebBrowserEmbedding.WorkerSemantics.Jobs","aoid":null,"title":"Events and scripts run in a worker as ES6 jobs","number":"8.2.2"},"WebBrowserEmbedding.WorkerSemantics.LicenseToKill":{"location":"","id":"WebBrowserEmbedding.WorkerSemantics.LicenseToKill","aoid":null,"title":"Curtail the license to kill","number":"8.2.3"},"WebBrowserEmbedding.WorkerSemantics.Introspection":{"location":"","id":"WebBrowserEmbedding.WorkerSemantics.Introspection","aoid":null,"title":"Termination detection","number":"8.2.4"},"WebBrowserEmbedding.MemoryModel":{"location":"","id":"WebBrowserEmbedding.MemoryModel","aoid":null,"title":"Agent communication semantics","number":"8.3"},"WebBrowserEmbedding.Termination":{"location":"","id":"WebBrowserEmbedding.Termination","aoid":null,"title":"Agent termination","number":"8.4"},"WebBrowserEmbedding.CloneAndTransfer":{"location":"","id":"WebBrowserEmbedding.CloneAndTransfer","aoid":null,"title":"Transmitting and Cloning SharedArrayBuffers and Views","number":"8.5"}},"ops":{"SharedDataBlockID":{"aoid":"SharedDataBlockID","id":"DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID","location":""},"IsDetachedBuffer":{"aoid":"IsDetachedBuffer","id":"StructuredData.ArrayBuffer.abstract.IsDetachedBuffer","location":""},"CloneArrayBuffer":{"aoid":"CloneArrayBuffer","id":"StructuredData.ArrayBuffer.abstract.CloneArrayBuffer","location":""},"GetValueFromBuffer":{"aoid":"GetValueFromBuffer","id":"StructuredData.ArrayBuffer.abstract.GetValueFromBuffer","location":""},"SetValueInBuffer":{"aoid":"SetValueInBuffer","id":"StructuredData.ArrayBuffer.abstract.SetValueInBuffer","location":""},"IsSharedMemory":{"aoid":"IsSharedMemory","id":"StructuredData.SharedArrayBuffer.abstract.IsSharedMemory","location":""},"ValidateSharedIntegerTypedArray":{"aoid":"ValidateSharedIntegerTypedArray","id":"Atomics.ValidateSharedIntegerTypedArray","location":""},"ValidateAtomicAccess":{"aoid":"ValidateAtomicAccess","id":"Atomics.ValidateAtomicAccess","location":""},"AgentSignifier":{"aoid":"AgentSignifier","id":"Atomics.AgentSignifier","location":""},"AgentCanSuspend":{"aoid":"AgentCanSuspend","id":"Atomics.AgentCanSuspend","location":""},"AddWaiter":{"aoid":"AddWaiter","id":"Atomics.AddWaiter","location":""},"RemoveWaiter":{"aoid":"RemoveWaiter","id":"Atomics.RemoveWaiter","location":""},"RemoveWaiters":{"aoid":"RemoveWaiters","id":"Atomics.RemoveWaiters","location":""},"Suspend":{"aoid":"Suspend","id":"Atomics.Suspend","location":""},"WakeWaiter":{"aoid":"WakeWaiter","id":"Atomics.WakeWaiter","location":""}},"productions":{},"terms":{},"examples":{},"notes":{},"tables":{},"figures":{}}</script></head><body><div id="menu-toggle">☰</div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#intro" title="Introduction"><span class="secnum"></span> Introduction</a></li><li><span class="item-toggle">◢</span><a href="#Overview" title="Overview (ES6 4)"><span class="secnum">1</span> Overview (ES6 4)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#Overview.Overview" title="ECMAScript Overview (ES6 4.2)"><span class="secnum">1.1</span> ECMAScript Overview (ES6 4.2)</a></li><li><span class="item-toggle">◢</span><a href="#Overview.Terms" title="Terms and Definitions (ES6 4.3)"><span class="secnum">1.2</span> Terms and Definitions (ES6 4.3)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#Overview.Terms.Agent" title="Agent"><span class="secnum">1.2.1</span> Agent</a></li><li><span class="item-toggle-none"></span><a href="#Overview.Terms.AgentComm" title="Agent communication"><span class="secnum">1.2.2</span> Agent communication</a></li><li><span class="item-toggle-none"></span><a href="#Overview.Terms.Cluster" title="Agent cluster"><span class="secnum">1.2.3</span> Agent cluster</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#DataTypesValues" title="ECMAScript Data Types and Values (ES6 6)"><span class="secnum">2</span> ECMAScript Data Types and Values (ES6 6)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#DataTypesValues.LanguageTypes" title="ECMAScript Language Types (ES6 6.1)"><span class="secnum">2.1</span> ECMAScript Language Types (ES6 6.1)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#DataTypesValues.LanguageTypes.Number" title="The Number Type (ES6 6.1.6)"><span class="secnum">2.1.1</span> The Number Type (ES6 6.1.6)</a></li><li><span class="item-toggle">◢</span><a href="#DataTypesValues.LanguageTypes.Object" title="The Object Type (ES6 6.1.7)"><span class="secnum">2.1.2</span> The Object Type (ES6 6.1.7)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#DataTypesValues.LanguageTypes.Object.Intrinsic" title="Well-Known Intrinsic Objects (ES6 6.1.7.4)"><span class="secnum">2.1.2.1</span> Well-Known Intrinsic Objects (ES6 6.1.7.4)</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#DataTypesValues.SpecTypes" title="ECMAScript Specification Types (ES6 6.2)"><span class="secnum">2.2</span> ECMAScript Specification Types (ES6 6.2)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#DataTypesValues.SpecTypes.DataBlocks" title="Data blocks (ES6 6.2.6)"><span class="secnum">2.2.1</span> Data blocks (ES6 6.2.6)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes" title="CopyDataBlockBytes( toBlock, toIndex, fromBlock, fromIndex, count ) (ES6 6.2.6.2)"><span class="secnum">2.2.1.1</span> CopyDataBlockBytes( toBlock, toIndex, fromBlock, fromIndex, count ) (ES6 6.2.6.2)</a></li><li><span class="item-toggle-none"></span><a href="#DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock" title="CreateSharedByteDataBlock( size )"><span class="secnum">2.2.1.2</span> CreateSharedByteDataBlock( size )</a></li><li><span class="item-toggle-none"></span><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID" title="SharedDataBlockID( block )"><span class="secnum">2.2.1.3</span> SharedDataBlockID( block )</a></li></ol></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#ExecutableCodeAndContexts" title="Executable Code and Execution Contexts (ES6 8)"><span class="secnum">3</span> Executable Code and Execution Contexts (ES6 8)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#ExecutableCodeAndContexts.JobsAndJobQueues" title="Jobs and Job Queues (ES6 8.4)"><span class="secnum">3.1</span> Jobs and Job Queues (ES6 8.4)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.JobsAndJobQueues.Progress" title="Forward Progress Guarantees"><span class="secnum">3.1.1</span> Forward Progress Guarantees</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#GlobalObject" title="The Global Object (ES6 18)"><span class="secnum">4</span> The Global Object (ES6 18)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#GlobalObject.ConstructorProps" title="Constructor Properties of the Global Object (ES6 18.3)"><span class="secnum">4.1</span> Constructor Properties of the Global Object (ES6 18.3)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#GlobalObject.ConstructorProps.SharedArrayBuffer" title="SharedArrayBuffer"><span class="secnum">4.1.1</span> SharedArrayBuffer</a></li><li><span class="item-toggle-none"></span><a href="#GlobalObject.ConstructorProps.Atomics" title="Atomics"><span class="secnum">4.1.2</span> Atomics</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#IndexedCollections" title="Indexed Collections (ES6 22)"><span class="secnum">5</span> Indexed Collections (ES6 22)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray" title="TypedArray Objects (ES6 22.2)"><span class="secnum">5.1</span> TypedArray Objects (ES6 22.2)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray.intrinsic" title="The %TypedArray% intrinsic object (ES6 22.2.1)"><span class="secnum">5.1.1</span> The %TypedArray% intrinsic object (ES6 22.2.1)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#IndexedCollections.TypedArray.intrinsic.constructFromObject" title="%TypedArray%( object ) (ES6 22.2.1.4)"><span class="secnum">5.1.1.1</span> %TypedArray%( object ) (ES6 22.2.1.4)</a></li><li><span class="item-toggle-none"></span><a href="#IndexedCollections.TypedArray.intrinsic.constructFromBuffer" title="%TypedArray%( buffer [ , byteOffset [ , length ] ] ) (ES6 22.2.1.5)"><span class="secnum">5.1.1.2</span> %TypedArray%( buffer [ , byteOffset [ , length ] ] ) (ES6 22.2.1.5)</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray.prototype" title="Properties of the %TypedArrayPrototype% object (ES6 22.2.3)"><span class="secnum">5.1.2</span> Properties of the %TypedArrayPrototype% object (ES6 22.2.3)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray.prototype.set" title=" %TypedArray%.prototype.set( overloaded [ , offset ] ) (ES6 22.2.3.22)"><span class="secnum">5.1.2.1</span> %TypedArray%.prototype.set( overloaded [ , offset ] ) (ES6 22.2.3.22)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#IndexedCollections.TypedArray.prototype.setFromTypedArray" title="%TypedArray%.prototype.set( typedArray [, offset ] ) (ES6 22.2.3.22.2)"><span class="secnum">5.1.2.1.1</span> %TypedArray%.prototype.set( typedArray [, offset ] ) (ES6 22.2.3.22.2)</a></li></ol></li></ol></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData" title="Structured Data (ES6 24)"><span class="secnum">6</span> Structured Data (ES6 24)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.ArrayBuffer" title="ArrayBuffer Objects (ES6 24.1)"><span class="secnum">6.1</span> ArrayBuffer Objects (ES6 24.1)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.ArrayBuffer.abstract" title="Abstract Operations for ArrayBuffer (ES6 24.1.1)"><span class="secnum">6.1.1</span> Abstract Operations for ArrayBuffer (ES6 24.1.1)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer" title="IsDetachedBuffer( arrayBuffer ) (ES6 24.1.1.2)"><span class="secnum">6.1.1.1</span> IsDetachedBuffer( arrayBuffer ) (ES6 24.1.1.2)</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.CloneArrayBuffer" title="CloneArrayBuffer( srcBuffer, srcByteOffset [, cloneConstructor] ) (ES6 24.1.1.4)"><span class="secnum">6.1.1.2</span> CloneArrayBuffer( srcBuffer, srcByteOffset [, cloneConstructor] ) (ES6 24.1.1.4)</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" title="GetValueFromBuffer( arrayBuffer, byteIndex, type, isLittleEndian ) (ES6 24.1.1.5)"><span class="secnum">6.1.1.3</span> GetValueFromBuffer( arrayBuffer, byteIndex, type, isLittleEndian ) (ES6 24.1.1.5)</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer" title="SetValueInBuffer( arrayBuffer, byteIndex, type, value, isLittleEndian ) (ES6 24.1.1.6)"><span class="secnum">6.1.1.4</span> SetValueInBuffer( arrayBuffer, byteIndex, type, value, isLittleEndian ) (ES6 24.1.1.6)</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.DataView" title="DataView Objects (ES6 24.2)"><span class="secnum">6.2</span> DataView Objects (ES6 24.2)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.DataView.constructor" title="The DataView Constructor (ES6 24.2.2)"><span class="secnum">6.2.1</span> The DataView Constructor (ES6 24.2.2)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.DataView.constructor.detail" title="DataView( buffer [ , byteOffset [ , byteLength ] ] ) (ES6 24.2.2.1)"><span class="secnum">6.2.1.1</span> DataView( buffer [ , byteOffset [ , byteLength ] ] ) (ES6 24.2.2.1)</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer" title="SharedArrayBuffer Objects"><span class="secnum">6.3</span> SharedArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.abstract" title="Abstract Operations for SharedArrayBuffer"><span class="secnum">6.3.1</span> Abstract Operations for SharedArrayBuffer</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer" title="AllocateSharedArrayBuffer( constructor, byteLength )"><span class="secnum">6.3.1.1</span> AllocateSharedArrayBuffer( constructor, byteLength )</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory" title="IsSharedMemory( obj )"><span class="secnum">6.3.1.2</span> IsSharedMemory( obj )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.constructor" title="The SharedArrayBuffer Constructor"><span class="secnum">6.3.2</span> The SharedArrayBuffer Constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.constructor.withLength" title="SharedArrayBuffer( length )"><span class="secnum">6.3.2.1</span> SharedArrayBuffer( length )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.constructor.properties" title="Properties of the SharedArrayBuffer constructor"><span class="secnum">6.3.3</span> Properties of the SharedArrayBuffer constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.constructor.properties.isView" title="SharedArrayBuffer.isView( arg )"><span class="secnum">6.3.3.1</span> SharedArrayBuffer.isView( arg )</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.constructor.properties.prototype" title="SharedArrayBuffer.prototype"><span class="secnum">6.3.3.2</span> SharedArrayBuffer.prototype</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.constructor.properties.get_species" title="get SharedArrayBuffer [ @@species ]"><span class="secnum">6.3.3.3</span> get SharedArrayBuffer [ @@species ]</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.prototype" title="Properties of the SharedArrayBuffer prototype object"><span class="secnum">6.3.4</span> Properties of the SharedArrayBuffer prototype object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.get_byteLength" title="get SharedArrayBuffer.prototype.byteLength"><span class="secnum">6.3.4.1</span> get SharedArrayBuffer.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.constructor" title="SharedArrayBuffer.prototype.constructor"><span class="secnum">6.3.4.2</span> SharedArrayBuffer.prototype.constructor</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.slice" title="SharedArrayBuffer.prototype.slice( start, end )"><span class="secnum">6.3.4.3</span> SharedArrayBuffer.prototype.slice( start, end )</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.toString" title="SharedArrayBuffer.prototype[ @@toStringTag ]"><span class="secnum">6.3.4.4</span> SharedArrayBuffer.prototype[ @@toStringTag ]</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.instances" title="Properties of the SharedArrayBuffer instances"><span class="secnum">6.3.5</span> Properties of the SharedArrayBuffer instances</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#AtomicsObject" title="The Atomics Object"><span class="secnum">7</span> The Atomics Object</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#AtomicsObjectValueProps" title="Value Properties of the Atomics Object"><span class="secnum">7.1</span> Value Properties of the Atomics Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#Atomics.OK" title="Atomics.OK"><span class="secnum">7.1.1</span> Atomics.OK</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.NOTEQUAL" title="Atomics.NOTEQUAL"><span class="secnum">7.1.2</span> Atomics.NOTEQUAL</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.TIMEDOUT" title="Atomics.TIMEDOUT"><span class="secnum">7.1.3</span> Atomics.TIMEDOUT</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#AtomicsObjectFunctionProps.semantics" title="Runtime semantics"><span class="secnum">7.2</span> Runtime semantics</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#Atomics.WithAtomicAccessTo" title="With atomic access to ( buffer, indexedPosition, elementSize )"><span class="secnum">7.2.1</span> With atomic access to ( buffer, indexedPosition, elementSize )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.ValidateSharedIntegerTypedArray" title="Runtime semantics: ValidateSharedIntegerTypedArray( typedArray [, onlyInt32] )"><span class="secnum">7.2.2</span> Runtime semantics: ValidateSharedIntegerTypedArray( typedArray [, onlyInt32] )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.ValidateAtomicAccess" title="Runtime semantics: ValidateAtomicAccess( typedArray, index )"><span class="secnum">7.2.3</span> Runtime semantics: ValidateAtomicAccess( typedArray, index )</a></li><li><span class="item-toggle-none"></span><a href="#WithinTheFutexCriticalSection" title="Within the futex critical section ..."><span class="secnum">7.2.4</span> Within the futex critical section ...</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AgentSignifier" title="Runtime semantics: AgentSignifier( )"><span class="secnum">7.2.5</span> Runtime semantics: AgentSignifier( )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AgentCanSuspend" title="Runtime semantics: AgentCanSuspend( )"><span class="secnum">7.2.6</span> Runtime semantics: AgentCanSuspend( )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AddWaiter" title="Runtime semantics: AddWaiter( W, G, i )"><span class="secnum">7.2.7</span> Runtime semantics: AddWaiter( W, G, i )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.RemoveWaiter" title="Runtime semantics: RemoveWaiter( W, G, i )"><span class="secnum">7.2.8</span> Runtime semantics: RemoveWaiter( W, G, i )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.RemoveWaiters" title="Runtime semantics: RemoveWaiters( G, i)"><span class="secnum">7.2.9</span> Runtime semantics: RemoveWaiters( G, i)</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.Suspend" title="Runtime semantics: Suspend( W, timeout )"><span class="secnum">7.2.10</span> Runtime semantics: Suspend( W, timeout )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.WakeWaiter" title="Runtime semantics: WakeWaiter( W )"><span class="secnum">7.2.11</span> Runtime semantics: WakeWaiter( W )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#AtomicsObjectFunctionProps" title="Function Properties of the Atomics Object"><span class="secnum">7.3</span> Function Properties of the Atomics Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#Atomics.add" title="Atomics.add( typedArray, index, value )"><span class="secnum">7.3.1</span> Atomics.add( typedArray, index, value )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.and" title="Atomics.and( typedArray, index, value )"><span class="secnum">7.3.2</span> Atomics.and( typedArray, index, value )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.compareExchange" title="Atomics.compareExchange( typedArray, index, expectedValue, replacementValue )"><span class="secnum">7.3.3</span> Atomics.compareExchange( typedArray, index, expectedValue, replacementValue )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.exchange" title="Atomics.exchange( typedArray, index, value )"><span class="secnum">7.3.4</span> Atomics.exchange( typedArray, index, value )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.futexWait" title="Atomics.futexWait( typedArray, index, value, timeout )"><span class="secnum">7.3.5</span> Atomics.futexWait( typedArray, index, value, timeout )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.futexWake" title="Atomics.futexWake( typedArray, index, count )"><span class="secnum">7.3.6</span> Atomics.futexWake( typedArray, index, count )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.futexWakeOrRequeue" title="Atomics.futexWakeOrRequeue( typedArray, index1, count, index2, value )"><span class="secnum">7.3.7</span> Atomics.futexWakeOrRequeue( typedArray, index1, count, index2, value )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.isLockFree" title="Atomics.isLockFree( size )"><span class="secnum">7.3.8</span> Atomics.isLockFree( size )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.load" title="Atomics.load( typedArray, index )"><span class="secnum">7.3.9</span> Atomics.load( typedArray, index )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.or" title="Atomics.or( typedArray, index, value )"><span class="secnum">7.3.10</span> Atomics.or( typedArray, index, value )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.store" title="Atomics.store( typedArray, index, value )"><span class="secnum">7.3.11</span> Atomics.store( typedArray, index, value )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.sub" title="Atomics.sub( typedArray, index, value )"><span class="secnum">7.3.12</span> Atomics.sub( typedArray, index, value )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.xor" title="Atomics.xor( typedArray, index, value )"><span class="secnum">7.3.13</span> Atomics.xor( typedArray, index, value )</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#WebBrowserEmbedding" title="Web browser embedding (informative)"><span class="secnum">8</span> Web browser embedding (informative)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.Agents" title="Agent mapping"><span class="secnum">8.1</span> Agent mapping</a></li><li><span class="item-toggle">◢</span><a href="#WebBrowserEmbedding.WorkerSemantics" title="Clarifications and changes to Web Worker semantics"><span class="secnum">8.2</span> Clarifications and changes to Web Worker semantics</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.WorkerSemantics.Start" title="Actions to start a worker"><span class="secnum">8.2.1</span> Actions to start a worker</a></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.WorkerSemantics.Jobs" title="Events and scripts run in a worker as ES6 jobs"><span class="secnum">8.2.2</span> Events and scripts run in a worker as ES6 jobs</a></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.WorkerSemantics.LicenseToKill" title="Curtail the license to kill"><span class="secnum">8.2.3</span> Curtail the license to kill</a></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.WorkerSemantics.Introspection" title="Termination detection"><span class="secnum">8.2.4</span> Termination detection</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.MemoryModel" title="Agent communication semantics"><span class="secnum">8.3</span> Agent communication semantics</a></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.Termination" title="Agent termination"><span class="secnum">8.4</span> Agent termination</a></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.CloneAndTransfer" title="Transmitting and Cloning SharedArrayBuffers and Views"><span class="secnum">8.5</span> Transmitting and Cloning SharedArrayBuffers and Views</a></li></ol></li></ol></div></div><h1>ECMAScript Shared Memory and Atomics</h1>
<p> Revised: 2015-09-23 </p>

<emu-intro id="intro">
<h1><span class="secnum"></span>Introduction<span class="utils"><span class="anchor"><a href="#intro">#</a></span></span></h1>

<p> This proposal adds a simple form of shared memory to ECMAScript.
Shared memory is being exposed in the form of a new SharedArrayBuffer
type; the existing TypedArrays are adapted in such a way that they can
be used to create views on shared memory.  The new Atomics global
object provides atomic operations on shared memory locations,
including operations that can be used to create blocking
synchronization primitives.  Though not a part of this specification,
we intend for the role of "threads" to be played by Web Workers in web
browser environments.</p><p>

</p><p> At this time the proposal adds only low-level primitives to
ECMAScript; we expect the developer community to put together
abstractions that are useful in specific domains.  </p>

<p> The work has been driven by the following use cases:  </p><p>

</p><ul>
  <li> Support for threaded code in programs written in other
  languages that are translated to asm.js or plain JS or a combination
  of the two, notably C++ but also JVM and CIL bytecode, Halide,
  Clojure, Rust, and similar safe languages. 

  </li><li> Support for hand-written JS or JS+asm.js that makes use of
  multiprocessing facilities for select tasks, such as image
  processing, asset management, or game AI.

</li></ul>

<p> The proposal makes only very basic assumptions about the required
hardware and should be broadly implementable with good performance.  A
closely related API has been available in Firefox Nightly for some
time.  </p>

<p>This specification constitutes a restatement and formalization of
an earlier
work,  <a href="https://docs.google.com/document/d/1NDGA_gZJ7M7w1Bh8S0AoDyEqwDdRh4uSoTPSNn77PFk/edit?usp=sharing">the
spec document for which</a> also contains additional rationale,
background information, discussions, implementation notes, and
comments.</p>

<p> This specification is substantially complete, apart from these aspects:  </p>
<ul>
  <li> The memory model is going to be refined further (for a while). 

  </li><li> It is highly desirable to add facilities that allow conflicting
  shared memory operations to have defined meaning.  For example,
  adding Atomics.loadUnordered, Atomics.storeUnordered, and perhaps an
  explicit Atomics.fence operation, might be enough to allow a
  translation from JVM bytecodes to ECMAScript.

</li></ul>

<p>Changelog:</p>
<ul>
  <li> 2015-12-28 -- (Issue 36) Allow futexWait to throw an exception if blocking is not allowed on a thread, search for "<emu-xref aoid="AgentCanSuspend"><a href="#Atomics.AgentCanSuspend">AgentCanSuspend</a></emu-xref>".
  
  </li><li> 2015-09-23 -- Spec draft notes are all linked to Issues in the bug tracker.
  
  </li><li> 2015-09-18 -- Corrected the definition of atomic access viability.
  
  </li><li> 2015-09-17 -- Restated the memory model (again) after discussions.
  
  </li><li> 2015-09-15 -- (Issue 24) Spell out constraints on optimization.
  
  </li><li> 2015-09-01 -- (Issue 21) isLockFree returns false if its argument is not the byte size of some <emu-val>integer</emu-val> array.
  
  </li><li> 2015-08-21 -- Expanded the discussion of Service Workers and Shared Workers.
  
  </li><li> 2015-08-18 -- Reformat, update to ecmarkup 1.7.
  
  </li><li> 2015-08-06 -- Added sections on forward progress and clarifications and changes to worker semantics.
  
  </li><li> 2015-07-09 -- Ongoing cleanup and minor bug fixing.  Restated the memory model.
  
  </li><li> 2015-07-08 -- Initial translation from the original proposal.

</li></ul>

</emu-intro>

<emu-clause id="Overview">
  <h1><span class="secnum">1</span>Overview (ES6 4)<span class="utils"><span class="anchor"><a href="#Overview">#</a></span></span></h1>
  <emu-clause id="Overview.Overview">
    <h1><span class="secnum">1.1</span>ECMAScript Overview (ES6 4.2)<span class="utils"><span class="anchor"><a href="#Overview.Overview">#</a></span></span></h1>
    <p>In the third paragraph, include  <b>SharedArrayBuffer</b> after  <b>ArrayBuffer</b>.</p>
  </emu-clause>
  <emu-clause id="Overview.Terms">
    <h1><span class="secnum">1.2</span>Terms and Definitions (ES6 4.3)<span class="utils"><span class="anchor"><a href="#Overview.Terms">#</a></span></span></h1>
    <emu-clause id="Overview.Terms.Agent">
      <h1><span class="secnum">1.2.1</span>Agent<span class="utils"><span class="anchor"><a href="#Overview.Terms.Agent">#</a></span></span></h1>
      <p> The combination of an instance of an ECMAScript execution environment and the ECMAScript programs running within that environment.  </p>
      <emu-note><span class="note">Note</span>
        <p> (Issue 27) This should be worded in terms of running 'jobs', and it needs to be broken out of Terms and Definitions and given a proper section, probably within ES6 section 8.  </p>
      </emu-note>
    </emu-clause>
    <emu-clause id="Overview.Terms.AgentComm">
      <h1><span class="secnum">1.2.2</span>Agent communication<span class="utils"><span class="anchor"><a href="#Overview.Terms.AgentComm">#</a></span></span></h1>
      <p> Two agents are said to be able to communicate through shared memory if there can exist a Shared <emu-xref href="#sec-data-blocks"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-data-blocks">Data Block</a></emu-xref> that can come to be referenced from both agents, not necessarily at the same time.  (Note this does not require the agents to have overlapping lifetimes.)  </p>
    </emu-clause>
    <emu-clause id="Overview.Terms.Cluster">
      <h1><span class="secnum">1.2.3</span>Agent cluster<span class="utils"><span class="anchor"><a href="#Overview.Terms.Cluster">#</a></span></span></h1>
      <p> A maximal set of agents that are able to communicate through shared memory.  </p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="DataTypesValues">
  <h1><span class="secnum">2</span>ECMAScript Data Types and Values (ES6 6)<span class="utils"><span class="anchor"><a href="#DataTypesValues">#</a></span></span></h1>
  
  <emu-clause id="DataTypesValues.LanguageTypes">
    <h1><span class="secnum">2.1</span>ECMAScript Language Types (ES6 6.1)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes">#</a></span></span></h1>
    <emu-clause id="DataTypesValues.LanguageTypes.Number">
      <h1><span class="secnum">2.1.1</span>The Number Type (ES6 6.1.6)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes.Number">#</a></span></span></h1>
      <p>In the NOTE, include  <b>SharedArrayBuffer</b> along with  <b>ArrayBuffer</b>.</p>
    </emu-clause>
    <emu-clause id="DataTypesValues.LanguageTypes.Object">
      <h1><span class="secnum">2.1.2</span>The Object Type (ES6 6.1.7)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes.Object">#</a></span></span></h1>
      <emu-clause id="DataTypesValues.LanguageTypes.Object.Intrinsic">
        <h1><span class="secnum">2.1.2.1</span>Well-Known Intrinsic Objects (ES6 6.1.7.4)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes.Object.Intrinsic">#</a></span></span></h1>
        <p>In table 7, include rows for %SharedArrayBuffer% and %SharedArrayBufferPrototype% in the manner of the rows for ArrayBuffer.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  
  <emu-clause id="DataTypesValues.SpecTypes">
    <h1><span class="secnum">2.2</span>ECMAScript Specification Types (ES6 6.2)<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes">#</a></span></span></h1>
    <emu-clause id="DataTypesValues.SpecTypes.DataBlocks">
      <h1><span class="secnum">2.2.1</span>Data blocks (ES6 6.2.6)<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks">#</a></span></span></h1>
      <p> Insert the following paragraph after the third:  </p>
      <p> A data block that resides in memory that can be referenced from multiple agents is designated a Shared <emu-xref href="#sec-data-blocks"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-data-blocks">Data Block</a></emu-xref>.  </p>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes">
        <h1><span class="secnum">2.2.1.1</span>CopyDataBlockBytes( toBlock, toIndex, fromBlock, fromIndex, count ) (ES6 6.2.6.2)<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes">#</a></span></span></h1>
        <p>Modify this algorithm as follows:</p>
        <ul>
          <li> In step 1, allow also a Shared <emu-xref href="#sec-data-blocks"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-data-blocks">Data Block</a></emu-xref>.
        
        </li></ul>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock">
        <h1><span class="secnum">2.2.1.2</span>CreateSharedByteDataBlock( size )<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock">#</a></span></span></h1>
        <p>When the abstract operation CreateSharedByteDataBlock is called with integer argument size, the following steps are taken:</p>
        <emu-alg><ol><li>Assert: <var>size</var> &gt;= 0.</li><li>Let <var>db</var> be a new Shared <emu-xref href="#sec-data-blocks"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-data-blocks">Data Block</a></emu-xref> value consisting of <var>size</var> bytes. If it is impossible to create such a Shared <emu-xref href="#sec-data-blocks"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-data-blocks">Data Block</a></emu-xref>, throw a <emu-const>RangeError</emu-const> exception.</li><li>Set all of the bytes of <var>db</var> to 0.</li><li>Return <var>db</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID" aoid="SharedDataBlockID">
        <h1><span class="secnum">2.2.1.3</span>SharedDataBlockID( block )<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">#</a></span></span></h1>
        <p>When the abstract operation SharedDataBlockID is called with Shared <emu-xref href="#sec-data-blocks"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-data-blocks">Data Block</a></emu-xref> argument <var>block</var>, the following steps are taken:</p>
        <emu-alg><ol><li>Let <var>G</var> be an address-free identifier for <var>block</var>.  All agents in the same cluster have the same value for <var>G</var> for any given <var>block</var>.</li><li>Return <var>G</var>.
        </li></ol></emu-alg>
        <emu-note><span class="note">Note</span>
          <p>The Shared <emu-xref href="#sec-data-blocks"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-data-blocks">Data Block</a></emu-xref> ID is used by the futex mechanism and names <var>block</var> independently of any virtual addresses it may be mapped to in any particular agent.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="ExecutableCodeAndContexts">
  <h1><span class="secnum">3</span>Executable Code and Execution Contexts (ES6 8)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts">#</a></span></span></h1>
  <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues">
    <h1><span class="secnum">3.1</span>Jobs and Job Queues (ES6 8.4)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.JobsAndJobQueues">#</a></span></span></h1>
    <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues.Progress">
      <h1><span class="secnum">3.1.1</span>Forward Progress Guarantees<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.JobsAndJobQueues.Progress">#</a></span></span></h1>
      <p>Implementations should ensure that all unblocked jobs eventually make progress.  </p>
      <emu-note><span class="note">Note</span>
        <p>(Issue 28) This section may be formalized at least partly in the terms of the C++ working paper on forward progress, see the referenced issue, or it may be left as-is.  An ES6 job is most plausibly a 'Concurrent agent' in the terms of that paper.  </p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="GlobalObject">
  <h1><span class="secnum">4</span>The Global Object (ES6 18)<span class="utils"><span class="anchor"><a href="#GlobalObject">#</a></span></span></h1>
  <emu-clause id="GlobalObject.ConstructorProps">
    <h1><span class="secnum">4.1</span>Constructor Properties of the Global Object (ES6 18.3)<span class="utils"><span class="anchor"><a href="#GlobalObject.ConstructorProps">#</a></span></span></h1>
    <emu-clause id="GlobalObject.ConstructorProps.SharedArrayBuffer">
      <h1><span class="secnum">4.1.1</span>SharedArrayBuffer<span class="utils"><span class="anchor"><a href="#GlobalObject.ConstructorProps.SharedArrayBuffer">#</a></span></span></h1>
      <p> Add a new subsection for SharedArrayBuffer, pointing to the appropriate new section (below).</p>
    </emu-clause>
    <emu-clause id="GlobalObject.ConstructorProps.Atomics">
      <h1><span class="secnum">4.1.2</span>Atomics<span class="utils"><span class="anchor"><a href="#GlobalObject.ConstructorProps.Atomics">#</a></span></span></h1>
      <p> Add a new subsection for Atomics, pointing to the appropriate new section (below).</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<!--
AllocateTypedArray only allocates an ArrayBuffer if length is specified.
These call AllocateTypedArray with a specified length:
  TypedArrayFrom (twice)
   called from:
     %TypedArray% ( object )
     %TypedArray%.from ( source [,mapFn [,thisArg]] )
  %TypedArray%.of ( ...items ) 
  %TypedArray%.prototype.filter ( callbackFn [, thisArg] )
  %TypedArray%.prototype.slice ( start, end )
  %TypedArray% ()
  %TypedArray% (length)
  -->

<emu-clause id="IndexedCollections">
  <h1><span class="secnum">5</span>Indexed Collections (ES6 22)<span class="utils"><span class="anchor"><a href="#IndexedCollections">#</a></span></span></h1>
  <emu-clause id="IndexedCollections.TypedArray">
    <h1><span class="secnum">5.1</span>TypedArray Objects (ES6 22.2)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray">#</a></span></span></h1>
    <emu-note><span class="note">Note</span>
      <p>(Issue 29)  This specification extends the TypedArray specification to allow TypedArrays to view SharedArrayBuffers.  There is a question whether existing TypedArray methods that create a new TypedArray on top of a new ArrayBuffer (%TypedArray%.prototype.filter, %TypedArray%.prototype.map, %TypedArray%.prototype.slice, %TypedArray%.prototype.subarray) should continue to create an ArrayBuffer even if the input buffer is a SharedArrayBuffer, or whether they should instead create a SharedArrayBuffer in that case.</p>
      <p>(Issue 30) Should TypedArray constructors should be extended to allow them to allocate shared memory?</p>
      <p>(Issue 31) Should TypedArray static methods (%TypedArray%.of, %TypedArray%.from) should be extended to allow them to allocate shared memory?</p>
      <p>For the time being, I have opted not to change any of those functions: shared memory can only be created by explicitly invoking the constructor of SharedArrayBuffer (or the constructors of any user-defined subclasses of SharedArrayBuffer).</p>
    </emu-note>

    <emu-clause id="IndexedCollections.TypedArray.intrinsic">
      <h1><span class="secnum">5.1.1</span>The %TypedArray% intrinsic object (ES6 22.2.1)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.intrinsic">#</a></span></span></h1>

      <emu-clause id="IndexedCollections.TypedArray.intrinsic.constructFromObject">
        <h1><span class="secnum">5.1.1.1</span>%TypedArray%( object ) (ES6 22.2.1.4)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.intrinsic.constructFromObject">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <ul>
          <li> Add the restriction on the applicability of this constructor that it does not apply if the object has a [[SharedArrayBufferData]] internal slot.
        
        </li></ul>
      </emu-clause>

      <emu-clause id="IndexedCollections.TypedArray.intrinsic.constructFromBuffer">
        <h1><span class="secnum">5.1.1.2</span>%TypedArray%( buffer [ , byteOffset [ , length ] ] ) (ES6 22.2.1.5)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.intrinsic.constructFromBuffer">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <ul>
          <li>In the first paragraph, allow also an object that has a [[SharedArrayBufferData]] internal slot.
          
          </li><li>In step 1, allow also an object that has a [[SharedArrayBufferData]] internal slot.
          
          </li><li>In step 12, if <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>buffer</var>) then let <var>bufferByteLength</var> be the value of <var>buffer</var>'s [[SharedArrayBufferByteLength]] internal slot.
        
        </li></ul>
      </emu-clause>

    </emu-clause> <!-- intrinsic object -->

    <emu-clause id="IndexedCollections.TypedArray.prototype">
      <h1><span class="secnum">5.1.2</span>Properties of the %TypedArrayPrototype% object (ES6 22.2.3)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype">#</a></span></span></h1>
      <emu-clause id="IndexedCollections.TypedArray.prototype.set">
        <h1><span class="secnum">5.1.2.1</span> %TypedArray%.prototype.set( overloaded [ , offset ] ) (ES6 22.2.3.22)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype.set">#</a></span></span></h1>
        <emu-clause id="IndexedCollections.TypedArray.prototype.setFromTypedArray">
          <h1><span class="secnum">5.1.2.1.1</span>%TypedArray%.prototype.set( typedArray [, offset ] ) (ES6 22.2.3.22.2)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype.setFromTypedArray">#</a></span></span></h1>
          <p> Before step 24, insert the following algorithm:</p>
          <emu-alg><ol><li>If <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>srcBuffer</var>) is <emu-const>true</emu-const> and <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>targetBuffer</var>) is <emu-const>true</emu-const> then:<ol><li>Let <var>srcBlock</var> be <var>srcBuffer</var>'s [[SharedArrayBufferData]] internal slot</li><li>Let <var>targetBlock</var> be <var>targetBuffer</var>'s [[SharedArrayBufferData]] internal slot</li><li>Let <var>srcId</var> be <emu-xref aoid="SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">SharedDataBlockID</a></emu-xref>(<var>srcBlock</var>)</li><li>Let <var>targetId</var> be <emu-xref aoid="SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">SharedDataBlockID</a></emu-xref>(<var>targetBlock</var>)</li><li>If <var>srcId</var> = <var>targetId</var> then let <var>doClone</var> be <emu-const>true</emu-const>, else let <var>doClone</var> be <emu-const>false</emu-const></li></ol></li><li>Else, let <var>doClone</var> be <emu-const>false</emu-const>
          </li></ol></emu-alg>
          <p> Then, in step 24, also choose to clone srcBuffer if <var>doClone</var> is <emu-const>true</emu-const>.  </p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="StructuredData">
  <h1><span class="secnum">6</span>Structured Data (ES6 24)<span class="utils"><span class="anchor"><a href="#StructuredData">#</a></span></span></h1>

  <emu-clause id="StructuredData.ArrayBuffer">
    <h1><span class="secnum">6.1</span>ArrayBuffer Objects (ES6 24.1)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer">#</a></span></span></h1>

    <emu-clause id="StructuredData.ArrayBuffer.abstract">
      <h1><span class="secnum">6.1.1</span>Abstract Operations for ArrayBuffer (ES6 24.1.1)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract">#</a></span></span></h1>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.IsDetachedBuffer" aoid="IsDetachedBuffer">
        <h1><span class="secnum">6.1.1.1</span>IsDetachedBuffer( arrayBuffer ) (ES6 24.1.1.2)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer">#</a></span></span></h1>
        <p> This algorithm is rewritten as follows:  </p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="Type"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>arrayBuffer</var>) is Object and it has an [[ArrayBufferData]] internal slot or a [[SharedArrayBufferData]] internal slot.</li><li>If <var>arrayBuffer</var> has an [[ArrayBufferData]] internal slot and <var>arrayBuffer</var>’s [[ArrayBufferData]] internal slot is null, return <emu-const>true</emu-const>.</li><li>Return <emu-const>false</emu-const>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.CloneArrayBuffer" aoid="CloneArrayBuffer">
        <h1><span class="secnum">6.1.1.2</span>CloneArrayBuffer( srcBuffer, srcByteOffset [, cloneConstructor] ) (ES6 24.1.1.4)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.CloneArrayBuffer">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <ul>
          <li> In the introductory paragraph, note that this function can take a SharedArrayBuffer as well.
          
          </li><li> In step 1, allow for a [[SharedArrayBufferData]] internal slot.
          
          </li><li> In step 4, if <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>srcBuffer</var>) then let <var>srcLength</var> be the value of <var>srcBuffer</var>'s [[SharedArrayBufferByteLength]] internal slot.
          
          </li><li> In step 7, if <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>srcBuffer</var>) then let <var>srcBlock</var> be the value of <var>srcBuffer</var>’s [[SharedArrayBufferData]] internal slot.
        
        </li></ul>
      </emu-clause>
      
      <emu-clause id="StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" aoid="GetValueFromBuffer">
        <h1><span class="secnum">6.1.1.3</span>GetValueFromBuffer( arrayBuffer, byteIndex, type, isLittleEndian ) (ES6 24.1.1.5)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">#</a></span></span></h1>
        <p> This algorithm is modified as follows:</p>
        <ul>
          <li> The parameter <var>arrayBuffer</var> can be an ArrayBuffer or SharedArrayBuffer.
          
          </li><li> All agents in the same cluster must compute the same value for <var>isLittleEndian</var> if it is not present.
          
          </li><li> In step 4, if <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>( <var>arrayBuffer</var> ) is <emu-const>true</emu-const> then use the value of <var>arrayBuffer</var>'s [[SharedArrayBufferData]] internal slot.
        
        </li></ul>

        <emu-note><span class="note">Note</span>
          <p> If <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>( <var>arrayBuffer</var> ) is <emu-const>true</emu-const> then two consecutive calls to GetValueFromBuffer with the same arguments in the same agent may not return the same value even if there is no write to the buffer in that agent between the read calls: another agent may have written to the buffer.  This restricts compiler optimizations as follows.  If a program loads a value, and then uses the loaded value several places, an ECMAScript implementation must not re-load the value for any of the uses even if it can prove the agent does not overwrite the value in memory.  It must also prove that no concurrent agent overwrites the value.  </p>
        </emu-note>

      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.SetValueInBuffer" aoid="SetValueInBuffer">
        <h1><span class="secnum">6.1.1.4</span>SetValueInBuffer( arrayBuffer, byteIndex, type, value, isLittleEndian ) (ES6 24.1.1.6)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">#</a></span></span></h1>
        <p> This algorithm is modified as follows:</p>
        <ul>
          <li> The parameter <var>arrayBuffer</var> can be an ArrayBuffer or SharedArrayBuffer.
          
          </li><li> All agents in the same cluster must compute the same value for <var>isLittleEndian</var> if it is not present.
          
          </li><li> In step 5, if <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>( <var>arrayBuffer</var> ) is <emu-const>true</emu-const> then use the value of <var>arrayBuffer</var>'s [[SharedArrayBufferData]] internal slot.
        
        </li></ul>

        <emu-note><span class="note">Note</span>
          <p> When SetValueInBuffer is called to set bytes in shared memory the implementation may set several bytes at a time (and that is the normal case), but it may not use read-modify-write on a larger datum, as that might introduce data races where the source program has none.  Data races are discussed in the section on the Atomics object.  </p>
        </emu-note>
      </emu-clause>
      
    </emu-clause> <!-- abstract -->
  </emu-clause> <!-- ArrayBuffer -->

  <emu-clause id="StructuredData.DataView">
    <h1><span class="secnum">6.2</span>DataView Objects (ES6 24.2)<span class="utils"><span class="anchor"><a href="#StructuredData.DataView">#</a></span></span></h1>
    <emu-clause id="StructuredData.DataView.constructor">
      <h1><span class="secnum">6.2.1</span>The DataView Constructor (ES6 24.2.2)<span class="utils"><span class="anchor"><a href="#StructuredData.DataView.constructor">#</a></span></span></h1>
      <emu-clause id="StructuredData.DataView.constructor.detail">
        <h1><span class="secnum">6.2.1.1</span>DataView( buffer [ , byteOffset [ , byteLength ] ] ) (ES6 24.2.2.1)<span class="utils"><span class="anchor"><a href="#StructuredData.DataView.constructor.detail">#</a></span></span></h1>
        <p> This algorithm is modified as follows:  </p>
        <ul>
          <li> In step 3, allow also a [[SharedArrayBufferData]] internal slot.
          
          </li><li> In step 9, if <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>buffer</var>) then let <var>bufferByteLength</var> be the value of <var>buffer</var>'s [[SharedArrayBufferByteLength]] internal slot.
        
        </li></ul>
      </emu-clause>
    </emu-clause>
  </emu-clause> <!-- DataView -->

  <emu-clause id="StructuredData.SharedArrayBuffer">
    <h1><span class="secnum">6.3</span>SharedArrayBuffer Objects<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer">#</a></span></span></h1>

    <emu-clause id="StructuredData.SharedArrayBuffer.abstract">
      <h1><span class="secnum">6.3.1</span>Abstract Operations for SharedArrayBuffer<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.abstract">#</a></span></span></h1>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer">
        <h1><span class="secnum">6.3.1.1</span>AllocateSharedArrayBuffer( constructor, byteLength )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer">#</a></span></span></h1>
        <p> The abstract operation AllocateSharedArrayBuffer with arguments <var>constructor</var> and <var>byteLength</var> is used to create a SharedArrayBuffer object. It performs the following steps:</p>

        <emu-alg><ol><li>Let <var>obj</var> be <emu-xref aoid="OrdinaryCreateFromConstructor"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ordinarycreatefromconstructor">OrdinaryCreateFromConstructor</a></emu-xref>(constructor, "%SharedArrayBufferPrototype%", «‍[[SharedArrayBufferData]], [[SharedArrayBufferByteLength]]» ).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>obj</var>).</li><li>Assert: <var>byteLength</var> is a positive integer.</li><li>Let block be CreateSharedByteDataBlock(<var>byteLength</var>).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>block</var>).</li><li>Set <var>obj</var>’s [[SharedArrayBufferData]] internal slot to block.</li><li>Set <var>obj</var>’s [[SharedArrayBufferByteLength]] internal slot to <var>byteLength</var>.</li><li>Return <var>obj</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.IsSharedMemory" aoid="IsSharedMemory">
        <h1><span class="secnum">6.3.1.2</span>IsSharedMemory( obj )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">#</a></span></span></h1>
        <p> IsSharedMemory tests whether an object represents shared memory.  </p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="Type"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>obj</var>) is <emu-const>Object</emu-const> and it has an [[ArrayBufferData]] internal slot or a [[SharedArrayBufferData]] internal slot.</li><li>If <var>obj</var> has a [[SharedArrayBufferData]] internal slot then return <emu-const>true</emu-const>.</li><li>Return <emu-const>false</emu-const>.
        </li></ol></emu-alg>
      </emu-clause>

    </emu-clause> <!-- abstract -->

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor">
      <h1><span class="secnum">6.3.2</span>The SharedArrayBuffer Constructor<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor">#</a></span></span></h1>
      <p> The SharedArrayBuffer constructor is the %SharedArrayBuffer% intrinsic object and the initial value of the <emu-const>SharedArrayBuffer</emu-const> property of the global object. When called as a constructor it creates and initializes a new SharedArrayBuffer object.  The SharedArrayBuffer constructor is not intended to be called as a function and will throw an exception when called in that manner.  </p>

      <p> The SharedArrayBuffer constructor is designed to be subclassable. It may be used as the value of an <emu-const>extends</emu-const> clause of a class definition. Subclass constructors that intend to inherit the specified SharedArrayBuffer behaviour must include a <emu-const>super</emu-const> call to the SharedArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support the <emu-const>SharedArrayBuffer.prototype</emu-const> built-in methods.  </p>

      <emu-note><span class="note">Note</span>
        <p> Unlike an ArrayBuffer, a SharedArrayBuffer cannot become detached, and its internal [[SharedArrayBufferData]] slot is never <emu-const>undefined</emu-const>.</p>
      </emu-note>
      
      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.withLength">
        <h1><span class="secnum">6.3.2.1</span>SharedArrayBuffer( length )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.withLength">#</a></span></span></h1>
        <p> SharedArrayBuffer called with argument length performs the following steps:  </p>
        <emu-alg><ol><li>If NewTarget is <emu-const>undefined</emu-const>, throw a <emu-const>TypeError</emu-const> exception.</li><li>Let <var>numberLength</var> be <emu-xref aoid="ToNumber"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tonumber">ToNumber</a></emu-xref>(<var>length</var>).</li><li>Let <var>byteLength</var> be <emu-xref aoid="ToLength"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tolength">ToLength</a></emu-xref>(<var>numberLength</var>).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>byteLength</var>).</li><li>If <emu-xref aoid="SameValueZero"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-samevaluezero">SameValueZero</a></emu-xref>(<var>numberLength</var>, <var>byteLength</var>) is <emu-const>false</emu-const>, throw a <emu-const>RangeError</emu-const> exception.</li><li>Return AllocateSharedArrayBuffer(NewTarget, <var>byteLength</var>).
        </li></ol></emu-alg>
      </emu-clause>
    </emu-clause> <!-- constructor -->

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties">
      <h1><span class="secnum">6.3.3</span>Properties of the SharedArrayBuffer constructor<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.properties">#</a></span></span></h1>

      <p>The value of the [[Prototype]] internal slot of the SharedArrayBuffer constructor is the intrinsic object %FunctionPrototype% (q.v.).</p>

      <p>Besides its <emu-const>length</emu-const> property (whose value is 1), the SharedArrayBuffer constructor has the following properties:</p>
      
      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.isView">
        <h1><span class="secnum">6.3.3.1</span>SharedArrayBuffer.isView( arg )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.properties.isView">#</a></span></span></h1>
        <p>The isView function takes one argument arg, and performs the following steps are taken:</p>
        <emu-alg><ol><li>If <emu-xref aoid="Type"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>arg</var>) is not <emu-const>Object</emu-const>, return <emu-const>false</emu-const>.</li><li>If <var>arg</var> has a [[ViewedArrayBuffer]] internal slot, return <emu-const>true</emu-const>.</li><li>Return <emu-const>false</emu-const>.
        </li></ol></emu-alg>
        <emu-note><span class="note">Note</span>
          <p> (Issue 32)  This function is identical to ArrayBuffer.isView, since TypedArrays use the [[ViewedArrayBuffer]] internal slot to hold both unshared and shared views.  There is an opportunity to do something more interesting, namely, to make SharedArrayBuffer.isView() return <emu-const>true</emu-const> only if its argument is viewing a SharedArrayBuffer, and to make ArrayBuffer.isView() return <emu-const>false</emu-const> if its argument is viewing a SharedArrayBuffer.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.prototype">
        <h1><span class="secnum">6.3.3.2</span>SharedArrayBuffer.prototype<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.properties.prototype">#</a></span></span></h1>
        <p> The initial value of SharedArrayBuffer.prototype is the intrinsic object %SharedArrayBufferPrototype% (q.v.).</p>
        <p> This property has the attributes { [[Writable]]: <emu-const>false</emu-const>, [[Enumerable]]: <emu-const>false</emu-const>, [[Configurable]]: <emu-const>false</emu-const> }.</p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.get_species">
        <h1><span class="secnum">6.3.3.3</span>get SharedArrayBuffer [ @@species ]<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.properties.get_species">#</a></span></span></h1>
        <p><code>SharedArrayBuffer[@@species]</code> is an accessor property whose set accessor function is <emu-const>undefined</emu-const>. Its get accessor function performs the following steps:</p>
        <emu-alg><ol><li>Return the <emu-const>this</emu-const> value.
        </li></ol></emu-alg>
        <p> The value of the name property of this function is "<code>get [Symbol.species]</code>".</p>
      </emu-clause>
    </emu-clause> <!-- properties -->

    <emu-clause id="StructuredData.SharedArrayBuffer.prototype">
      <h1><span class="secnum">6.3.4</span>Properties of the SharedArrayBuffer prototype object<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype">#</a></span></span></h1>

      <p>The SharedArrayBuffer prototype object is the intrinsic object %SharedArrayBufferPrototype%. The value of the [[Prototype]] internal slot of the SharedArrayBuffer prototype object is the intrinsic object %ObjectPrototype% (19.1.3). The SharedArrayBuffer prototype object is an ordinary object. It does not have a [[SharedArrayBufferData]] or [[SharedArrayBufferByteLength]] internal slot.</p>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.get_byteLength">
        <h1><span class="secnum">6.3.4.1</span>get SharedArrayBuffer.prototype.byteLength<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.get_byteLength">#</a></span></span></h1>

        <p> SharedArrayBuffer.prototype.byteLength is an accessor property whose set accessor function is <emu-const>undefined</emu-const>. Its get accessor function performs the following steps:  </p>

        <emu-alg><ol><li>Let <var>O</var> be the <emu-const>this</emu-const> value.</li><li>If <emu-xref aoid="Type"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>O</var>) is not <emu-const>Object</emu-const>, throw a <emu-const>TypeError</emu-const> exception.</li><li>If <var>O</var> does not have a [[SharedArrayBufferData]] internal slot, throw a <emu-const>TypeError</emu-const> exception.</li><li>Let <var>length</var> be the value of <var>O</var>’s [[SharedArrayBufferByteLength]] internal slot.</li><li>Return <var>length</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.constructor">
        <h1><span class="secnum">6.3.4.2</span>SharedArrayBuffer.prototype.constructor<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.constructor">#</a></span></span></h1>
        <p> The initial value of <code>SharedArrayBuffer.prototype.constructor</code> is the intrinsic object %SharedArrayBuffer%.  </p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.slice">
        <h1><span class="secnum">6.3.4.3</span>SharedArrayBuffer.prototype.slice( start, end )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.slice">#</a></span></span></h1>
        <p> The following steps are taken:  </p>
        <emu-alg><ol><li>Let <var>O</var> be the <emu-const>this</emu-const> value.</li><li>If <emu-xref aoid="Type"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>O</var>) is not <emu-const>Object</emu-const>, throw a <emu-const>TypeError</emu-const> exception.</li><li>If <var>O</var> does not have a [[SharedArrayBufferData]] internal slot, throw a <emu-const>TypeError</emu-const> exception.</li><li>Let <var>len</var> be the value of <var>O</var>’s [[SharedArrayBufferByteLength]] internal slot.</li><li>Let <var>relativeStart</var> be <emu-xref aoid="ToInteger"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tointeger">ToInteger</a></emu-xref>(<var>start</var>).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>relativeStart</var>).</li><li>If <var>relativeStart</var> &lt; 0, let first be max((<var>len</var> + <var>relativeStart</var>),0); else let first be min(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-const>undefined</emu-const>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be <emu-xref aoid="ToInteger"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tointeger">ToInteger</a></emu-xref>(<var>end</var>).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>relativeEnd</var>).</li><li>If <var>relativeEnd</var> &lt; 0, let <var>final</var> be max((<var>len</var> + <var>relativeEnd</var>),0); else let <var>final</var> be min(<var>relativeEnd</var>, <var>len</var>).</li><li>Let <var>newLen</var> be max(<var>final</var> - <var>first</var>,0).</li><li>Let <var>ctor</var> be <emu-xref aoid="SpeciesConstructor"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-speciesconstructor">SpeciesConstructor</a></emu-xref>(<var>O</var>, %SharedArrayBuffer%).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>ctor</var>).</li><li>Let <var>new</var> be <emu-xref aoid="Construct"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-construct">Construct</a></emu-xref>(<var>ctor</var>, «newLen»).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>new</var>).</li><li>If <var>new</var> does not have a [[SharedArrayBufferData]] internal slot, throw a <emu-const>TypeError</emu-const> exception.</li><li>If <emu-xref aoid="SameValue"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-samevalue">SameValue</a></emu-xref>(<var>new</var>, <var>O</var>) is <emu-const>true</emu-const>, throw a <emu-const>TypeError</emu-const> exception.</li><li>If the value of <var>new</var>’s [[SharedArrayBufferByteLength]] internal slot &lt; <var>newLen</var>, throw a <emu-const>TypeError</emu-const> exception.</li><li>Let <var>fromBuf</var> be the value of <var>O</var>’s [[SharedArrayBufferData]] internal slot.</li><li>Let <var>toBuf</var> be the value of <var>new</var>’s [[SharedArrayBufferData]] internal slot.</li><li>Perform <emu-xref aoid="CopyDataBlockBytes"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>toBuf</var>, 0, <var>fromBuf</var>, <var>first</var>, <var>newLen</var>).</li><li>Return <var>new</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.toString">
        <h1><span class="secnum">6.3.4.4</span>SharedArrayBuffer.prototype[ @@toStringTag ]<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.toString">#</a></span></span></h1>
        <p> The initial value of the @@toStringTag property is the String value <code>"SharedArrayBuffer"</code>.</p>

        <p>This property has the attributes { [[Writable]]: <emu-const>false</emu-const>, [[Enumerable]]: <emu-const>false</emu-const>, [[Configurable]]: <emu-const>true</emu-const> }.</p>
      </emu-clause>
    </emu-clause> <!-- prototype -->

    <emu-clause id="StructuredData.SharedArrayBuffer.instances">
      <h1><span class="secnum">6.3.5</span>Properties of the SharedArrayBuffer instances<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.instances">#</a></span></span></h1>

      <p> SharedArrayBuffer instances inherit properties from the SharedArrayBuffer prototype object. SharedArrayBuffer instances each have a [[SharedArrayBufferData]] internal slot and a [[SharedArrayBufferByteLength]] internal slot.  </p>

      <emu-note><span class="note">Note</span>
        <p> SharedArrayBuffer instances, unlike ArrayBuffer instances, are never detached.  </p>
      </emu-note>
    </emu-clause> <!-- instances -->

  </emu-clause> <!-- SharedArrayBuffer -->
</emu-clause> <!-- Structured data -->

<emu-clause id="AtomicsObject">
  <h1><span class="secnum">7</span>The Atomics Object<span class="utils"><span class="anchor"><a href="#AtomicsObject">#</a></span></span></h1>
  
  <emu-clause id="AtomicsObjectValueProps">
    <h1><span class="secnum">7.1</span>Value Properties of the Atomics Object<span class="utils"><span class="anchor"><a href="#AtomicsObjectValueProps">#</a></span></span></h1>
    <emu-clause id="Atomics.OK">
      <h1><span class="secnum">7.1.1</span>Atomics.OK<span class="utils"><span class="anchor"><a href="#Atomics.OK">#</a></span></span></h1>
      <p>The value 0.</p>
    </emu-clause>
    <emu-clause id="Atomics.NOTEQUAL">
      <h1><span class="secnum">7.1.2</span>Atomics.NOTEQUAL<span class="utils"><span class="anchor"><a href="#Atomics.NOTEQUAL">#</a></span></span></h1>
      <p>The value -1.</p>
    </emu-clause>
    <emu-clause id="Atomics.TIMEDOUT">
      <h1><span class="secnum">7.1.3</span>Atomics.TIMEDOUT<span class="utils"><span class="anchor"><a href="#Atomics.TIMEDOUT">#</a></span></span></h1>
      <p>The value -2.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="AtomicsObjectFunctionProps.semantics">
    <h1><span class="secnum">7.2</span>Runtime semantics<span class="utils"><span class="anchor"><a href="#AtomicsObjectFunctionProps.semantics">#</a></span></span></h1>
    
    <emu-clause id="Atomics.WithAtomicAccessTo">
      <h1><span class="secnum">7.2.1</span>With atomic access to ( buffer, indexedPosition, elementSize )<span class="utils"><span class="anchor"><a href="#Atomics.WithAtomicAccessTo">#</a></span></span></h1>
      
      <p> Let  <em>atomic accesses</em> be those algorithm steps that
        are labeled 'With atomic access to ...' in the algorithms below,
        ie, atomic load, atomic store, and the atomic read-modify-write
        operations add, sub, and, or, xor, exchange, and
        compareExchange.</p>

      <p> Let  <em>data accesses</em> be those invocations of
        <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>() and <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>() that are not part of
        atomic accesses.</p>
        
      <p> Let the  <em>access range</em> of an atomic or data access be the
        memory cells read or written by the access.  </p>

      <p> Atomic accesses that are  <em>viable</em> are performed in a
        single total order (the  <em>synchronization order</em>)
        consistent with each agent's program order.  An atomic access
        is not viable if its access range intersects with but is not
        equal to the access range of another atomic access from
        another agent that could be adjacent to it in the total
        order.  (None of the accesses that intersect in that way are viable.)  </p>

      <emu-note><span class="note">Note 1</span>
        <p> ECMAScript allows TypedArrays to alias each other and
          exposes atomic accesses directly on TypedArrays.  It is thus
          possible for atomic accesses of different size to partly
          overlapping access ranges to be performed concurrently.
          Requiring overlapping concurrent atomic accesses to be part
          of the total atomics order would impose significant run-time
          costs on some, possibly all, platforms.</p>

        <p> For example, on a platform such as MIPS32 that only has
          4-byte atomics, an 8-byte atomic access (eg for Int64) must
          be implemented with a lock, yet it is desirable to implement
          4-byte atomic accesses directly.  Requiring overlapping
          concurrent accesses to be part of the total atomics order
          would require all atomic accesses to use the lock.  </p>

        <p> In a more general case, if we were to provide a method to
          (say) atomically compare-and-exchange a larger region of
          memory, such a primitive would have to use a lock on
          virtually all platforms, forcing all platforms to use locks
          even for smaller atomic accesses.  </p>
      </emu-note>

      <p> In the following, "atomic access" refers only to viable
        atomic accesses, and "data access" refers also to non-viable
        atomic accesses.  </p>
      
      <p> An  <em>event</em> in an agent is a atomic access, a
        data access, the sending of a SharedArrayBuffer, the receipt
        of a SharedArrayBuffer, the action of waking up a sleeping
        agent, or a sleeping agent being woken up.  Events can also be
        embedding-specific.  </p>

      <emu-note><span class="note">Note 2</span>
        <p> Examples of embedding-specific events are starting and stopping agents
          and communicating via other channels than shared memory.  </p>
      </emu-note>

      <p> An event A  <em>happens before</em> another event B if either:</p>
      <ol>
        <li> A precedes B in an agent's program order,
        
        </li><li> A is the sending of a SharedArrayBuffer and B is the
        receipt in another agent of that buffer,
        
        </li><li> A is the waking up a sleeping agent and B the agent being
        woken up,
        
        </li><li> A and B are paired embedding-specific events in separate
        agents where the embedding states that A happens before B,
        
        </li><li> A and B are both atomic accesses to identical access ranges,
          B follows A in the synchronization order, and B reads
          the value written by A, or
        
        </li><li> A happens before C and C happens before B (transitivity).
      
      </li></ol>

      <p> Executions must be such that  <em>happens before</em> is
        irreflexive (acyclic).  </p>

      <p> A data access read R only sees a write W that happens before
        R, where there is no write V such that V happens before R and
        W happens before V.  </p>
      
      <p> An atomic read R sees either the last preceding (in
        synchronization order) atomic write U to the same location, or
        a non-atomic write W that happens before R, where there is no
        write V such that V happens before R and W happens before
        V.  </p>

      <p> Two memory accesses whose access ranges intersect constitute
        a  <em>data race</em> if neither happens before the other and
        at least one of them is not an atomic access.  </p>

      <p> A write involved in a data race stores a poison value that
        can read back as anything whatsoever.  </p>

      <emu-note><span class="note">Note 3</span>
        <p> (Issue 22, broadly) There are problems with the preceding
          clause.  One problem is that the affected memory region is
          not defined.  Another problem is semantic: The intent of the
          clause is that a race poisons a delimited part of memory,
          and subsequent reads from that area of memory will see
          garbage.  However, "subsequent" is slippery and not well
          defined.  C++ has made races undefined behavior because of
          this, and Java has a complicated memory model to deal with
          it.  What is most appropriate for ES is not yet known.  </p>

        <p> Also see the NOTE on <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>() that clarifies
          that a compiler may not generate re-loads from shared
          memory.  </p>
      </emu-note>

      <emu-note><span class="note">Note 4</span>
        <p> If the execution of an agent cluster has no data races, then
          the agent cluster behaves according to one of its sequentially
          consistent executions.  </p>
      </emu-note>
        
    </emu-clause>

    <emu-clause id="Atomics.ValidateSharedIntegerTypedArray" aoid="ValidateSharedIntegerTypedArray">
      <h1><span class="secnum">7.2.2</span>Runtime semantics: ValidateSharedIntegerTypedArray( typedArray [, onlyInt32] )<span class="utils"><span class="anchor"><a href="#Atomics.ValidateSharedIntegerTypedArray">#</a></span></span></h1>
      <emu-alg><ol><li>If <emu-xref aoid="Type"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>typedArray</var>) is not Object, throw a <emu-const>TypeError</emu-const> exception.</li><li>Let <var>typeName</var> be the value of <var>typedArray</var>'s [[TypedArrayName]] internal slot</li><li>If <var>onlyInt32</var> is <emu-const>true</emu-const> then<ol><li>If <var>typeName</var> is not "Int32Array" then throw a <emu-const>TypeError</emu-const> exception</li></ol></li><li>Else<ol><li>If <var>typeName</var> is not "Int8Array", "Uint8Array", "Int16Array", "Uint16Array", "Int32Array", or "Uint32Array" then throw a <emu-const>TypeError</emu-const> exception</li></ol></li><li>If <var>typedArray</var> does not have a [[ViewedArrayBuffer]] internal slot, throw a <emu-const>TypeError</emu-const> exception.</li><li>Let <var>buffer</var> be the value of <var>typedArray</var>’s [[ViewedArrayBuffer]] internal slot.</li><li>If <emu-xref aoid="Type"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>buffer</var>) is not Object, throw a <emu-const>TypeError</emu-const> exception.</li><li>If <var>buffer</var> does not have a [[SharedArrayBufferData]] internal slot, throw a <emu-const>TypeError</emu-const> exception.</li><li>Return <var>buffer</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.ValidateAtomicAccess" aoid="ValidateAtomicAccess">
      <h1><span class="secnum">7.2.3</span>Runtime semantics: ValidateAtomicAccess( typedArray, index )<span class="utils"><span class="anchor"><a href="#Atomics.ValidateAtomicAccess">#</a></span></span></h1>
      <p> Perform the following steps:  </p>
      <emu-alg><ol><li>Assert: <var>typedArray</var> is an Object that has a [[ViewedArrayBuffer]] internal slot.</li><li>If <emu-xref aoid="Type"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>index</var>) is String then<ol><li>Let <var>numValue</var> be <emu-xref aoid="CanonicalNumericIndexString"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-canonicalnumericindexstring">CanonicalNumericIndexString</a></emu-xref>( <var>index</var> )</li><li>If <var>numValue</var> is <emu-const>undefined</emu-const> then throw a <emu-const>RangeError</emu-const> exception</li></ol></li><li>Else if <emu-xref aoid="Type"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>index</var>) is Number<ol><li>Let <var>numValue</var> be <var>index</var></li></ol></li><li>Else:<ol><li>Throw a <emu-const>RangeError</emu-const> exception</li></ol></li><li>If <emu-xref aoid="IsInteger"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-isinteger">IsInteger</a></emu-xref>(<var>numValue</var>) is <emu-const>false</emu-const> throw a <emu-const>RangeError</emu-const> exception</li><li>If <var>numValue</var> = -0 throw a <emu-const>RangeError</emu-const> exception</li><li>Let <var>length</var> be the value of <var>typedArray</var>'s [[ArrayLength]] internal slot.</li><li>If <var>numValue</var> &lt; 0 or <var>numValue</var> ≥ <var>length</var> throw a <emu-const>RangeError</emu-const> exception</li><li>Return <var>numValue</var>
      </li></ol></emu-alg>
    </emu-clause>
    
    <emu-clause id="WithinTheFutexCriticalSection">
      <h1><span class="secnum">7.2.4</span>Within the futex critical section ...<span class="utils"><span class="anchor"><a href="#WithinTheFutexCriticalSection">#</a></span></span></h1>
      <p> In the algorithms below, the algorithm step 'Within the futex critical section' means the following:</p>
      <ul>
        <li> There is a single critical section for the futex operations that is shared among all agents in a cluster.
        
        </li><li> The phrase 'Within the futex critical section' acquires that section exclusively; any return from the dependent statements releases the section.
      
      </li></ul>
    </emu-clause>

    <emu-clause id="Atomics.AgentSignifier" aoid="AgentSignifier">
      <h1><span class="secnum">7.2.5</span>Runtime semantics: AgentSignifier( )<span class="utils"><span class="anchor"><a href="#Atomics.AgentSignifier">#</a></span></span></h1>
      <p> When AgentSignifier is called without arguments then the following steps are taken.</p>
      <emu-alg><ol><li>Let <var>W</var> be an identifier that identifies the calling agent within its cluster.</li><li>Return <var>W</var>.
      </li></ol></emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.AgentCanSuspend" aoid="AgentCanSuspend">
      <h1><span class="secnum">7.2.6</span>Runtime semantics: AgentCanSuspend( )<span class="utils"><span class="anchor"><a href="#Atomics.AgentCanSuspend">#</a></span></span></h1>
      <p> When AgentCanSuspend is called without arguments then the following steps are taken.</p>
      <emu-alg><ol><li>Let <var>B</var> be <emu-const>true</emu-const> if the agent is allowed to suspend, and <emu-const>false</emu-const> otherwise.</li><li>Return <var>B</var>.
      </li></ol></emu-alg>

      <p> AgentCanSuspend always returns the same value when called from a given agent.  </p>

      <emu-note><span class="note">Note</span>
        <p> In some environments it may not be reasonable for a given agent to suspend.  For example,
          in a web browser environment, it may be reasonable to disallow suspending a document's main event
          handling thread, while still allowing workers' event handling threads to suspend.  </p>
      </emu-note>
    </emu-clause>
    
    <emu-clause id="Atomics.AddWaiter" aoid="AddWaiter">
      <h1><span class="secnum">7.2.7</span>Runtime semantics: AddWaiter( W, G, i )<span class="utils"><span class="anchor"><a href="#Atomics.AddWaiter">#</a></span></span></h1>
      <p> When AddWaiter is called with an agent signifier <var>W</var>, a Shared <emu-xref href="#sec-data-blocks"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-data-blocks">Data Block</a></emu-xref> ID <var>G</var>, and a nonnegative integer <var>i</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: The calling agent is in the futex critical section.</li><li>Assert: <var>W</var> is not in any global list of waiters</li><li>Add <var>W</var> to the end of the global list of all waiters that wait on (<var>G</var>, <var>i</var>)
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.RemoveWaiter" aoid="RemoveWaiter">
      <h1><span class="secnum">7.2.8</span>Runtime semantics: RemoveWaiter( W, G, i )<span class="utils"><span class="anchor"><a href="#Atomics.RemoveWaiter">#</a></span></span></h1>
      <p> When RemoveWaiter is called with an agent signifier <var>W</var>, a Shared <emu-xref href="#sec-data-blocks"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-data-blocks">Data Block</a></emu-xref> ID <var>G</var>, and a nonnegative integer <var>i</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: The calling agent is in the futex critical section.</li><li>Assert: <var>W</var> is in the global list of all waiters that wait on (<var>G</var>, <var>i</var>)</li><li>Remove <var>W</var> from the global list of all waiters that wait on (<var>G</var>, <var>i</var>)
      </li></ol></emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.RemoveWaiters" aoid="RemoveWaiters">
      <h1><span class="secnum">7.2.9</span>Runtime semantics: RemoveWaiters( G, i)<span class="utils"><span class="anchor"><a href="#Atomics.RemoveWaiters">#</a></span></span></h1>
      <p> When RemoveWaiters is called with Shared <emu-xref href="#sec-data-blocks"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-data-blocks">Data Block</a></emu-xref> ID <var>G</var> and a nonnegative integer <var>i</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: The calling agent is in the futex critical section.</li><li>Let <var>L</var> be a copy of the global list of all waiters that wait on (<var>G</var>, <var>i</var>)</li><li>Set the global list of all waiters that wait on (<var>G</var>, <var>i</var>) to the empty list</li><li>Return <var>L</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.Suspend" aoid="Suspend">
      <h1><span class="secnum">7.2.10</span>Runtime semantics: Suspend( W, timeout )<span class="utils"><span class="anchor"><a href="#Atomics.Suspend">#</a></span></span></h1>
      <p> When Suspend is called with a an agent signifier <var>W</var> and nonnegative number <var>timeout</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: The calling agent is in the futex critical section.</li><li>Assert: The calling agent is on some global list of waiters</li><li>Assert: <var>W</var> is equal to <emu-xref aoid="AgentSignifier"><a href="#Atomics.AgentSignifier">AgentSignifier</a></emu-xref>()</li><li>Assert: <emu-xref aoid="AgentCanSuspend"><a href="#Atomics.AgentCanSuspend">AgentCanSuspend</a></emu-xref>() is equal to true</li><li>Atomically relinquish the futex critical section and suspend <var>W</var> for up to <var>timeout</var> milliseconds.  <var>W</var> can wake up either because the timeout expired or because it was woken explicitly by another agent calling <emu-xref aoid="WakeWaiter"><a href="#Atomics.WakeWaiter">WakeWaiter</a></emu-xref>(<var>W</var>), and not for any other reasons at all.</li><li>Re-acquire the futex critical section.</li><li>If <var>W</var> was woken explicitly by another agent calling <emu-xref aoid="WakeWaiter"><a href="#Atomics.WakeWaiter">WakeWaiter</a></emu-xref>(<var>W</var>), then return <emu-const>true</emu-const></li><li>Return <emu-const>false</emu-const>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.WakeWaiter" aoid="WakeWaiter">
      <h1><span class="secnum">7.2.11</span>Runtime semantics: WakeWaiter( W )<span class="utils"><span class="anchor"><a href="#Atomics.WakeWaiter">#</a></span></span></h1>
      <p> When WakeWaiter is called with an agent signifier <var>W</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: The calling agent is in the futex critical section.</li><li>Assert: <var>W</var> is on some global list of waiters</li><li>Wake the agent <var>W</var>
      </li></ol></emu-alg>
    </emu-clause>

  </emu-clause> <!-- runtime semantics -->

  <emu-clause id="AtomicsObjectFunctionProps">
    <h1><span class="secnum">7.3</span>Function Properties of the Atomics Object<span class="utils"><span class="anchor"><a href="#AtomicsObjectFunctionProps">#</a></span></span></h1>

    <emu-clause id="Atomics.add">
      <h1><span class="secnum">7.3.1</span>Atomics.add( typedArray, index, value )<span class="utils"><span class="anchor"><a href="#Atomics.add">#</a></span></span></h1>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>buffer</var>)</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>i</var>)</li><li>Let <var>v</var> be <emu-xref aoid="ToNumber"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tonumber">ToNumber</a></emu-xref>(<var>value</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>value</var>).</li><li>Let <var>arrayTypeName</var> be the value of <var>typedArray</var>'s [[TypedArrayName]] internal slot</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be the value of <var>typedArray</var>’s [[ByteOffset]] internal slot.</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var></li><li>With atomic access to ( <var>buffer</var>, <var>indexedPosition</var>, <var>elementSize</var> ), do:<ol><li>Let <var>r</var> be the result of <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var> )</li><li>Compute: Let <var>w</var> be <var>r</var> + <var>v</var></li><li>Call <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>w</var> )</li></ol></li><li>Return <var>r</var>
      </li></ol></emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.and">
      <h1><span class="secnum">7.3.2</span>Atomics.and( typedArray, index, value )<span class="utils"><span class="anchor"><a href="#Atomics.and">#</a></span></span></h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let <var>w</var> be <var>r</var> &amp; <var>v</var>.</p>
    </emu-clause>
    
    <emu-clause id="Atomics.compareExchange">
      <h1><span class="secnum">7.3.3</span>Atomics.compareExchange( typedArray, index, expectedValue, replacementValue )<span class="utils"><span class="anchor"><a href="#Atomics.compareExchange">#</a></span></span></h1>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>buffer</var>)</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>i</var>)</li><li>Let <var>expected</var> be <emu-xref aoid="ToNumber"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tonumber">ToNumber</a></emu-xref>(<var>expectedValue</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>expected</var>)</li><li>Let <var>replacement</var> be <emu-xref aoid="ToNumber"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tonumber">ToNumber</a></emu-xref>(<var>replacedValue</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>replacement</var>)</li><li>Let <var>arrayTypeName</var> be the value of <var>typedArray</var>'s [[TypedArrayName]] internal slot</li><li>Let <var>convOp</var> be the conversion operation specified in Table 49 for <var>arrayTypeName</var></li><li>Let <var>x</var> be <var>convOp</var> ( <var>expected</var> )</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be the value of <var>typedArray</var>’s [[ByteOffset]] internal slot.</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var></li><li>With atomic access to ( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var> ), do:<ol><li>Let <var>r</var> be <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var> )</li><li>If <var>r</var> is the same number value as <var>x</var> then:<ol><li>Call <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>replacement</var> )</li></ol></li></ol></li><li>Return <var>r</var>
      </li></ol></emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.exchange">
      <h1><span class="secnum">7.3.4</span>Atomics.exchange( typedArray, index, value )<span class="utils"><span class="anchor"><a href="#Atomics.exchange">#</a></span></span></h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let <var>w</var> be <var>v</var>.</p>
    </emu-clause>

    <emu-clause id="Atomics.futexWait">
      <h1><span class="secnum">7.3.5</span>Atomics.futexWait( typedArray, index, value, timeout )<span class="utils"><span class="anchor"><a href="#Atomics.futexWait">#</a></span></span></h1>
      <p> Atomics.futexWait puts the calling agent in a wait queue and puts it to sleep until it is awoken or the sleep times out. The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>, <emu-const>true</emu-const>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>buffer</var>)</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>i</var>)</li><li>Let <var>v</var> be the result of <emu-xref aoid="ToInt32"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toint32">ToInt32</a></emu-xref>(<var>value</var>).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>v</var>)</li><li>If <var>timeout</var> is not provided or is <emu-const>undefined</emu-const> then let <var>t</var> be +Infinity.  Otherwise:<ol><li>Let <var>q</var> be the result of <emu-xref aoid="ToNumber"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tonumber">ToNumber</a></emu-xref>(<var>timeout</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>q</var>)</li><li>If <var>q</var> is NaN then let <var>t</var> be +Infinity, otherwise let <var>t</var> be max(0, <var>q</var>).</li></ol></li><li>Let <var>B</var> be <emu-xref aoid="AgentCanSuspend"><a href="#Atomics.AgentCanSuspend">AgentCanSuspend</a></emu-xref>()</li><li>If <var>B</var> is <emu-const>false</emu-const> then throw a <emu-const>TypeError</emu-const> exception.</li><li>Let <var>bufferVal</var> be the value of the internal [[SharedArrayBufferData]] property of <var>buffer</var>.</li><li>Let <var>G</var> be <emu-xref aoid="SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">SharedDataBlockID</a></emu-xref>(<var>bufferVal</var>)</li><li>Within the futex critical section do:<ol><li>Let <var>w</var> be Atomics.load(<var>typedArray</var>, <var>i</var>)</li><li>If <var>v</var> does not equal <var>w</var> then:<ol><li>Return the original value of <emu-const>Atomics.NOTEQUAL</emu-const>.</li></ol></li><li>Let <var>W</var> be <emu-xref aoid="AgentSignifier"><a href="#Atomics.AgentSignifier">AgentSignifier</a></emu-xref>().</li><li>Call <emu-xref aoid="AddWaiter"><a href="#Atomics.AddWaiter">AddWaiter</a></emu-xref>(<var>W</var>, <var>G</var>, <var>i</var>)</li><li>Let awoken = <emu-xref aoid="Suspend"><a href="#Atomics.Suspend">Suspend</a></emu-xref>(<var>W</var>, <var>t</var>)</li><li>Call <emu-xref aoid="RemoveWaiter"><a href="#Atomics.RemoveWaiter">RemoveWaiter</a></emu-xref>(<var>W</var>, <var>G</var>, <var>i</var>)</li></ol></li><li>If awoken is <emu-const>true</emu-const> then return the original value of <emu-const>Atomics.OK</emu-const>.</li><li>Return the original value of <emu-const>Atomics.TIMEDOUT</emu-const>.
      </li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p> The name "futex" comes from Linux, where it means "fast user-space mutex".  Linux has wait/wake system calls with names and functionality similar to what's defined here. The mechanism described here is however not Linux-dependent in any way.  </p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.futexWake">
      <h1><span class="secnum">7.3.6</span>Atomics.futexWake( typedArray, index, count )<span class="utils"><span class="anchor"><a href="#Atomics.futexWake">#</a></span></span></h1>
      <p> Atomics.futexWake wakes up some agents that are sleeping in the wait queue.  The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>( <var>typedArray</var>, <emu-const>true</emu-const> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>( <var>buffer</var> )</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>( <var>i</var> )</li><li>Let <var>tmp</var> be <emu-xref aoid="ToInteger"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tointeger">ToInteger</a></emu-xref>( <var>count</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>( <var>tmp</var> )</li><li>Let <var>c</var> be max( +0, <var>tmp</var> ).</li><li>Let <var>bufferVal</var> be the value of the internal [[SharedArrayBufferData]] property of <var>buffer</var>.</li><li>Let <var>G</var> be <emu-xref aoid="SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">SharedDataBlockID</a></emu-xref>( <var>bufferVal</var> )</li><li>Let <var>n</var> = 0</li><li>Within the futex critical section do:<ol><li>Let <var>S</var> be <emu-xref aoid="RemoveWaiters"><a href="#Atomics.RemoveWaiters">RemoveWaiters</a></emu-xref>( <var>G</var>, <var>i</var> )</li><li>While <var>c</var> &gt; 0 and <var>S</var> is not the empty list:<ol><li>Let <var>W</var> be the first agent in <var>S</var></li><li>Remove <var>W</var> from the front of <var>S</var></li><li>Call <emu-xref aoid="WakeWaiter"><a href="#Atomics.WakeWaiter">WakeWaiter</a></emu-xref>( <var>W</var> )</li><li>Subtract 1 from <var>c</var></li><li>Add 1 to <var>n</var></li></ol></li></ol></li><li>Return <var>n</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.futexWakeOrRequeue">
      <h1><span class="secnum">7.3.7</span>Atomics.futexWakeOrRequeue( typedArray, index1, count, index2, value )<span class="utils"><span class="anchor"><a href="#Atomics.futexWakeOrRequeue">#</a></span></span></h1>
      <p> Atomics.futexWake wakes up some agents that are sleeping in the wait queue and moves other waiting agents to the back of the queue.  The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>, <emu-const>true</emu-const>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>buffer</var>)</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index1</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>i</var>)</li><li>Let <var>tmp</var> be <emu-xref aoid="ToInteger"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tointeger">ToInteger</a></emu-xref>(<var>count</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>tmp</var>)</li><li>Let <var>c</var> be max(+0,<var>tmp</var>)</li><li>Let <var>j</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index2</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>j</var>)</li><li>Let <var>v</var> be <emu-xref aoid="ToInt32"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toint32">ToInt32</a></emu-xref>(<var>value</var>)</li><li>Let <var>bufferVal</var> be the value of the internal [[SharedArrayBufferData]] property of <var>buffer</var></li><li>Let <var>G</var> be <emu-xref aoid="SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">SharedDataBlockID</a></emu-xref>(<var>bufferVal</var>)</li><li>Let <var>n</var> = 0</li><li>Within the futex critical section do:<ol><li>Let <var>w</var> be Atomics.load(<var>typedArray</var>, <var>i</var>)</li><li>If <var>v</var> does not equal <var>w</var> then:<ol><li>Return the original value of <emu-const>Atomics.NOTEQUAL</emu-const></li></ol></li><li>Let <var>S</var> be <emu-xref aoid="RemoveWaiters"><a href="#Atomics.RemoveWaiters">RemoveWaiters</a></emu-xref>(<var>G</var>, <var>i</var>)</li><li>While <var>c</var> &gt; 0 and <var>S</var> is not the empty list:<ol><li>Let <var>W</var> be the first agent in <var>S</var></li><li>Remove <var>W</var> from the front of <var>S</var></li><li>Call <emu-xref aoid="WakeWaiter"><a href="#Atomics.WakeWaiter">WakeWaiter</a></emu-xref>(<var>W</var>)</li><li>Subtract 1 from <var>c</var></li><li>Add 1 to <var>n</var></li></ol></li><li>While <var>S</var> is not the empty list:<ol><li>Let <var>W</var> be the first agent in <var>S</var></li><li>Remove <var>W</var> from the front of <var>S</var></li><li>Call <emu-xref aoid="AddWaiter"><a href="#Atomics.AddWaiter">AddWaiter</a></emu-xref>(<var>W</var>, <var>G</var>, <var>j</var>)</li></ol></li></ol></li><li>Return <var>n</var>.
      </li></ol></emu-alg>        

      <emu-note><span class="note">Note</span>
        <p> Atomics.futexWaitOrRequeue is an optimization that helps programs avoid a "thundering herd" problem when many agents are woken and compete for a lock (as in a broadcast).  </p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.isLockFree">
      <h1><span class="secnum">7.3.8</span>Atomics.isLockFree( size )<span class="utils"><span class="anchor"><a href="#Atomics.isLockFree">#</a></span></span></h1>

      <emu-alg><ol><li>Let <var>n</var> be <emu-xref aoid="ToInteger"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tointeger">ToInteger</a></emu-xref>(<var>size</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>n</var>)</li><li>If <var>n</var> is not the initial value of the BYTES_PER_ELEMENT property of some integer TypedArray then return <emu-const>false</emu-const></li><li>If the atomic step of an atomic operation (compareExchange, load, store, add, sub, and, or, xor, or exchange) on a datum of size <var>n</var> bytes will be performed without the calling agent acquiring a lock outside the <var>n</var> bytes comprising the datum then return <emu-const>true</emu-const></li><li>Return <emu-const>false</emu-const>
      </li></ol></emu-alg>

      <p>If Atomics.isLockFree(k) returns a value  <em>v</em> at some point in some agent then every other invocation of Atomics.isLockFree(k) in that agent must return  <em>v</em>.</p>

      <p>If Atomics.isLockFree(k) returns a value  <em>v</em> in some agent then every invocation of Atomics.isLockFree(k) in any agent in the same cluster as the first agent must also return  <em>v</em>.</p>

      <emu-note><span class="note">Note 1</span>
        <p> Atomics.isLockFree() is an optimization primitive.  High-performance algorithms will use it to determine whether to use locks or atomic operations in critical sections.  If an atomic primitive is not lock-free then it is often more efficient for an algorithm to provide its own locking.</p>
      </emu-note>

      <emu-note><span class="note">Note 2</span>
        <p>The return value for a given argument is not necessarily a constant on a given piece of hardware, but also reflects implementation choices that can vary over time and across engines.</p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.load">
      <h1><span class="secnum">7.3.9</span>Atomics.load( typedArray, index )<span class="utils"><span class="anchor"><a href="#Atomics.load">#</a></span></span></h1>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>buffer</var>)</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>i</var>)</li><li>Let <var>arrayTypeName</var> be the value of <var>typedArray</var>'s [[TypedArrayName]] internal slot</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be the value of <var>typedArray</var>’s [[ByteOffset]] internal slot.</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var></li><li>With atomic access to ( <var>buffer</var>, <var>indexedPosition</var>, <var>elementSize</var> ), do:<ol><li>Let <var>r</var> be the result of <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var> )</li></ol></li><li>Return <var>r</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.or">
      <h1><span class="secnum">7.3.10</span>Atomics.or( typedArray, index, value )<span class="utils"><span class="anchor"><a href="#Atomics.or">#</a></span></span></h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let <var>w</var> be <var>r</var> | <var>v</var>.</p>
    </emu-clause>
    
    <emu-clause id="Atomics.store">
      <h1><span class="secnum">7.3.11</span>Atomics.store( typedArray, index, value )<span class="utils"><span class="anchor"><a href="#Atomics.store">#</a></span></span></h1>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>buffer</var>)</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>i</var>)</li><li>Let <var>v</var> be <emu-xref aoid="ToNumber"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tonumber">ToNumber</a></emu-xref>(<var>value</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>v</var>)</li><li>Let <var>arrayTypeName</var> be the value of <var>typedArray</var>'s [[TypedArrayName]] internal slot</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be the value of <var>typedArray</var>’s [[ByteOffset]] internal slot.</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var></li><li>With atomic access to ( <var>buffer</var>, <var>indexedPosition</var>, <var>elementSize</var> ), do:<ol><li>Call <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>v</var> )</li></ol></li><li>Return <var>v</var>
      </li></ol></emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.sub">
      <h1><span class="secnum">7.3.12</span>Atomics.sub( typedArray, index, value )<span class="utils"><span class="anchor"><a href="#Atomics.sub">#</a></span></span></h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let <var>w</var> be <var>r</var> - <var>v</var>.</p>
    </emu-clause>
    
    <emu-clause id="Atomics.xor">
      <h1><span class="secnum">7.3.13</span>Atomics.xor( typedArray, index, value )<span class="utils"><span class="anchor"><a href="#Atomics.xor">#</a></span></span></h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let <var>w</var> be <var>r</var> ^ <var>v</var>.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="WebBrowserEmbedding">
  <h1><span class="secnum">8</span>Web browser embedding (informative)<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding">#</a></span></span></h1>

  <emu-clause id="WebBrowserEmbedding.Agents">
    <h1><span class="secnum">8.1</span>Agent mapping<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.Agents">#</a></span></span></h1>
    <p> In a web browser setting, the  <em>agents</em> comprise a document's main thread environment and worker thread environments.  Normal Web Workers must be supported.</p>

    <p> There are reasons not to support ServiceWorkers and Shared Workers ("non-page workers").  In some browsers, non-page workers may be technically incapable of receiving shared memory segments due to process separation.  Also, if a non-page is communicating through shared memory with a web worker, a deadlock can ensue if the non-page worker is waiting to be woken up by the web worker and the web worker is suspended or killed because its owning document is placed into the history or closed.  </p>

  </emu-clause>
  
  <emu-clause id="WebBrowserEmbedding.WorkerSemantics">
    <h1><span class="secnum">8.2</span>Clarifications and changes to Web Worker semantics<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.WorkerSemantics">#</a></span></span></h1>

    <emu-note><span class="note">Note</span>
      <p> Several of these issues have been reported as bugs against the WHATWG spec,  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29039">see this bug report</a>.  </p>
    </emu-note>

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Start">
      <h1><span class="secnum">8.2.1</span>Actions to start a worker<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.WorkerSemantics.Start">#</a></span></span></h1>
      <p> (Clarification) The only action required to start a worker is to call "new Worker()".  </p>
      <p> (Compatible change) If a worker cannot be started for reasons of resource exhaustion (notably, no threads available, including arbitrary implementation limits on the number of threads) then an exception must be thrown.  </p>
      <emu-note><span class="note">Note</span>
        <p> Some browsers currently violate those requirements.  </p>
        <ul>
          <li> In current Firefox, a worker is not actually created until the parent has returned to its event loop and allowed the event loop to process runnables related to the worker creation.
          
          </li><li> In current Firefox, there is a per-domain limit on the number of workers.  An attempt to create a worker will silently not start the worker if the limit has been reached; the worker will be queued and started when another worker has terminated.
        
        </li></ul>
        <p> If an agent creates a worker and then -- if the worker is not started because the agent does not return to its event loop or because the worker is not assigned a thread -- the agent goes to sleep on a location waiting for the worker to wake it, there will be a deadlock.  </p>
        <p> There are other error situations during worker startup that can't necessarily be signaled synchronously, notably, a load error on the URL.  Those have to be signaled via an event callback, or the creating agent must poll the state of the worker to see if it enters an error state (see more below on the state).  </p>
      </emu-note>
    </emu-clause>

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Jobs">
      <h1><span class="secnum">8.2.2</span>Events and scripts run in a worker as ES6 jobs<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.WorkerSemantics.Jobs">#</a></span></span></h1>
      <p> (Clarification) ECMAscript code running in a worker runs as an ES6 job, and scheduling of work in a Worker happens by the rules of ES6 jobs.</p>
      <emu-note><span class="note">Note</span>
        <p> Thus the forward-progress guarantee of jobs also applies to workers.  </p>
      </emu-note>
    </emu-clause>

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.LicenseToKill">
      <h1><span class="secnum">8.2.3</span>Curtail the license to kill<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.WorkerSemantics.LicenseToKill">#</a></span></span></h1>
      <p> (Compatible change) Workers may be killed by the browser only for specific reasons.  These reasons are TBD but include evicting the owning page from the history and closing the owning page.  These reasons do not include workers that 'run too long'.  </p>
      <emu-note><span class="note">Note</span>
        <p> Currently the WHATWG spec allows the browser to kill any worker at any time.  The purpose of the rule is probably a combination of the need to stop runaway scripts (without the normal slow-script dialog) and the need to remove workers once a page is evicted from the browser cache or a tab is closed.  However, the wording is overly broad.  Also, common uses of workers for computation conflict with the ability to detect 'runaway' agents:</p>
        <ul>
          <li> The worker may perform a genuinely long-running computation
          
          </li><li> The worker will have its own user-implemented 'event' loop, communicating synchronously through shared memory; it will not use the browser's event loop
        
        </li></ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Introspection">
      <h1><span class="secnum">8.2.4</span>Termination detection<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.WorkerSemantics.Introspection">#</a></span></span></h1>
      <p> (Compatible(?) change) The worker object should have a read-only property called "state" whose value represents the state of the worker (eg a string naming the state).  One state could be "terminated", indicating the worker is dead.  </p>
      <emu-note><span class="note">Note 1</span>
        <p> There appears to be no way at present to directly determine whether a Worker has terminated.  </p>
      </emu-note>
      <emu-note><span class="note">Note 2</span>
        <p> Possible complementary mechanisms include throwing an exception when a message is sent to a terminated worker, and to send an error event to the creating agent when a worker is killed.  </p>
      </emu-note>
    </emu-clause>

  </emu-clause>
  
  <emu-clause id="WebBrowserEmbedding.MemoryModel">
    <h1><span class="secnum">8.3</span>Agent communication semantics<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.MemoryModel">#</a></span></span></h1>

    <p>Agent-to-agent communication extends the happens-before relation of the program, as follows:</p>

    <ul>
      <li>The call to the Worker constructor in the parent happens-before the execution of the main script in the worker.
      
      </li><li>The termination of a worker happens-before the parent of the worker (or any other agent) can determine that the worker has terminated.
      
      </li><li>A postMessage to a worker happens-before the event fires in the worker.
    
    </li></ul>

  </emu-clause>

  <emu-clause id="WebBrowserEmbedding.Termination">
    <h1><span class="secnum">8.4</span>Agent termination<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.Termination">#</a></span></span></h1>
    <p>If a worker is terminated by a call to its terminate method while it is blocked in a call to futexWait then the worker is first woken (removed from any wait queue) and then immediately terminated (the wakeup is not observed by the caller of futexWait).  There are no provisions for cleaning up locked state unless the browser supports a close handler.</p>

    <p>If a worker is terminated for any other reason, such as the user agent reloading or closing the window or frame, and the worker is blocked in a call to futexWait when it is terminated, then the worker is first woken (removed from any wait queue) and then immediately terminated (the wakeup is not observed by the caller of futexWait).  However, after the running script has been terminated the worker's close handler(s) will be run as if the wait had not been aborted.</p>

    <p> Some corner cases are unresolved:</p>
    <ul>
      <li> If Service Workers have access to shared memory then it is possible for a service worker to wait on an action from another agent, say, a document's main thread.  But if the document in question is suspended (because the user is navigating away from the document) then the service worker may never be woken: the document may remain suspended and may eventually be evicted from the history.
    
    </li></ul>
        
  </emu-clause>
  
  <emu-clause id="WebBrowserEmbedding.CloneAndTransfer">
    <h1><span class="secnum">8.5</span>Transmitting and Cloning SharedArrayBuffers and Views<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.CloneAndTransfer">#</a></span></span></h1>

    <p> SharedArrayBuffers and TypedArrays that view SharedArrayBuffers can be transmitted from one worker to another using postMessage() and are handled by the HTML5 structured clone algorithm as follows.</p>

    <p>When a SharedArrayBuffer input object is cloned in the originating agent the result is a new SharedArrayBuffer object in the receiving agent that references the same Shared <emu-xref href="#sec-data-blocks"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-data-blocks">Data Block</a></emu-xref> as the input object.  The input object must be present in the transfer map for the clone operation; if not, a standard clone exception will be thrown.</p>

    <p>When a SharedArrayBuffer object is cloned its Shared <emu-xref href="#sec-data-blocks"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-data-blocks">Data Block</a></emu-xref> is not detached (SharedArrayBuffers are never detached).</p>

    <p>A Shared <emu-xref href="#sec-data-blocks"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-data-blocks">Data Block</a></emu-xref> remains accessible so long as at least one SharedArrayBuffer object references it in some agent.</p>

    <p>When a TypedArray object that is a view on a SharedArrayBuffer is cloned the result is a new TypedArray object of the same element type.  The "buffer" property of the new TypedArray will reference a clone of the input object's "buffer" property.  The input object's "buffer" property must be present in the transfer map for the clone, or a standard clone exception will be thrown.</p>

  </emu-clause>

</emu-clause>
</body>
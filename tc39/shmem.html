<!doctype html>
<head><meta charset="utf-8">
<title>ECMAScript Shared Memory and Atomics</title>
<script src="https://bterlson.github.io/ecmarkup/ecmarkup.js"></script>
<link rel="stylesheet" href="https://bterlson.github.io/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">

<script type="application/json" id="menu-search-biblio">[{"type":"clause","id":"intro","aoid":null,"title":"Introduction","number":"","namespace":"<no location>","location":"","key":"Introduction"},{"type":"clause","id":"Overview","aoid":null,"title":"Overview (ES7 4)","number":"1","namespace":"<no location>","location":"","key":"Overview (ES7 4)"},{"type":"clause","id":"Overview.Overview","aoid":null,"title":"ECMAScript Overview (ES7 4.2)","number":"1.1","namespace":"<no location>","location":"","key":"ECMAScript Overview (ES7 4.2)"},{"type":"clause","id":"DataTypesValues","aoid":null,"title":"ECMAScript Data Types and Values (ES7 6)","number":"2","namespace":"<no location>","location":"","key":"ECMAScript Data Types and Values (ES7 6)"},{"type":"clause","id":"DataTypesValues.LanguageTypes","aoid":null,"title":"ECMAScript Language Types (ES7 6.1)","number":"2.1","namespace":"<no location>","location":"","key":"ECMAScript Language Types (ES7 6.1)"},{"type":"clause","id":"DataTypesValues.LanguageTypes.Number","aoid":null,"title":"The Number Type (ES7 6.1.6)","number":"2.1.1","namespace":"<no location>","location":"","key":"The Number Type (ES7 6.1.6)"},{"type":"clause","id":"DataTypesValues.LanguageTypes.Object","aoid":null,"title":"The Object Type (ES7 6.1.7)","number":"2.1.2","namespace":"<no location>","location":"","key":"The Object Type (ES7 6.1.7)"},{"type":"clause","id":"DataTypesValues.LanguageTypes.Object.Intrinsic","aoid":null,"title":"Well-Known Intrinsic Objects (ES7 6.1.7.4)","number":"2.1.2.1","namespace":"<no location>","location":"","key":"Well-Known Intrinsic Objects (ES7 6.1.7.4)"},{"type":"clause","id":"DataTypesValues.SpecTypes","aoid":null,"title":"ECMAScript Specification Types (ES7 6.2)","number":"2.2","namespace":"<no location>","location":"","key":"ECMAScript Specification Types (ES7 6.2)"},{"type":"clause","id":"DataTypesValues.SpecTypes.DataBlocks","aoid":null,"title":"Data blocks (ES7 6.2.6)","number":"2.2.1","namespace":"<no location>","location":"","key":"Data blocks (ES7 6.2.6)"},{"type":"clause","id":"DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes","aoid":null,"title":"CopyDataBlockBytes ( _toBlock_, _toIndex_, _fromBlock_, _fromIndex_, _count_ ) (ES7 6.2.6.2)","number":"2.2.1.1","namespace":"<no location>","location":"","key":"CopyDataBlockBytes ( _toBlock_, _toIndex_, _fromBlock_, _fromIndex_, _count_ ) (ES7 6.2.6.2)"},{"type":"clause","id":"DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock","aoid":null,"title":"CreateSharedByteDataBlock( _size_ )","number":"2.2.1.2","namespace":"<no location>","location":"","key":"CreateSharedByteDataBlock( _size_ )"},{"type":"op","aoid":"SharedDataBlockID","refId":"DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID","location":"","key":"SharedDataBlockID"},{"type":"clause","id":"DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID","aoid":"SharedDataBlockID","title":"SharedDataBlockID( _block_ )","number":"2.2.1.3","namespace":"<no location>","location":"","key":"SharedDataBlockID( _block_ )"},{"type":"clause","id":"ExecutableCodeAndContexts","aoid":null,"title":"Executable Code and Execution Contexts (ES7 8)","number":"3","namespace":"<no location>","location":"","key":"Executable Code and Execution Contexts (ES7 8)"},{"type":"clause","id":"ExecutableCodeAndContexts.JobsAndJobQueues","aoid":null,"title":"Jobs and Job Queues (ES7 8.4)","number":"3.1","namespace":"<no location>","location":"","key":"Jobs and Job Queues (ES7 8.4)"},{"type":"clause","id":"ExecutableCodeAndContexts.JobsAndJobQueues.Progress","aoid":null,"title":"Forward Progress Guarantees","number":"3.1.1","namespace":"<no location>","location":"","key":"Forward Progress Guarantees"},{"type":"clause","id":"ExecutableCodeAndContexts.AgentCluster","aoid":null,"title":"Agents (AMENDMENTS)","number":"3.2","namespace":"<no location>","location":"","key":"Agents (AMENDMENTS)"},{"type":"clause","id":"ExecutableCodeAndContexts.AgentCluster","aoid":null,"title":"Agent Clusters (NEW)","number":"3.3","namespace":"<no location>","location":"","key":"Agent Clusters (NEW)"},{"type":"clause","id":"sec-ordinary-and-exotic-objects-behaviours","aoid":null,"title":"Ordinary and Exotic Objects Behaviours (ES7 9)","number":"4","namespace":"<no location>","location":"","key":"Ordinary and Exotic Objects Behaviours (ES7 9)"},{"type":"clause","id":"sec-built-in-exotic-object-internal-methods-and-slots","aoid":null,"title":"Built-in Exotic Object Internal Methods and Slots (ES7 9.4)","number":"4.1","namespace":"<no location>","location":"","key":"Built-in Exotic Object Internal Methods and Slots (ES7 9.4)"},{"type":"clause","id":"sec-integer-indexed-exotic-objects","aoid":null,"title":"Integer Indexed Exotic Objects (ES7 9.4.5)","number":"4.1.1","namespace":"<no location>","location":"","key":"Integer Indexed Exotic Objects (ES7 9.4.5)"},{"type":"op","aoid":"IntegerIndexedElementGet","refId":"sec-integerindexedelementget","location":"","key":"IntegerIndexedElementGet"},{"type":"clause","id":"sec-integerindexedelementget","aoid":"IntegerIndexedElementGet","title":"IntegerIndexedElementGet ( _O_, _index_ ) (ES7 9.4.5.8)","number":"4.1.1.1","namespace":"<no location>","location":"","key":"IntegerIndexedElementGet ( _O_, _index_ ) (ES7 9.4.5.8)"},{"type":"op","aoid":"IntegerIndexedElementSet","refId":"sec-integerindexedelementset","location":"","key":"IntegerIndexedElementSet"},{"type":"clause","id":"sec-integerindexedelementset","aoid":"IntegerIndexedElementSet","title":"IntegerIndexedElementSet ( _O_, _index_, _value_ ) (ES7 9.4.5.9)","number":"4.1.1.2","namespace":"<no location>","location":"","key":"IntegerIndexedElementSet ( _O_, _index_, _value_ ) (ES7 9.4.5.9)"},{"type":"clause","id":"GlobalObject","aoid":null,"title":"The Global Object (ES7 18)","number":"5","namespace":"<no location>","location":"","key":"The Global Object (ES7 18)"},{"type":"clause","id":"GlobalObject.ConstructorProps","aoid":null,"title":"Constructor Properties of the Global Object (ES7 18.3)","number":"5.1","namespace":"<no location>","location":"","key":"Constructor Properties of the Global Object (ES7 18.3)"},{"type":"clause","id":"GlobalObject.ConstructorProps.SharedArrayBuffer","aoid":null,"title":"SharedArrayBuffer","number":"5.1.1","namespace":"<no location>","location":"","key":"SharedArrayBuffer"},{"type":"clause","id":"GlobalObject.ConstructorProps.Atomics","aoid":null,"title":"Atomics","number":"5.1.2","namespace":"<no location>","location":"","key":"Atomics"},{"type":"clause","id":"IndexedCollections","aoid":null,"title":"Indexed Collections (ES7 22)","number":"6","namespace":"<no location>","location":"","key":"Indexed Collections (ES7 22)"},{"type":"clause","id":"IndexedCollections.TypedArray","aoid":null,"title":"TypedArray Objects (ES7 22.2)","number":"6.1","namespace":"<no location>","location":"","key":"TypedArray Objects (ES7 22.2)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype","aoid":null,"title":"Properties of the %TypedArrayPrototype% object (ES7 22.2.3)","number":"6.1.1","namespace":"<no location>","location":"","key":"Properties of the %TypedArrayPrototype% object (ES7 22.2.3)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype.set","aoid":null,"title":" %TypedArray%.prototype.set( _overloaded_ [ , _offset_ ] ) (ES7 22.2.3.23)","number":"6.1.1.1","namespace":"<no location>","location":"","key":" %TypedArray%.prototype.set( _overloaded_ [ , _offset_ ] ) (ES7 22.2.3.23)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype.setFromTypedArray","aoid":null,"title":"%TypedArray%.prototype.set( _array_ [, _offset_ ] ) (ES7 22.2.3.23.1)","number":"6.1.1.1.1","namespace":"<no location>","location":"","key":"%TypedArray%.prototype.set( _array_ [, _offset_ ] ) (ES7 22.2.3.23.1)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype.setFromTypedArray","aoid":null,"title":"%TypedArray%.prototype.set( _typedArray_ [, _offset_ ] ) (ES7 22.2.3.23.2)","number":"6.1.1.1.2","namespace":"<no location>","location":"","key":"%TypedArray%.prototype.set( _typedArray_ [, _offset_ ] ) (ES7 22.2.3.23.2)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype.slice","aoid":null,"title":"%TypedArray%.prototype.slice( _start_, _end_ ) (ES7 22.2.3.24)","number":"6.1.1.1.3","namespace":"<no location>","location":"","key":"%TypedArray%.prototype.slice( _start_, _end_ ) (ES7 22.2.3.24)"},{"type":"clause","id":"IndexedCollections.TypedArray.constructors","aoid":null,"title":"The %TypedArray% constructors (ES7 22.2.4)","number":"6.1.2","namespace":"<no location>","location":"","key":"The %TypedArray% constructors (ES7 22.2.4)"},{"type":"clause","id":"sec-typedarray-typedarray","aoid":null,"title":"_TypedArray_ ( _typedArray_ ) (ES7 22.2.4.3)","number":"6.1.2.1","namespace":"<no location>","location":"","key":"_TypedArray_ ( _typedArray_ ) (ES7 22.2.4.3)"},{"type":"clause","id":"IndexedCollections.TypedArray.intrinsic.constructFromObject","aoid":null,"title":"%TypedArray%( _object_ ) (ES7 22.2.4.4)","number":"6.1.2.2","namespace":"<no location>","location":"","key":"%TypedArray%( _object_ ) (ES7 22.2.4.4)"},{"type":"clause","id":"IndexedCollections.TypedArray.intrinsic.constructFromBuffer","aoid":null,"title":"%TypedArray%( _buffer_ [ , _byteOffset_ [ , _length_ ] ] ) (ES7 22.2.4.5)","number":"6.1.2.3","namespace":"<no location>","location":"","key":"%TypedArray%( _buffer_ [ , _byteOffset_ [ , _length_ ] ] ) (ES7 22.2.4.5)"},{"type":"clause","id":"StructuredData","aoid":null,"title":"Structured Data (ES7 24)","number":"7","namespace":"<no location>","location":"","key":"Structured Data (ES7 24)"},{"type":"clause","id":"StructuredData.ArrayBuffer","aoid":null,"title":"ArrayBuffer Objects (ES7 24.1)","number":"7.1","namespace":"<no location>","location":"","key":"ArrayBuffer Objects (ES7 24.1)"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract","aoid":null,"title":"Abstract Operations for ArrayBuffer (ES7 24.1.1)","number":"7.1.1","namespace":"<no location>","location":"","key":"Abstract Operations for ArrayBuffer (ES7 24.1.1)"},{"type":"op","aoid":"IsDetachedBuffer","refId":"StructuredData.ArrayBuffer.abstract.IsDetachedBuffer","location":"","key":"IsDetachedBuffer"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract.IsDetachedBuffer","aoid":"IsDetachedBuffer","title":"IsDetachedBuffer( _arrayBuffer_ ) (ES7 24.1.1.2)","number":"7.1.1.1","namespace":"<no location>","location":"","key":"IsDetachedBuffer( _arrayBuffer_ ) (ES7 24.1.1.2)"},{"type":"op","aoid":"CloneArrayBuffer","refId":"StructuredData.ArrayBuffer.abstract.CloneArrayBuffer","location":"","key":"CloneArrayBuffer"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract.CloneArrayBuffer","aoid":"CloneArrayBuffer","title":"CloneArrayBuffer( _srcBuffer_, _srcByteOffset_ [, _cloneConstructor_] ) (ES7 24.1.1.4)","number":"7.1.1.2","namespace":"<no location>","location":"","key":"CloneArrayBuffer( _srcBuffer_, _srcByteOffset_ [, _cloneConstructor_] ) (ES7 24.1.1.4)"},{"type":"op","aoid":"GetValueFromBuffer","refId":"StructuredData.ArrayBuffer.abstract.GetValueFromBuffer","location":"","key":"GetValueFromBuffer"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract.GetValueFromBuffer","aoid":"GetValueFromBuffer","title":"GetValueFromBuffer( _arrayBuffer_, _byteIndex_, _type_, _isTypedArray_, _isLittleEndian_ ) (ES7 24.1.1.5)","number":"7.1.1.3","namespace":"<no location>","location":"","key":"GetValueFromBuffer( _arrayBuffer_, _byteIndex_, _type_, _isTypedArray_, _isLittleEndian_ ) (ES7 24.1.1.5)"},{"type":"op","aoid":"SetValueInBuffer","refId":"StructuredData.ArrayBuffer.abstract.SetValueInBuffer","location":"","key":"SetValueInBuffer"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract.SetValueInBuffer","aoid":"SetValueInBuffer","title":"SetValueInBuffer( _arrayBuffer_, _byteIndex_, _type_, _isTypedArray_, _value_, _isLittleEndian_ ) (ES7 24.1.1.6)","number":"7.1.1.4","namespace":"<no location>","location":"","key":"SetValueInBuffer( _arrayBuffer_, _byteIndex_, _type_, _isTypedArray_, _value_, _isLittleEndian_ ) (ES7 24.1.1.6)"},{"type":"clause","id":"StructuredData.DataView","aoid":null,"title":"DataView Objects (ES7 24.2)","number":"7.2","namespace":"<no location>","location":"","key":"DataView Objects (ES7 24.2)"},{"type":"clause","id":"sec-abstract-operations-for-dataview-objects","aoid":null,"title":"Abstract Operations For DataView Objects (ES7 24.2.1)","number":"7.2.1","namespace":"<no location>","location":"","key":"Abstract Operations For DataView Objects (ES7 24.2.1)"},{"type":"op","aoid":"GetViewValue","refId":"sec-getviewvalue","location":"","key":"GetViewValue"},{"type":"clause","id":"sec-getviewvalue","aoid":"GetViewValue","title":"GetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_ ) (ES7 24.2.1.1)","number":"7.2.1.1","namespace":"<no location>","location":"","key":"GetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_ ) (ES7 24.2.1.1)"},{"type":"op","aoid":"SetViewValue","refId":"sec-setviewvalue","location":"","key":"SetViewValue"},{"type":"clause","id":"sec-setviewvalue","aoid":"SetViewValue","title":"SetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_, _value_ ) (ES7 24.2.1.2)","number":"7.2.1.2","namespace":"<no location>","location":"","key":"SetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_, _value_ ) (ES7 24.2.1.2)"},{"type":"clause","id":"StructuredData.DataView.constructor","aoid":null,"title":"The DataView Constructor (ES7 24.2.2)","number":"7.2.2","namespace":"<no location>","location":"","key":"The DataView Constructor (ES7 24.2.2)"},{"type":"clause","id":"StructuredData.DataView.constructor.detail","aoid":null,"title":"DataView( _buffer_ [ , _byteOffset_ [ , _byteLength_ ] ] ) (ES7 24.2.2.1)","number":"7.2.2.1","namespace":"<no location>","location":"","key":"DataView( _buffer_ [ , _byteOffset_ [ , _byteLength_ ] ] ) (ES7 24.2.2.1)"},{"type":"clause","id":"StructuredData.SharedArrayBuffer","aoid":null,"title":"SharedArrayBuffer Objects","number":"7.3","namespace":"<no location>","location":"","key":"SharedArrayBuffer Objects"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.abstract","aoid":null,"title":"Abstract Operations for SharedArrayBuffer","number":"7.3.1","namespace":"<no location>","location":"","key":"Abstract Operations for SharedArrayBuffer"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer","aoid":null,"title":"AllocateSharedArrayBuffer( _constructor_, _byteLength_ )","number":"7.3.1.1","namespace":"<no location>","location":"","key":"AllocateSharedArrayBuffer( _constructor_, _byteLength_ )"},{"type":"op","aoid":"IsSharedMemory","refId":"StructuredData.SharedArrayBuffer.abstract.IsSharedMemory","location":"","key":"IsSharedMemory"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.abstract.IsSharedMemory","aoid":"IsSharedMemory","title":"IsSharedMemory( _obj_ )","number":"7.3.1.2","namespace":"<no location>","location":"","key":"IsSharedMemory( _obj_ )"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor","aoid":null,"title":"The SharedArrayBuffer Constructor","number":"7.3.2","namespace":"<no location>","location":"","key":"The SharedArrayBuffer Constructor"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor.withLength","aoid":null,"title":"SharedArrayBuffer( _length_ )","number":"7.3.2.1","namespace":"<no location>","location":"","key":"SharedArrayBuffer( _length_ )"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor.properties","aoid":null,"title":"Properties of the SharedArrayBuffer constructor","number":"7.3.3","namespace":"<no location>","location":"","key":"Properties of the SharedArrayBuffer constructor"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor.properties.prototype","aoid":null,"title":"SharedArrayBuffer.prototype","number":"7.3.3.1","namespace":"<no location>","location":"","key":"SharedArrayBuffer.prototype"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor.properties.get_species","aoid":null,"title":"get SharedArrayBuffer [ @@species ]","number":"7.3.3.2","namespace":"<no location>","location":"","key":"get SharedArrayBuffer [ @@species ]"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype","aoid":null,"title":"Properties of the SharedArrayBuffer prototype object","number":"7.3.4","namespace":"<no location>","location":"","key":"Properties of the SharedArrayBuffer prototype object"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype.get_byteLength","aoid":null,"title":"get SharedArrayBuffer.prototype.byteLength","number":"7.3.4.1","namespace":"<no location>","location":"","key":"get SharedArrayBuffer.prototype.byteLength"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype.constructor","aoid":null,"title":"SharedArrayBuffer.prototype.constructor","number":"7.3.4.2","namespace":"<no location>","location":"","key":"SharedArrayBuffer.prototype.constructor"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype.slice","aoid":null,"title":"SharedArrayBuffer.prototype.slice( _start_, _end_ )","number":"7.3.4.3","namespace":"<no location>","location":"","key":"SharedArrayBuffer.prototype.slice( _start_, _end_ )"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype.toString","aoid":null,"title":"SharedArrayBuffer.prototype[ @@toStringTag ]","number":"7.3.4.4","namespace":"<no location>","location":"","key":"SharedArrayBuffer.prototype[ @@toStringTag ]"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.instances","aoid":null,"title":"Properties of the SharedArrayBuffer instances","number":"7.3.5","namespace":"<no location>","location":"","key":"Properties of the SharedArrayBuffer instances"},{"type":"clause","id":"AtomicsObject","aoid":null,"title":"The Atomics Object","number":"8","namespace":"<no location>","location":"","key":"The Atomics Object"},{"type":"clause","id":"AtomicsObjectFunctionProps.semantics","aoid":null,"title":"Runtime semantics","number":"8.1","namespace":"<no location>","location":"","key":"Runtime semantics"},{"type":"clause","id":"AtomicsObject.MemoryModel","aoid":null,"title":"Memory model","number":"8.1.1","namespace":"<no location>","location":"","key":"Memory model"},{"type":"clause","id":"AtomicsObject.Fundamentals","aoid":null,"title":"Fundamentals","number":"8.1.1.1","namespace":"<no location>","location":"","key":"Fundamentals"},{"type":"clause","id":"AtomicsObject.SeqCst","aoid":null,"title":"Sequential consistency","number":"8.1.1.2","namespace":"<no location>","location":"","key":"Sequential consistency"},{"type":"clause","id":"AtomicsObject.DataRaces","aoid":null,"title":"Data races","number":"8.1.1.3","namespace":"<no location>","location":"","key":"Data races"},{"type":"op","aoid":"ReadSharedMemory","refId":"Atomics.ReadSharedMemory","location":"","key":"ReadSharedMemory"},{"type":"clause","id":"Atomics.ReadSharedMemory","aoid":"ReadSharedMemory","title":"ReadSharedMemory(_block_, _byteIndex_, _accessAtomic_, _numBytes_)","number":"8.1.2","namespace":"<no location>","location":"","key":"ReadSharedMemory(_block_, _byteIndex_, _accessAtomic_, _numBytes_)"},{"type":"op","aoid":"WriteSharedMemory","refId":"Atomics.WriteSharedMemory","location":"","key":"WriteSharedMemory"},{"type":"clause","id":"Atomics.WriteSharedMemory","aoid":"WriteSharedMemory","title":"WriteSharedMemory(_block_, _byteIndex_, _accessAtomic_, _numBytes_, _rawBytes_)","number":"8.1.3","namespace":"<no location>","location":"","key":"WriteSharedMemory(_block_, _byteIndex_, _accessAtomic_, _numBytes_, _rawBytes_)"},{"type":"op","aoid":"ValidateSharedIntegerTypedArray","refId":"Atomics.ValidateSharedIntegerTypedArray","location":"","key":"ValidateSharedIntegerTypedArray"},{"type":"clause","id":"Atomics.ValidateSharedIntegerTypedArray","aoid":"ValidateSharedIntegerTypedArray","title":"ValidateSharedIntegerTypedArray(_typedArray_ [, _onlyInt32_] )","number":"8.1.4","namespace":"<no location>","location":"","key":"ValidateSharedIntegerTypedArray(_typedArray_ [, _onlyInt32_] )"},{"type":"op","aoid":"ValidateAtomicAccess","refId":"Atomics.ValidateAtomicAccess","location":"","key":"ValidateAtomicAccess"},{"type":"clause","id":"Atomics.ValidateAtomicAccess","aoid":"ValidateAtomicAccess","title":"ValidateAtomicAccess( _typedArray_, _requestIndex_ )","number":"8.1.5","namespace":"<no location>","location":"","key":"ValidateAtomicAccess( _typedArray_, _requestIndex_ )"},{"type":"op","aoid":"AgentSignifier","refId":"Atomics.AgentSignifier","location":"","key":"AgentSignifier"},{"type":"clause","id":"Atomics.AgentSignifier","aoid":"AgentSignifier","title":"AgentSignifier( )","number":"8.1.6","namespace":"<no location>","location":"","key":"AgentSignifier( )"},{"type":"op","aoid":"AgentCanSuspend","refId":"Atomics.AgentCanSuspend","location":"","key":"AgentCanSuspend"},{"type":"clause","id":"Atomics.AgentCanSuspend","aoid":"AgentCanSuspend","title":"AgentCanSuspend( )","number":"8.1.7","namespace":"<no location>","location":"","key":"AgentCanSuspend( )"},{"type":"op","aoid":"GetWaiterList","refId":"GetWaiterList","location":"","key":"GetWaiterList"},{"type":"clause","id":"GetWaiterList","aoid":"GetWaiterList","title":"GetWaiterList( _G_, _i_ )","number":"8.1.8","namespace":"<no location>","location":"","key":"GetWaiterList( _G_, _i_ )"},{"type":"op","aoid":"EnterCriticalSection","refId":"EnterCriticalSection","location":"","key":"EnterCriticalSection"},{"type":"clause","id":"EnterCriticalSection","aoid":"EnterCriticalSection","title":"EnterCriticalSection( _WL_ )","number":"8.1.9","namespace":"<no location>","location":"","key":"EnterCriticalSection( _WL_ )"},{"type":"op","aoid":"LeaveCriticalSection","refId":"LeaveCriticalSection","location":"","key":"LeaveCriticalSection"},{"type":"clause","id":"LeaveCriticalSection","aoid":"LeaveCriticalSection","title":"LeaveCriticalSection( _WL_ )","number":"8.1.10","namespace":"<no location>","location":"","key":"LeaveCriticalSection( _WL_ )"},{"type":"op","aoid":"AddWaiter","refId":"Atomics.AddWaiter","location":"","key":"AddWaiter"},{"type":"clause","id":"Atomics.AddWaiter","aoid":"AddWaiter","title":"AddWaiter( _WL_, _W_ )","number":"8.1.11","namespace":"<no location>","location":"","key":"AddWaiter( _WL_, _W_ )"},{"type":"op","aoid":"RemoveWaiter","refId":"Atomics.RemoveWaiter","location":"","key":"RemoveWaiter"},{"type":"clause","id":"Atomics.RemoveWaiter","aoid":"RemoveWaiter","title":"RemoveWaiter( _WL_, _W_ )","number":"8.1.12","namespace":"<no location>","location":"","key":"RemoveWaiter( _WL_, _W_ )"},{"type":"op","aoid":"RemoveWaiters","refId":"Atomics.RemoveWaiters","location":"","key":"RemoveWaiters"},{"type":"clause","id":"Atomics.RemoveWaiters","aoid":"RemoveWaiters","title":"RemoveWaiters( _WL_, _c_ )","number":"8.1.13","namespace":"<no location>","location":"","key":"RemoveWaiters( _WL_, _c_ )"},{"type":"op","aoid":"Suspend","refId":"Atomics.Suspend","location":"","key":"Suspend"},{"type":"clause","id":"Atomics.Suspend","aoid":"Suspend","title":"Suspend( _WL_, _W_, _timeout_ )","number":"8.1.14","namespace":"<no location>","location":"","key":"Suspend( _WL_, _W_, _timeout_ )"},{"type":"op","aoid":"WakeWaiter","refId":"Atomics.WakeWaiter","location":"","key":"WakeWaiter"},{"type":"clause","id":"Atomics.WakeWaiter","aoid":"WakeWaiter","title":"WakeWaiter( _WL_, _W_ )","number":"8.1.15","namespace":"<no location>","location":"","key":"WakeWaiter( _WL_, _W_ )"},{"type":"op","aoid":"AtomicFetchOp","refId":"Atomics.FetchOp","location":"","key":"AtomicFetchOp"},{"type":"clause","id":"Atomics.FetchOp","aoid":"AtomicFetchOp","title":"AtomicFetchOp( _typedArray_, _index_, _value_, _op_ )","number":"8.1.16","namespace":"<no location>","location":"","key":"AtomicFetchOp( _typedArray_, _index_, _value_, _op_ )"},{"type":"clause","id":"AtomicsObjectFunctionProps","aoid":null,"title":"Function Properties of the Atomics Object","number":"8.2","namespace":"<no location>","location":"","key":"Function Properties of the Atomics Object"},{"type":"clause","id":"Atomics.add","aoid":null,"title":"Atomics.add( _typedArray_, _index_, _value_ )","number":"8.2.1","namespace":"<no location>","location":"","key":"Atomics.add( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.and","aoid":null,"title":"Atomics.and( _typedArray_, _index_, _value_ )","number":"8.2.2","namespace":"<no location>","location":"","key":"Atomics.and( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.compareExchange","aoid":null,"title":"Atomics.compareExchange( _typedArray_, _index_, _expectedValue_, _replacementValue_ )","number":"8.2.3","namespace":"<no location>","location":"","key":"Atomics.compareExchange( _typedArray_, _index_, _expectedValue_, _replacementValue_ )"},{"type":"clause","id":"Atomics.exchange","aoid":null,"title":"Atomics.exchange( _typedArray_, _index_, _value_ )","number":"8.2.4","namespace":"<no location>","location":"","key":"Atomics.exchange( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.isLockFree","aoid":null,"title":"Atomics.isLockFree( _size_ )","number":"8.2.5","namespace":"<no location>","location":"","key":"Atomics.isLockFree( _size_ )"},{"type":"clause","id":"Atomics.load","aoid":null,"title":"Atomics.load( _typedArray_, _index_ )","number":"8.2.6","namespace":"<no location>","location":"","key":"Atomics.load( _typedArray_, _index_ )"},{"type":"clause","id":"Atomics.or","aoid":null,"title":"Atomics.or( _typedArray_, _index_, _value_ )","number":"8.2.7","namespace":"<no location>","location":"","key":"Atomics.or( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.store","aoid":null,"title":"Atomics.store( _typedArray_, _index_, _value_ )","number":"8.2.8","namespace":"<no location>","location":"","key":"Atomics.store( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.sub","aoid":null,"title":"Atomics.sub( _typedArray_, _index_, _value_ )","number":"8.2.9","namespace":"<no location>","location":"","key":"Atomics.sub( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.wait","aoid":null,"title":"Atomics.wait( _typedArray_, _index_, _value_, _timeout_ )","number":"8.2.10","namespace":"<no location>","location":"","key":"Atomics.wait( _typedArray_, _index_, _value_, _timeout_ )"},{"type":"clause","id":"Atomics.wake","aoid":null,"title":"Atomics.wake( _typedArray_, _index_, _count_ )","number":"8.2.11","namespace":"<no location>","location":"","key":"Atomics.wake( _typedArray_, _index_, _count_ )"},{"type":"clause","id":"Atomics.xor","aoid":null,"title":"Atomics.xor( _typedArray_, _index_, _value_ )","number":"8.2.12","namespace":"<no location>","location":"","key":"Atomics.xor( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"WebBrowserEmbedding","aoid":null,"title":"Web browser embedding (informative)","number":"9","namespace":"<no location>","location":"","key":"Web browser embedding (informative)"},{"type":"table","id":"table-agent-record","number":1,"caption":"Table 1: Agent Record Fields","namespace":"<no location>","location":"","key":"Table 1: Agent Record Fields"},{"type":"term","term":"Shared Data Block","refId":"DataTypesValues.SpecTypes.DataBlocks","namespace":"<no location>","location":"","key":"Shared Data Block"},{"type":"term","term":"Shared Data Block ID","refId":"DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID","namespace":"<no location>","location":"","key":"Shared Data Block ID"},{"type":"term","term":"Agent Record","refId":"ExecutableCodeAndContexts.AgentCluster","namespace":"<no location>","location":"","key":"Agent Record"},{"type":"term","term":"%Atomics%","refId":"AtomicsObject","namespace":"<no location>","location":"","key":"%Atomics%"},{"type":"term","term":"memory model","refId":"AtomicsObject","namespace":"<no location>","location":"","key":"memory model"},{"type":"term","term":"WaiterList","refId":"GetWaiterList","namespace":"<no location>","location":"","key":"WaiterList"}]</script></head><body><div id="menu-toggle">☰</div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#intro" title="Introduction"><span class="secnum"></span> Introduction</a></li><li><span class="item-toggle">◢</span><a href="#Overview" title="Overview (ES7 4)"><span class="secnum">1</span> Overview (ES7 4)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#Overview.Overview" title="ECMAScript Overview (ES7 4.2)"><span class="secnum">1.1</span> ECMAScript Overview (ES7 4.2)</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#DataTypesValues" title="ECMAScript Data Types and Values (ES7 6)"><span class="secnum">2</span> ECMAScript Data Types and Values (ES7 6)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#DataTypesValues.LanguageTypes" title="ECMAScript Language Types (ES7 6.1)"><span class="secnum">2.1</span> ECMAScript Language Types (ES7 6.1)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#DataTypesValues.LanguageTypes.Number" title="The Number Type (ES7 6.1.6)"><span class="secnum">2.1.1</span> The Number Type (ES7 6.1.6)</a></li><li><span class="item-toggle">◢</span><a href="#DataTypesValues.LanguageTypes.Object" title="The Object Type (ES7 6.1.7)"><span class="secnum">2.1.2</span> The Object Type (ES7 6.1.7)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#DataTypesValues.LanguageTypes.Object.Intrinsic" title="Well-Known Intrinsic Objects (ES7 6.1.7.4)"><span class="secnum">2.1.2.1</span> Well-Known Intrinsic Objects (ES7 6.1.7.4)</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#DataTypesValues.SpecTypes" title="ECMAScript Specification Types (ES7 6.2)"><span class="secnum">2.2</span> ECMAScript Specification Types (ES7 6.2)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#DataTypesValues.SpecTypes.DataBlocks" title="Data blocks (ES7 6.2.6)"><span class="secnum">2.2.1</span> Data blocks (ES7 6.2.6)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes" title="CopyDataBlockBytes ( _toBlock_, _toIndex_, _fromBlock_, _fromIndex_, _count_ ) (ES7 6.2.6.2)"><span class="secnum">2.2.1.1</span> CopyDataBlockBytes ( <var>toBlock</var>, <var>toIndex</var>, <var>fromBlock</var>, <var>fromIndex</var>, <var>count</var> ) (ES7 6.2.6.2)</a></li><li><span class="item-toggle-none"></span><a href="#DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock" title="CreateSharedByteDataBlock( _size_ )"><span class="secnum">2.2.1.2</span> CreateSharedByteDataBlock( <var>size</var> )</a></li><li><span class="item-toggle-none"></span><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID" title="SharedDataBlockID( _block_ )"><span class="secnum">2.2.1.3</span> SharedDataBlockID( <var>block</var> )</a></li></ol></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#ExecutableCodeAndContexts" title="Executable Code and Execution Contexts (ES7 8)"><span class="secnum">3</span> Executable Code and Execution Contexts (ES7 8)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#ExecutableCodeAndContexts.JobsAndJobQueues" title="Jobs and Job Queues (ES7 8.4)"><span class="secnum">3.1</span> Jobs and Job Queues (ES7 8.4)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.JobsAndJobQueues.Progress" title="Forward Progress Guarantees"><span class="secnum">3.1.1</span> Forward Progress Guarantees</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.AgentCluster" title="Agents (AMENDMENTS)"><span class="secnum">3.2</span> Agents (AMENDMENTS)</a></li><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.AgentCluster" title="Agent Clusters (NEW)"><span class="secnum">3.3</span> Agent Clusters (NEW)</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-ordinary-and-exotic-objects-behaviours" title="Ordinary and Exotic Objects Behaviours (ES7 9)"><span class="secnum">4</span> Ordinary and Exotic Objects Behaviours (ES7 9)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-built-in-exotic-object-internal-methods-and-slots" title="Built-in Exotic Object Internal Methods and Slots (ES7 9.4)"><span class="secnum">4.1</span> Built-in Exotic Object Internal Methods and Slots (ES7 9.4)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-integer-indexed-exotic-objects" title="Integer Indexed Exotic Objects (ES7 9.4.5)"><span class="secnum">4.1.1</span> Integer Indexed Exotic Objects (ES7 9.4.5)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-integerindexedelementget" title="IntegerIndexedElementGet ( _O_, _index_ ) (ES7 9.4.5.8)"><span class="secnum">4.1.1.1</span> IntegerIndexedElementGet ( <var>O</var>, <var>index</var> ) (ES7 9.4.5.8)</a></li><li><span class="item-toggle-none"></span><a href="#sec-integerindexedelementset" title="IntegerIndexedElementSet ( _O_, _index_, _value_ ) (ES7 9.4.5.9)"><span class="secnum">4.1.1.2</span> IntegerIndexedElementSet ( <var>O</var>, <var>index</var>, <var>value</var> ) (ES7 9.4.5.9)</a></li></ol></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#GlobalObject" title="The Global Object (ES7 18)"><span class="secnum">5</span> The Global Object (ES7 18)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#GlobalObject.ConstructorProps" title="Constructor Properties of the Global Object (ES7 18.3)"><span class="secnum">5.1</span> Constructor Properties of the Global Object (ES7 18.3)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#GlobalObject.ConstructorProps.SharedArrayBuffer" title="SharedArrayBuffer"><span class="secnum">5.1.1</span> SharedArrayBuffer</a></li><li><span class="item-toggle-none"></span><a href="#GlobalObject.ConstructorProps.Atomics" title="Atomics"><span class="secnum">5.1.2</span> Atomics</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#IndexedCollections" title="Indexed Collections (ES7 22)"><span class="secnum">6</span> Indexed Collections (ES7 22)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray" title="TypedArray Objects (ES7 22.2)"><span class="secnum">6.1</span> TypedArray Objects (ES7 22.2)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray.prototype" title="Properties of the %TypedArrayPrototype% object (ES7 22.2.3)"><span class="secnum">6.1.1</span> Properties of the %TypedArrayPrototype% object (ES7 22.2.3)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray.prototype.set" title=" %TypedArray%.prototype.set( _overloaded_ [ , _offset_ ] ) (ES7 22.2.3.23)"><span class="secnum">6.1.1.1</span> %TypedArray%.prototype.set( <var>overloaded</var> [ , <var>offset</var> ] ) (ES7 22.2.3.23)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#IndexedCollections.TypedArray.prototype.setFromTypedArray" title="%TypedArray%.prototype.set( _array_ [, _offset_ ] ) (ES7 22.2.3.23.1)"><span class="secnum">6.1.1.1.1</span> %TypedArray%.prototype.set( <var>array</var> [, <var>offset</var> ] ) (ES7 22.2.3.23.1)</a></li><li><span class="item-toggle-none"></span><a href="#IndexedCollections.TypedArray.prototype.setFromTypedArray" title="%TypedArray%.prototype.set( _typedArray_ [, _offset_ ] ) (ES7 22.2.3.23.2)"><span class="secnum">6.1.1.1.2</span> %TypedArray%.prototype.set( <var>typedArray</var> [, <var>offset</var> ] ) (ES7 22.2.3.23.2)</a></li><li><span class="item-toggle-none"></span><a href="#IndexedCollections.TypedArray.prototype.slice" title="%TypedArray%.prototype.slice( _start_, _end_ ) (ES7 22.2.3.24)"><span class="secnum">6.1.1.1.3</span> %TypedArray%.prototype.slice( <var>start</var>, <var>end</var> ) (ES7 22.2.3.24)</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray.constructors" title="The %TypedArray% constructors (ES7 22.2.4)"><span class="secnum">6.1.2</span> The %TypedArray% constructors (ES7 22.2.4)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-typedarray-typedarray" title="_TypedArray_ ( _typedArray_ ) (ES7 22.2.4.3)"><span class="secnum">6.1.2.1</span> <var>TypedArray</var> ( <var>typedArray</var> ) (ES7 22.2.4.3)</a></li><li><span class="item-toggle-none"></span><a href="#IndexedCollections.TypedArray.intrinsic.constructFromObject" title="%TypedArray%( _object_ ) (ES7 22.2.4.4)"><span class="secnum">6.1.2.2</span> %TypedArray%( <var>object</var> ) (ES7 22.2.4.4)</a></li><li><span class="item-toggle-none"></span><a href="#IndexedCollections.TypedArray.intrinsic.constructFromBuffer" title="%TypedArray%( _buffer_ [ , _byteOffset_ [ , _length_ ] ] ) (ES7 22.2.4.5)"><span class="secnum">6.1.2.3</span> %TypedArray%( <var>buffer</var> [ , <var>byteOffset</var> [ , <var>length</var> ] ] ) (ES7 22.2.4.5)</a></li></ol></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData" title="Structured Data (ES7 24)"><span class="secnum">7</span> Structured Data (ES7 24)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.ArrayBuffer" title="ArrayBuffer Objects (ES7 24.1)"><span class="secnum">7.1</span> ArrayBuffer Objects (ES7 24.1)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.ArrayBuffer.abstract" title="Abstract Operations for ArrayBuffer (ES7 24.1.1)"><span class="secnum">7.1.1</span> Abstract Operations for ArrayBuffer (ES7 24.1.1)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer" title="IsDetachedBuffer( _arrayBuffer_ ) (ES7 24.1.1.2)"><span class="secnum">7.1.1.1</span> IsDetachedBuffer( <var>arrayBuffer</var> ) (ES7 24.1.1.2)</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.CloneArrayBuffer" title="CloneArrayBuffer( _srcBuffer_, _srcByteOffset_ [, _cloneConstructor_] ) (ES7 24.1.1.4)"><span class="secnum">7.1.1.2</span> CloneArrayBuffer( <var>srcBuffer</var>, <var>srcByteOffset</var> [, <var>cloneConstructor</var>] ) (ES7 24.1.1.4)</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" title="GetValueFromBuffer( _arrayBuffer_, _byteIndex_, _type_, _isTypedArray_, _isLittleEndian_ ) (ES7 24.1.1.5)"><span class="secnum">7.1.1.3</span> GetValueFromBuffer( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>isTypedArray</var>, <var>isLittleEndian</var> ) (ES7 24.1.1.5)</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer" title="SetValueInBuffer( _arrayBuffer_, _byteIndex_, _type_, _isTypedArray_, _value_, _isLittleEndian_ ) (ES7 24.1.1.6)"><span class="secnum">7.1.1.4</span> SetValueInBuffer( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>isTypedArray</var>, <var>value</var>, <var>isLittleEndian</var> ) (ES7 24.1.1.6)</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.DataView" title="DataView Objects (ES7 24.2)"><span class="secnum">7.2</span> DataView Objects (ES7 24.2)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-abstract-operations-for-dataview-objects" title="Abstract Operations For DataView Objects (ES7 24.2.1)"><span class="secnum">7.2.1</span> Abstract Operations For DataView Objects (ES7 24.2.1)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-getviewvalue" title="GetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_ ) (ES7 24.2.1.1)"><span class="secnum">7.2.1.1</span> GetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var> ) (ES7 24.2.1.1)</a></li><li><span class="item-toggle-none"></span><a href="#sec-setviewvalue" title="SetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_, _value_ ) (ES7 24.2.1.2)"><span class="secnum">7.2.1.2</span> SetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var>, <var>value</var> ) (ES7 24.2.1.2)</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.DataView.constructor" title="The DataView Constructor (ES7 24.2.2)"><span class="secnum">7.2.2</span> The DataView Constructor (ES7 24.2.2)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.DataView.constructor.detail" title="DataView( _buffer_ [ , _byteOffset_ [ , _byteLength_ ] ] ) (ES7 24.2.2.1)"><span class="secnum">7.2.2.1</span> DataView( <var>buffer</var> [ , <var>byteOffset</var> [ , <var>byteLength</var> ] ] ) (ES7 24.2.2.1)</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer" title="SharedArrayBuffer Objects"><span class="secnum">7.3</span> SharedArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.abstract" title="Abstract Operations for SharedArrayBuffer"><span class="secnum">7.3.1</span> Abstract Operations for SharedArrayBuffer</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer" title="AllocateSharedArrayBuffer( _constructor_, _byteLength_ )"><span class="secnum">7.3.1.1</span> AllocateSharedArrayBuffer( <var>constructor</var>, <var>byteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory" title="IsSharedMemory( _obj_ )"><span class="secnum">7.3.1.2</span> IsSharedMemory( <var>obj</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.constructor" title="The SharedArrayBuffer Constructor"><span class="secnum">7.3.2</span> The SharedArrayBuffer Constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.constructor.withLength" title="SharedArrayBuffer( _length_ )"><span class="secnum">7.3.2.1</span> SharedArrayBuffer( <var>length</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.constructor.properties" title="Properties of the SharedArrayBuffer constructor"><span class="secnum">7.3.3</span> Properties of the SharedArrayBuffer constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.constructor.properties.prototype" title="SharedArrayBuffer.prototype"><span class="secnum">7.3.3.1</span> SharedArrayBuffer.prototype</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.constructor.properties.get_species" title="get SharedArrayBuffer [ @@species ]"><span class="secnum">7.3.3.2</span> get SharedArrayBuffer [ @@species ]</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.prototype" title="Properties of the SharedArrayBuffer prototype object"><span class="secnum">7.3.4</span> Properties of the SharedArrayBuffer prototype object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.get_byteLength" title="get SharedArrayBuffer.prototype.byteLength"><span class="secnum">7.3.4.1</span> get SharedArrayBuffer.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.constructor" title="SharedArrayBuffer.prototype.constructor"><span class="secnum">7.3.4.2</span> SharedArrayBuffer.prototype.constructor</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.slice" title="SharedArrayBuffer.prototype.slice( _start_, _end_ )"><span class="secnum">7.3.4.3</span> SharedArrayBuffer.prototype.slice( <var>start</var>, <var>end</var> )</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.toString" title="SharedArrayBuffer.prototype[ @@toStringTag ]"><span class="secnum">7.3.4.4</span> SharedArrayBuffer.prototype[ @@toStringTag ]</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.instances" title="Properties of the SharedArrayBuffer instances"><span class="secnum">7.3.5</span> Properties of the SharedArrayBuffer instances</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#AtomicsObject" title="The Atomics Object"><span class="secnum">8</span> The Atomics Object</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#AtomicsObjectFunctionProps.semantics" title="Runtime semantics"><span class="secnum">8.1</span> Runtime semantics</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#AtomicsObject.MemoryModel" title="Memory model"><span class="secnum">8.1.1</span> Memory model</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#AtomicsObject.Fundamentals" title="Fundamentals"><span class="secnum">8.1.1.1</span> Fundamentals</a></li><li><span class="item-toggle-none"></span><a href="#AtomicsObject.SeqCst" title="Sequential consistency"><span class="secnum">8.1.1.2</span> Sequential consistency</a></li><li><span class="item-toggle-none"></span><a href="#AtomicsObject.DataRaces" title="Data races"><span class="secnum">8.1.1.3</span> Data races</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#Atomics.ReadSharedMemory" title="ReadSharedMemory(_block_, _byteIndex_, _accessAtomic_, _numBytes_)"><span class="secnum">8.1.2</span> ReadSharedMemory(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>numBytes</var>)</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.WriteSharedMemory" title="WriteSharedMemory(_block_, _byteIndex_, _accessAtomic_, _numBytes_, _rawBytes_)"><span class="secnum">8.1.3</span> WriteSharedMemory(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>numBytes</var>, <var>rawBytes</var>)</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.ValidateSharedIntegerTypedArray" title="ValidateSharedIntegerTypedArray(_typedArray_ [, _onlyInt32_] )"><span class="secnum">8.1.4</span> ValidateSharedIntegerTypedArray(<var>typedArray</var> [, <var>onlyInt32</var>] )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.ValidateAtomicAccess" title="ValidateAtomicAccess( _typedArray_, _requestIndex_ )"><span class="secnum">8.1.5</span> ValidateAtomicAccess( <var>typedArray</var>, <var>requestIndex</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AgentSignifier" title="AgentSignifier( )"><span class="secnum">8.1.6</span> AgentSignifier( )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AgentCanSuspend" title="AgentCanSuspend( )"><span class="secnum">8.1.7</span> AgentCanSuspend( )</a></li><li><span class="item-toggle-none"></span><a href="#GetWaiterList" title="GetWaiterList( _G_, _i_ )"><span class="secnum">8.1.8</span> GetWaiterList( <var>G</var>, <var>i</var> )</a></li><li><span class="item-toggle-none"></span><a href="#EnterCriticalSection" title="EnterCriticalSection( _WL_ )"><span class="secnum">8.1.9</span> EnterCriticalSection( <var>WL</var> )</a></li><li><span class="item-toggle-none"></span><a href="#LeaveCriticalSection" title="LeaveCriticalSection( _WL_ )"><span class="secnum">8.1.10</span> LeaveCriticalSection( <var>WL</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AddWaiter" title="AddWaiter( _WL_, _W_ )"><span class="secnum">8.1.11</span> AddWaiter( <var>WL</var>, <var>W</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.RemoveWaiter" title="RemoveWaiter( _WL_, _W_ )"><span class="secnum">8.1.12</span> RemoveWaiter( <var>WL</var>, <var>W</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.RemoveWaiters" title="RemoveWaiters( _WL_, _c_ )"><span class="secnum">8.1.13</span> RemoveWaiters( <var>WL</var>, <var>c</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.Suspend" title="Suspend( _WL_, _W_, _timeout_ )"><span class="secnum">8.1.14</span> Suspend( <var>WL</var>, <var>W</var>, <var>timeout</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.WakeWaiter" title="WakeWaiter( _WL_, _W_ )"><span class="secnum">8.1.15</span> WakeWaiter( <var>WL</var>, <var>W</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.FetchOp" title="AtomicFetchOp( _typedArray_, _index_, _value_, _op_ )"><span class="secnum">8.1.16</span> AtomicFetchOp( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>op</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#AtomicsObjectFunctionProps" title="Function Properties of the Atomics Object"><span class="secnum">8.2</span> Function Properties of the Atomics Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#Atomics.add" title="Atomics.add( _typedArray_, _index_, _value_ )"><span class="secnum">8.2.1</span> Atomics.add( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.and" title="Atomics.and( _typedArray_, _index_, _value_ )"><span class="secnum">8.2.2</span> Atomics.and( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.compareExchange" title="Atomics.compareExchange( _typedArray_, _index_, _expectedValue_, _replacementValue_ )"><span class="secnum">8.2.3</span> Atomics.compareExchange( <var>typedArray</var>, <var>index</var>, <var>expectedValue</var>, <var>replacementValue</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.exchange" title="Atomics.exchange( _typedArray_, _index_, _value_ )"><span class="secnum">8.2.4</span> Atomics.exchange( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.isLockFree" title="Atomics.isLockFree( _size_ )"><span class="secnum">8.2.5</span> Atomics.isLockFree( <var>size</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.load" title="Atomics.load( _typedArray_, _index_ )"><span class="secnum">8.2.6</span> Atomics.load( <var>typedArray</var>, <var>index</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.or" title="Atomics.or( _typedArray_, _index_, _value_ )"><span class="secnum">8.2.7</span> Atomics.or( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.store" title="Atomics.store( _typedArray_, _index_, _value_ )"><span class="secnum">8.2.8</span> Atomics.store( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.sub" title="Atomics.sub( _typedArray_, _index_, _value_ )"><span class="secnum">8.2.9</span> Atomics.sub( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.wait" title="Atomics.wait( _typedArray_, _index_, _value_, _timeout_ )"><span class="secnum">8.2.10</span> Atomics.wait( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.wake" title="Atomics.wake( _typedArray_, _index_, _count_ )"><span class="secnum">8.2.11</span> Atomics.wake( <var>typedArray</var>, <var>index</var>, <var>count</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.xor" title="Atomics.xor( _typedArray_, _index_, _value_ )"><span class="secnum">8.2.12</span> Atomics.xor( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li></ol></li></ol></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding" title="Web browser embedding (informative)"><span class="secnum">9</span> Web browser embedding (informative)</a></li></ol></div></div><h1>ECMAScript Shared Memory and Atomics</h1>
<p> Revised: 2016-07-11 </p>
<p> Some algorithms and semantics in this proposal are presented as modifications to existing ES262 algorithms and semantics.  The base revision of ES262 for the modifications (here denoted "ES7") is currently f35248729043089b47ccf29e4c47559386f5f6fd (2016-06-29).  At the moment, ES7 (ES2016) section numbering differs from ES6 (ES2015) only for TypedArrays (section 22.2).</p>

<emu-intro id="intro">
<h1><span class="secnum"></span>Introduction<span class="utils"><span class="anchor"><a href="#intro">#</a></span></span></h1>

<p> This proposal adds a simple form of shared memory to ECMAScript.
Shared memory is being exposed in the form of a new SharedArrayBuffer
type; the existing TypedArray and DataView types are adapted in such a way
that they can be used to create views on shared memory.  The new
global Atomics object provides atomic operations on shared memory
locations, including operations that can be used to create blocking
synchronization primitives.  Though not a part of this specification,
we intend for the role of "threads" to be played by Web Workers in web
browser environments.</p><p>

</p><p> At this time the proposal adds only low-level primitives to
ECMAScript; we expect the developer community to put together
abstractions that are useful in specific domains.  </p>

<p> The work has been driven by the following use cases:  </p><p>

</p><ul>
  <li> Support for threaded code in programs written in other
  languages that are translated to asm.js or plain JS or a combination
  of the two, notably C and C++ but also other, safe, languages. 

  </li><li> Support for hand-written JS or JS+asm.js that makes use of
  multiprocessing facilities for select tasks, such as image
  processing, asset management, or game AI.

</li></ul>

<p> The proposal makes only very basic assumptions about the required
hardware and should be broadly implementable with good performance.
Prototype implementations of the API are available in Firefox and in
Google Chrome.  </p>

<p>This specification constitutes a restatement and formalization of
an earlier
work,  <a href="https://github.com/tc39/ecmascript_sharedmem/blob/master/historical/Spec_JavaScriptSharedMemoryAtomicsandLocks.pdf">the
spec document for which</a> also contains additional rationale,
background information, discussions, implementation notes, and
comments.</p>

<p>Changelog:</p>
<ul>
  <li> 2016-07-11 -- Rewrote the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> section, which introduced separate access functions for shared memory, and caused many other changes.
  
  </li><li> 2016-07-05 -- Rewrote (and shrunk) the informative Web Browser Embedding section so that it only addresses the requirements of this spec, not how HTML ought to evolve.
  
  </li><li> 2016-07-05 -- Rephrased the wait/wake mutual exclusion in terms of critical sections named by (G,i), as the old specification was too strong.
  
  </li><li> 2016-06-30 -- Algorithms that are modified relative to their ES262 forms include more context and are more clearly marked, and there's a defined ES262 base revision for those modifications.  Updated section references to reference that revision.
  
  </li><li> (Older changelog removed)

</li></ul>

</emu-intro>

<emu-clause id="Overview">
  <h1><span class="secnum">1</span>Overview (<a href="https://tc39.github.io/ecma262/#sec-overview">ES7 4</a>)<span class="utils"><span class="anchor"><a href="#Overview">#</a></span></span></h1>
  <emu-clause id="Overview.Overview">
    <h1><span class="secnum">1.1</span>ECMAScript Overview (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-overview">ES7 4.2</a>)<span class="utils"><span class="anchor"><a href="#Overview.Overview">#</a></span></span></h1>
    <p>In the third paragraph, include  <b>SharedArrayBuffer</b> after  <b>ArrayBuffer</b>.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="DataTypesValues">
  <h1><span class="secnum">2</span>ECMAScript Data Types and Values (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">ES7 6</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues">#</a></span></span></h1>

  <emu-clause id="DataTypesValues.LanguageTypes">
    <h1><span class="secnum">2.1</span>ECMAScript Language Types (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-language-types">ES7 6.1</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes">#</a></span></span></h1>
    <emu-clause id="DataTypesValues.LanguageTypes.Number">
      <h1><span class="secnum">2.1.1</span>The Number Type (<a href="https://tc39.github.io/ecma262/#sec-well-known-symbols">ES7 6.1.6</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes.Number">#</a></span></span></h1>
      <p>In the NOTE, include  <b>SharedArrayBuffer</b> along with  <b>ArrayBuffer</b>.</p>
    </emu-clause>
    <emu-clause id="DataTypesValues.LanguageTypes.Object">
      <h1><span class="secnum">2.1.2</span>The Object Type (<a href="https://tc39.github.io/ecma262/#sec-object-type">ES7 6.1.7</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes.Object">#</a></span></span></h1>
      <emu-clause id="DataTypesValues.LanguageTypes.Object.Intrinsic">
        <h1><span class="secnum">2.1.2.1</span>Well-Known Intrinsic Objects (<a href="https://tc39.github.io/ecma262/#sec-well-known-intrinsic-objects">ES7 6.1.7.4</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes.Object.Intrinsic">#</a></span></span></h1>
        <p>In table 7, include rows for <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">%Atomics%</a></emu-xref>, %SharedArrayBuffer%, and %SharedArrayBufferPrototype% in the manner of the row for ArrayBuffer.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="DataTypesValues.SpecTypes">
    <h1><span class="secnum">2.2</span>ECMAScript Specification Types (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-specification-types">ES7 6.2</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes">#</a></span></span></h1>
    <emu-clause id="DataTypesValues.SpecTypes.DataBlocks">
      <h1><span class="secnum">2.2.1</span>Data blocks (<a href="https://tc39.github.io/ecma262/#sec-data-blocks">ES7 6.2.6</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks">#</a></span></span></h1>
      <p> Insert the following paragraph after the third:  </p>

      <p> A data block that resides in memory that can be referenced from multiple agents concurrently is designated a  <dfn>Shared Data Block</dfn>.  </p>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes">
        <h1><span class="secnum">2.2.1.1</span>CopyDataBlockBytes ( <var>toBlock</var>, <var>toIndex</var>, <var>fromBlock</var>, <var>fromIndex</var>, <var>count</var> ) (<a href="https://tc39.github.io/ecma262/#sec-copydatablockbytes">ES7 6.2.6.2</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes">#</a></span></span></h1>
        <p> This algorithm is modified as follows:</p>
        <p>When the abstract operation <emu-xref aoid="CopyDataBlockBytes"><a href="https://tc39.github.io/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref> is called, the following steps are taken:</p>
        <emu-alg><ol><li>Assert: <var>fromBlock</var> and <var>toBlock</var> are distinct <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> <ins>or <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref></ins> values.</li><li>Assert: <var>fromIndex</var>, <var>toIndex</var>, and <var>count</var> are integer values ≥ 0.</li><li>Let <var>fromSize</var> be the number of bytes in <var>fromBlock</var>.</li><li>Assert: <var>fromIndex</var>+<var>count</var> ≤ <var>fromSize</var>.</li><li>Let <var>toSize</var> be the number of bytes in <var>toBlock</var>.</li><li>Assert: <var>toIndex</var>+<var>count</var> ≤ <var>toSize</var>.</li><li>Repeat, while <var>count</var>&gt;0<ol><li><del> Set <var>toBlock</var>[<var>toIndex</var>] to the value of <var>fromBlock</var>[<var>fromIndex</var>]. </del> <br> <ins>If <var>fromBlock</var> is a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref>  then let <var>byte</var> be <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref>(<var>fromBlock</var>, <var>fromIndex</var>, <emu-val>true</emu-val>, <emu-val>1</emu-val>), otherwise let <var>byte</var> be <var>fromBlock</var>[<var>fromIndex</var>] </ins></li><li><ins>If <var>toBlock</var> is a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> then perform <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref>(<var>toBlock</var>, <var>toIndex</var>, <emu-val>true</emu-val>, 1, <var>byte</var>), otherwise set <var>toBlock</var>[<var>toIndex</var>] to <var>byte</var>. </ins></li><li>Increment <var>toIndex</var> and <var>fromIndex</var> each by 1.</li><li>Decrement <var>count</var> by 1.</li></ol></li><li>Return <emu-xref aoid="NormalCompletion"><a href="https://tc39.github.io/ecma262/#sec-normalcompletion">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock">
        <h1><span class="secnum">2.2.1.2</span>CreateSharedByteDataBlock( <var>size</var> )<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock">#</a></span></span></h1>
        <p>When the abstract operation CreateSharedByteDataBlock is called with integer argument size, the following steps are taken:</p>
        <emu-alg><ol><li>Assert: <var>size</var> &gt;= 0.</li><li>Let <var>db</var> be a new <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> value consisting of <var>size</var> bytes. If it is impossible to create such a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Set all of the bytes of <var>db</var> to 0 as if by calls to <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref>(<var>db</var>, <var>i</var>, <emu-val>true</emu-val>, 1, 0) for each index <var>i</var> in <var>db</var>.</li><li>Return <var>db</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID" aoid="SharedDataBlockID">
        <h1><span class="secnum">2.2.1.3</span>SharedDataBlockID( <var>block</var> )<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">#</a></span></span></h1>
        <p>When the abstract operation SharedDataBlockID is called with <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> argument <var>block</var>, the following steps are taken:</p>
        <emu-alg><ol><li>Let <var>G</var> be an address-free identifier for <var>block</var>.  All agents in the same agent cluster must use the same value for <var>G</var> for any given <var>block</var>.</li><li>Return <var>G</var>.
        </li></ol></emu-alg>
        <emu-note><span class="note">Note</span>
          <p>The  <dfn>Shared Data Block ID</dfn> is used by the wait/wake mechanism and names <var>block</var> independently of any virtual addresses it may be mapped to in any particular agent.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="ExecutableCodeAndContexts">
  <h1><span class="secnum">3</span>Executable Code and Execution Contexts (<a href="https://tc39.github.io/ecma262/#sec-executable-code-and-execution-contexts">ES7 8</a>)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts">#</a></span></span></h1>
  <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues">

    <h1><span class="secnum">3.1</span>Jobs and Job Queues (<a href="https://tc39.github.io/ecma262/#sec-jobs-and-job-queues">ES7 8.4</a>)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.JobsAndJobQueues">#</a></span></span></h1>
    <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues.Progress">
      <h1><span class="secnum">3.1.1</span>Forward Progress Guarantees<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.JobsAndJobQueues.Progress">#</a></span></span></h1>
      <p> The forward progress guarantee is provided by  <a href="https://github.com/tc39/ecma262/pull/522">PR 522 on ES262</a>.  </p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="ExecutableCodeAndContexts.AgentCluster">
    <h1><span class="secnum">3.2</span>Agents (AMENDMENTS)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.AgentCluster">#</a></span></span></h1>

    <p> Add the following properties to the  <dfn>Agent Record</dfn> (which is provided by  <a href="https://github.com/tc39/ecma262/pull/522">PR 522 on ES262</a>):</p>

    <emu-table id="table-agent-record" caption="Agent Record Fields"><figure><figcaption>Table 1: Agent Record Fields</figcaption>
      <table>
        <tbody>
          <tr>
            <th>
	      Field name
	    
	    </th>
            <th>
	      Value
	    
	    </th>
            <th>
	      Meaning
	    
	    </th>
          </tr>
          <tr>
            <td> [[Signifier]]  </td>
            <td> A value that admits equality testing  </td>
            <td> Uniquely identifies the agent within its agent cluster.  </td>
          </tr>
          <tr>
            <td> [[IsLockFree1]]  </td>
            <td> Boolean  </td>
            <td> True if and only if atomic operations on one-byte values are lock-free.  </td>
          </tr>
          <tr>
            <td> [[IsLockFree2]]  </td>
            <td> Boolean  </td>
            <td> True if and only if atomic operations on two-byte values are lock-free.  </td>
          </tr>
        </tbody>
      </table>
    </figure></emu-table>

    <p> Once the values of [[Signifier]], [[IsLockFree1]], and
    [[IsLockFree2]] have been observed by any agent in the agent
    cluster they cannot change.  </p>

    <emu-note><span class="note">Note</span>
      <p>The values of [[IsLockFree1]] and [[IsLockFree2]] are not
        necessarily determined by the hardware, but may also reflect
        implementation choices that can vary over time and between
        ECMAScript implementations.</p>

      <p>There is no [[IsLockFree4]] property: 4-byte atomic
        operations are always lock-free.  </p>

      <p>Formally, atomic operations are lock-free if, infinitely
        often, some atomic operation finishes in a finite number of
        program steps.  In practice, if an atomic operation is
        implemented with any type of lock the operation is not
        lock-free.  Lock-free does not imply wait-free: there is no
        upper bound on how many machine steps may be required to
        complete a lock-free atomic operation.  </p>

      <p>That an atomic access of size  <em>n</em> is lock-free does
        not imply anything about the (perceived) atomicity of
        non-atomic accesses of size  <em>n</em>, specifically,
        non-atomic accesses may still be performed as a sequence of
        several separate memory accesses.  See <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref> and
        <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref> for details.  </p>
    </emu-note>

  </emu-clause>

  <emu-clause id="ExecutableCodeAndContexts.AgentCluster">
    <h1><span class="secnum">3.3</span>Agent Clusters (NEW)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.AgentCluster">#</a></span></span></h1>

    <p> An  <em>agent cluster</em> is a maximal set of agents that can
      communicate by operating on shared memory.  </p>

    <emu-note><span class="note">Note 1</span>
      <p> Programs within different agents may share memory by
        unspecified means.  At a minimum, the backing memory for
        SharedArrayBuffer objects can be shared among the agents in
        the cluster.  </p>

      <p> There may be agents that can communicate by message passing
	that cannot share memory; they are never in the same
	cluster.  </p>
    </emu-note>

    <p> Every agent belongs to exactly one agent cluster.  </p>

    <emu-note><span class="note">Note 2</span>
      <p> The agents in a cluster need not all be alive at some
	particular point in time.  If agent  <b>A</b> creates another
	agent  <b>B</b>, after which  <b>A</b> terminates and  <b>B</b>
	creates agent  <b>C</b>, the three agents are in the same
	cluster if  <b>A</b> could share some memory with  <b>B</b>
	and  <b>B</b> could share some memory with  <b>C</b>.  </p>
    </emu-note>

    <p> All agents within a cluster must have the same value for
      the [[LittleEndian]] property in their respective Agent Records.  </p>

    <emu-note><span class="note">Note 3</span>
      <p> If different agents within an agent cluster have different
        values of [[LittleEndian]] it becomes hard to use shared
        memory for multi-byte data.  </p>
    </emu-note>

    <p> All agents within a cluster must have the same values for
      the [[IsLockFree1]] property in their respective Agent Records; similarly for
      the [[IsLockFree2]] property.  </p>

    <p> All agents within a cluster must have different values for
      the [[Signifier]] property in their respective Agent Records.  </p>

    <p> An agent cluster is a specification mechanism and need not correspond to
      any particular artefact of an ECMAScript implementation.  </p>

    <p> An embedding may deactivate (stop forward progress) or
      activate (resume forward progress) an agent without the agent's
      knowledge or cooperation.  If the embedding does so, it must not
      leave some agents in the cluster active while other agents in
      the cluster are deactivated indefinitely.  </p>

    <emu-note><span class="note">Note 4</span>
      <p> The purpose of the preceding restriction is to avoid a
        situation where an agent deadlocks or starves because another
        agent has been suspended.  For example, if a DOM SharedWorker
        shares memory with a regular worker, and the regular worker is
        suspended while it holds a lock (because the web page the
        regular worker is in is pushed into the window history), and
        the SharedWorker tries to acquire the lock, then the
        SharedWorker will be blocked until the regular worker wakes up
        again, if ever.  Meanwhile other workers trying to access the
        SharedWorker from other web pages will starve.  </p>

      <p> The implication of the restriction is that it will not be
        possible to share memory between agents that don't belong to
        the same suspend/wake collective within the embedding.  </p>
    </emu-note>

    <p> An embedding may terminate an agent without any of the agent's
      cluster's other agents' prior knowledge or cooperation.  If an
      agent is terminated not by programmatic action of its own or of
      another agent in the cluster but by forces external to the
      cluster, then the embedding must choose one of two strategies:
      Either terminate all the agents in the cluster, or provide
      reliable APIs that allow the agents in the cluster to coordinate
      so that at least one remaining member of the cluster will be
      able to detect the termination, with the termination data
      containing enough information to identify the agent that was
      terminated.  </p>

    <emu-note><span class="note">Note 5</span>
      <p> Examples of that type of termination are: operating systems
        or users terminating agents that are running in separate
        processes; the embedding itself terminating an agent that is
        running in-process with the other agents when per-agent
        resource accounting indicates that the agent is runaway.  </p>
    </emu-note>

    <emu-note><span class="note">Note 6</span>
      <p> This proposal additionally suggests (see later text) that if
        termination is signaled then the signal creates a
        synchronizes-with edge in the memory ordering.  </p>
    </emu-note>

  </emu-clause> <!-- agent cluster -->

</emu-clause>

<!-- es6num="9" -->
<emu-clause id="sec-ordinary-and-exotic-objects-behaviours">
  <h1><span class="secnum">4</span>Ordinary and Exotic Objects Behaviours (<a href="https://tc39.github.io/ecma262/#sec-ordinary-and-exotic-objects-behaviours">ES7 9</a>)<span class="utils"><span class="anchor"><a href="#sec-ordinary-and-exotic-objects-behaviours">#</a></span></span></h1>

  <!-- es6num="9.4" -->
  <emu-clause id="sec-built-in-exotic-object-internal-methods-and-slots">
    <h1><span class="secnum">4.1</span>Built-in Exotic Object Internal Methods and Slots (<a href="https://tc39.github.io/ecma262/#sec-built-in-exotic-object-internal-methods-and-slots">ES7 9.4</a>)<span class="utils"><span class="anchor"><a href="#sec-built-in-exotic-object-internal-methods-and-slots">#</a></span></span></h1>

    <!-- es6num="9.4.5" -->
    <emu-clause id="sec-integer-indexed-exotic-objects">
      <h1><span class="secnum">4.1.1</span>Integer Indexed Exotic Objects (<a href="https://tc39.github.io/ecma262/#sec-integer-indexed-exotic-objects">ES7 9.4.5</a>)<span class="utils"><span class="anchor"><a href="#sec-integer-indexed-exotic-objects">#</a></span></span></h1>

      <!-- es6num="9.4.5.8" -->
      <emu-clause id="sec-integerindexedelementget" aoid="IntegerIndexedElementGet">
        <h1><span class="secnum">4.1.1.1</span>IntegerIndexedElementGet ( <var>O</var>, <var>index</var> ) (<a href="https://tc39.github.io/ecma262/#sec-integerindexedelementget">ES7 9.4.5.8</a>)<span class="utils"><span class="anchor"><a href="#sec-integerindexedelementget">#</a></span></span></h1>

        <p> This algorithm is modified as follows:  </p>

        <p> In the call to <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>, pass <emu-val>true</emu-val> as the fourth argument to indicate that the operation is performed on a TypedArray.  </p>
      </emu-clause>

      <!-- es6num="9.4.5.9" -->
      <emu-clause id="sec-integerindexedelementset" aoid="IntegerIndexedElementSet">
        <h1><span class="secnum">4.1.1.2</span>IntegerIndexedElementSet ( <var>O</var>, <var>index</var>, <var>value</var> ) (<a href="https://tc39.github.io/ecma262/#sec-integerindexedelementset">ES7 9.4.5.9</a>)<span class="utils"><span class="anchor"><a href="#sec-integerindexedelementset">#</a></span></span></h1>

        <p> This algorithm is modified as follows:  </p>

        <p> In the call to <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>, pass <emu-val>true</emu-val> as the fourth argument to indicate that the operation is performed on a TypedArray.  </p>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="GlobalObject">
  <h1><span class="secnum">5</span>The Global Object (<a href="https://tc39.github.io/ecma262/#sec-global-object">ES7 18</a>)<span class="utils"><span class="anchor"><a href="#GlobalObject">#</a></span></span></h1>
  <emu-clause id="GlobalObject.ConstructorProps">
    <h1><span class="secnum">5.1</span>Constructor Properties of the Global Object (<a href="https://tc39.github.io/ecma262/#sec-constructor-properties-of-the-global-object">ES7 18.3</a>)<span class="utils"><span class="anchor"><a href="#GlobalObject.ConstructorProps">#</a></span></span></h1>
    <emu-clause id="GlobalObject.ConstructorProps.SharedArrayBuffer">
      <h1><span class="secnum">5.1.1</span>SharedArrayBuffer<span class="utils"><span class="anchor"><a href="#GlobalObject.ConstructorProps.SharedArrayBuffer">#</a></span></span></h1>
      <p> Add a new subsection for SharedArrayBuffer, pointing to the appropriate new section (below).</p>
    </emu-clause>
    <emu-clause id="GlobalObject.ConstructorProps.Atomics">
      <h1><span class="secnum">5.1.2</span>Atomics<span class="utils"><span class="anchor"><a href="#GlobalObject.ConstructorProps.Atomics">#</a></span></span></h1>
      <p> Add a new subsection for Atomics, pointing to the appropriate new section (below).</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<!--
AllocateTypedArray only allocates an ArrayBuffer if length is specified.
These call AllocateTypedArray with a specified length:
  TypedArrayFrom (twice)
   called from:
     %TypedArray% ( object )
     %TypedArray%.from ( source [,mapFn [,thisArg]] )
  %TypedArray%.of ( ...items )
  %TypedArray%.prototype.filter ( callbackFn [, thisArg] )
  %TypedArray%.prototype.slice ( start, end )
  %TypedArray% ()
  %TypedArray% (length)
  -->

<emu-clause id="IndexedCollections">
  <h1><span class="secnum">6</span>Indexed Collections (<a href="https://tc39.github.io/ecma262/#sec-indexed-collections">ES7 22</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections">#</a></span></span></h1>
  <emu-clause id="IndexedCollections.TypedArray">
    <h1><span class="secnum">6.1</span>TypedArray Objects (<a href="https://tc39.github.io/ecma262/#sec-typedarray-objects">ES7 22.2</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray">#</a></span></span></h1>

    <emu-clause id="IndexedCollections.TypedArray.prototype">
      <h1><span class="secnum">6.1.1</span>Properties of the %TypedArrayPrototype% object (<a href="https://tc39.github.io/ecma262/#sec-properties-of-the-%typedarrayprototype%-object">ES7 22.2.3</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype">#</a></span></span></h1>
      <emu-clause id="IndexedCollections.TypedArray.prototype.set">
        <h1><span class="secnum">6.1.1.1</span> %TypedArray%.prototype.set( <var>overloaded</var> [ , <var>offset</var> ] ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-overloaded-offset">ES7 22.2.3.23</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype.set">#</a></span></span></h1>

        <emu-clause id="IndexedCollections.TypedArray.prototype.setFromTypedArray">
          <h1><span class="secnum">6.1.1.1.1</span>%TypedArray%.prototype.set( <var>array</var> [, <var>offset</var> ] ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-array-offset">ES7 22.2.3.23.1</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype.setFromTypedArray">#</a></span></span></h1>
          <p> This algorithm is modified as follows:  </p>

          <p> In the call to <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>, pass <emu-val>true</emu-val> as the fourth argument to indicate that the operation is performed on a TypedArray.  </p>
        </emu-clause>

        <emu-clause id="IndexedCollections.TypedArray.prototype.setFromTypedArray">
          <h1><span class="secnum">6.1.1.1.2</span>%TypedArray%.prototype.set( <var>typedArray</var> [, <var>offset</var> ] ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-typedarray-offset">ES7 22.2.3.23.2</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype.setFromTypedArray">#</a></span></span></h1>
          <p>This algorithm is modified as follows:</p>
          <p>Sets multiple values in this <var>TypedArray</var>, reading the values from the <var>typedArray</var> argument object. The optional <var>offset</var> value indicates the first element index in this <var>TypedArray</var> where values are written. If omitted, it is assumed to be 0.</p>
          <emu-alg><ol><li>Assert: <var>typedArray</var> has a [[TypedArrayName]] internal slot. If it does not, the definition in <emu-xref href="#sec-%typedarray%.prototype.set-array-offset"><a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-array-offset">22.2.3.23.1</a></emu-xref> applies.</li><li>Let <var>target</var> be the <emu-val>this</emu-val> value.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>target</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>target</var> does not have a [[TypedArrayName]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>Assert: <var>target</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>targetOffset</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>offset</var>).</li><li>If <var>targetOffset</var> &lt; 0, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>targetBuffer</var> be <var>target</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer">IsDetachedBuffer</a></emu-xref>(<var>targetBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>targetLength</var> be <var>target</var>.[[ArrayLength]].</li><li>Let <var>srcBuffer</var> be <var>typedArray</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer">IsDetachedBuffer</a></emu-xref>(<var>srcBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>targetName</var> be the String value of <var>target</var>.[[TypedArrayName]].</li><li>Let <var>targetType</var> be the String value of the Element Type value in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>targetName</var>.</li><li>Let <var>targetElementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>targetName</var>.</li><li>Let <var>targetByteOffset</var> be <var>target</var>.[[ByteOffset]].</li><li>Let <var>srcName</var> be the String value of <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>srcType</var> be the String value of the Element Type value in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcElementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcLength</var> be <var>typedArray</var>.[[ArrayLength]].</li><li>Let <var>srcByteOffset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>If <var>srcLength</var> + <var>targetOffset</var> &gt; <var>targetLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li><ins>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is SharedArrayBuffer, then let <var>same</var> be <emu-val>true</emu-val> if <emu-xref aoid="SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">SharedDataBlockID</a></emu-xref>(<var>x</var>.[[SharedArrayBufferData]]) equals <emu-xref aoid="SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">SharedDataBlockID</a></emu-xref>(<var>y</var>.[[SharedArrayBufferData]]); otherwise let <var>same</var> be <emu-xref aoid="SameValue"><a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>srcBuffer</var>, <var>targetBuffer</var>). </ins></li><li><del>If <emu-xref aoid="SameValue"><a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>srcBuffer</var>, <var>targetBuffer</var>)</del> <ins><var>same</var></ins> is <emu-val>true</emu-val>, then<ol><li>Let <var>srcBuffer</var> be ? <emu-xref aoid="CloneArrayBuffer"><a href="#StructuredData.ArrayBuffer.abstract.CloneArrayBuffer">CloneArrayBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteOffset</var>, <var>srcLength</var>, <emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.github.io/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>).</li><li>NOTE: <emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.github.io/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref> is used to clone <var>srcBuffer</var> because is it known to not have any observable side-effects.</li><li>Let <var>srcByteIndex</var> be 0.</li></ol></li><li>Else, let <var>srcByteIndex</var> be <var>srcByteOffset</var>.</li><li>Let <var>targetByteIndex</var> be <var>targetOffset</var> × <var>targetElementSize</var> + <var>targetByteOffset</var>.</li><li>Let <var>limit</var> be <var>targetByteIndex</var> + <var>targetElementSize</var> × <var>srcLength</var>.</li><li>If <emu-xref aoid="SameValue"><a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>srcType</var>, <var>targetType</var>) is <emu-val>true</emu-val>, then<ol><li>NOTE: If <var>srcType</var> and <var>targetType</var> are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.</li><li>Repeat, while <var>targetByteIndex</var> &lt; <var>limit</var><ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteIndex</var>, <code>"Uint8"</code>, <ins><emu-val>true</emu-val></ins>).</li><li>Perform <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>(<var>targetBuffer</var>, <var>targetByteIndex</var>, <code>"Uint8"</code>, <ins><emu-val>true</emu-val></ins>, <var>value</var>).</li><li>...</li></ol></li></ol></li><li>Else,<ol><li>Repeat, while <var>targetByteIndex</var> &lt; <var>limit</var><ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteIndex</var>, <var>srcType</var>, <ins><emu-val>true</emu-val></ins>).</li><li>Perform <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>(<var>targetBuffer</var>, <var>targetByteIndex</var>, <var>targetType</var>, <ins><emu-val>true</emu-val></ins>, <var>value</var>).</li><li>...</li></ol></li></ol></li><li>Return <emu-val>undefined</emu-val>.
          </li></ol></emu-alg>
        </emu-clause>

        <emu-clause id="IndexedCollections.TypedArray.prototype.slice">
          <h1><span class="secnum">6.1.1.1.3</span>%TypedArray%.prototype.slice( <var>start</var>, <var>end</var> ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice">ES7 22.2.3.24</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype.slice">#</a></span></span></h1>
          <p> This algorithm is modified as follows:  </p>

          <p> In the calls to <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref> and <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>, pass <emu-val>true</emu-val> as the fourth argument to indicate that the operations are
            performed on a TypedArray.  </p>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="IndexedCollections.TypedArray.constructors">
      <h1><span class="secnum">6.1.2</span>The %TypedArray% constructors (<a href="https://tc39.github.io/ecma262/#sec-typedarray-constructors">ES7 22.2.4</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.constructors">#</a></span></span></h1>

      <!-- es6num="22.2.1.3" -->
      <emu-clause id="sec-typedarray-typedarray">
        <h1><span class="secnum">6.1.2.1</span><var>TypedArray</var> ( <var>typedArray</var> ) (<a href="https://tc39.github.io/ecma262/#sec-typedarray-typedarray">ES7 22.2.4.3</a>)<span class="utils"><span class="anchor"><a href="#sec-typedarray-typedarray">#</a></span></span></h1>

        <p> This algorithm is modified as follows:  </p>

        <p> In the calls to <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref> and <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>, pass <emu-val>true</emu-val> as the fourth argument to indicate that the operations are performed
          on a TypedArray.  </p>
      </emu-clause>

      <emu-clause id="IndexedCollections.TypedArray.intrinsic.constructFromObject">
        <h1><span class="secnum">6.1.2.2</span>%TypedArray%( <var>object</var> ) (<a href="https://tc39.github.io/ecma262/#sec-typedarray-object">ES7 22.2.4.4</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.intrinsic.constructFromObject">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p>This description applies only if the <var>TypedArray</var> function is called with at least one argument and the Type of the first argument is Object and that object does not have either a [[TypedArrayName]]  <del>or</del> <ins>,</ins> an [[ArrayBufferData]]<ins>, or a [[SharedArrayBufferData]]</ins> internal slot.</p>
        <p> ...  </p>
      </emu-clause>

      <emu-clause id="IndexedCollections.TypedArray.intrinsic.constructFromBuffer">
        <h1><span class="secnum">6.1.2.3</span>%TypedArray%( <var>buffer</var> [ , <var>byteOffset</var> [ , <var>length</var> ] ] ) (<a href="https://tc39.github.io/ecma262/#sec-typedarray-buffer-byteoffset-length">ES7 22.2.4.5</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.intrinsic.constructFromBuffer">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p>This description applies only if the <var>TypedArray</var> function is called with at least one argument and the Type of the first argument is Object and that object has an [[ArrayBufferData]]  <ins>or [[SharedArrayBufferData]]</ins> internal slot.</p>
        <p><var>TypedArray</var> called with at least one argument <var>buffer</var> performs the following steps:</p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>buffer</var>) is Object and <var>buffer</var> has an [[ArrayBufferData]] <ins>or a [[SharedArrayBufferData]]</ins> internal slot.</li><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>constructorName</var> be the String value of the Constructor Name value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for this <var>TypedArray</var> constructor.</li><li>Let <var>O</var> be ? <emu-xref aoid="AllocateTypedArray"><a href="https://tc39.github.io/ecma262/#sec-allocatetypedarray">AllocateTypedArray</a></emu-xref>(<var>constructorName</var>, NewTarget, <code>"%TypedArrayPrototype%"</code>).</li><li>Let <var>constructorName</var> be the String value of <var>O</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Number value of the Element Size value in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>constructorName</var>.</li><li>Let <var>offset</var> be ? ToIndex(<var>byteOffset</var>).</li><li>If <var>offset</var> <emu-xref aoid="modulo"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">modulo</a></emu-xref> <var>elementSize</var> ≠ 0, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><del>Let</del> <ins> If <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>buffer</var>) then let <var>bufferByteLength</var> be <var>buffer</var>.[[SharedArrayBufferByteLength]], otherwise let</ins> <var>bufferByteLength</var> be <var>buffer</var>.[[ArrayBufferByteLength]].</li><li>...
        </li></ol></emu-alg>
      </emu-clause>

    </emu-clause> <!-- intrinsic object -->

  </emu-clause>
</emu-clause>

<emu-clause id="StructuredData">
  <h1><span class="secnum">7</span>Structured Data (<a href="https://tc39.github.io/ecma262/#sec-structured-data">ES7 24</a>)<span class="utils"><span class="anchor"><a href="#StructuredData">#</a></span></span></h1>

  <emu-clause id="StructuredData.ArrayBuffer">
    <h1><span class="secnum">7.1</span>ArrayBuffer Objects (<a href="https://tc39.github.io/ecma262/#sec-arraybuffer-objects">ES7 24.1</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer">#</a></span></span></h1>

    <emu-clause id="StructuredData.ArrayBuffer.abstract">
      <h1><span class="secnum">7.1.1</span>Abstract Operations for ArrayBuffer (<a href="https://tc39.github.io/ecma262/#sec-abstract-operations-for-arraybuffer-objects">ES7 24.1.1</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract">#</a></span></span></h1>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.IsDetachedBuffer" aoid="IsDetachedBuffer">
        <h1><span class="secnum">7.1.1.1</span>IsDetachedBuffer( <var>arrayBuffer</var> ) (<a href="https://tc39.github.io/ecma262/#sec-isdetachedbuffer">ES7 24.1.1.2</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer">#</a></span></span></h1>
        <p> This algorithm is modified as follows:  </p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>arrayBuffer</var>) is Object and it has an [[ArrayBufferData]] <ins>or a [[SharedArrayBufferData]]<ins> internal slot.</ins></ins></li><li>If <ins><var>arrayBuffer</var> has an [[ArrayBufferData]] internal slot and</ins> <var>arrayBuffer</var>.[[ArrayBufferData]] is <emu-val>null</emu-val>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.CloneArrayBuffer" aoid="CloneArrayBuffer">
        <h1><span class="secnum">7.1.1.2</span>CloneArrayBuffer( <var>srcBuffer</var>, <var>srcByteOffset</var> [, <var>cloneConstructor</var>] ) (<a href="https://tc39.github.io/ecma262/#sec-clonearraybuffer">ES7 24.1.1.4</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.CloneArrayBuffer">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p> The abstract operation CloneArrayBuffer takes four parameters, an ArrayBuffer  <ins>or SharedArrayBuffer</ins> <var>srcBuffer</var>, an integer offset <var>srcByteOffset</var>, an integer length <var>srcLength</var>, and optionally a constructor function <var>cloneConstructor</var>. It creates a new ArrayBuffer whose data is a copy of <var>srcBuffer</var>'s data over the range starting at <var>srcByteOffset</var> and continuing for <var>srcLength</var> bytes. This operation performs the following steps:</p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>srcBuffer</var>) is Object and it has an [[ArrayBufferData]] <ins>or [[SharedArrayBufferData]]</ins> internal slot.</li><li>If <var>cloneConstructor</var> is not present, then<ol><li>Let <var>cloneConstructor</var> be ? <emu-xref aoid="SpeciesConstructor"><a href="https://tc39.github.io/ecma262/#sec-speciesconstructor">SpeciesConstructor</a></emu-xref>(<var>srcBuffer</var>, <emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.github.io/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>).</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer">IsDetachedBuffer</a></emu-xref>(<var>srcBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>Else, Assert: <emu-xref aoid="IsConstructor"><a href="https://tc39.github.io/ecma262/#sec-isconstructor">IsConstructor</a></emu-xref>(<var>cloneConstructor</var>) is <emu-val>true</emu-val>.</li><li><del>Let</del> <ins>If <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>srcBuffer</var>) then let <var>srcBlock</var> be <var>srcBuffer</var>.[[SharedArrayBufferData]], else let</ins> <var>srcBlock</var> be <var>srcBuffer</var>.[[ArrayBufferData]].</li><li>...
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" aoid="GetValueFromBuffer">
        <h1><span class="secnum">7.1.1.3</span>GetValueFromBuffer( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>,  <ins><var>isTypedArray</var>,</ins> <var>isLittleEndian</var> ) (<a href="https://tc39.github.io/ecma262/#sec-getvaluefrombuffer">ES7 24.1.1.5</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">#</a></span></span></h1>
        <p> This algorithm is modified as follows:</p>
        <p> The abstract operation GetValueFromBuffer takes  <del>four</del><ins>five</ins> parameters, an ArrayBuffer  <ins>or SharedArrayBuffer</ins> <var>arrayBuffer</var>, an integer <var>byteIndex</var>, a String <var>type</var>,  <ins>a Boolean <var>isTypedArray</var>,</ins> and optionally a Boolean <var>isLittleEndian</var>. This operation performs the following steps:</p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="IsDetachedBuffer"><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li>Assert: There are sufficient bytes in <var>arrayBuffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li>Assert: <var>byteIndex</var> is an integer value ≥ 0.</li><li><del>Let</del> <ins>If <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>arrayBuffer</var>) then let <var>block</var> be <var>arrayBuffer</var>.[[SharedArrayBufferData]], else let</ins> <var>block</var> be <var>arrayBuffer</var>.[[ArrayBufferData]].</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for Element Type <var>type</var>.</li><li><del>Let <var>rawValue</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of <var>elementSize</var> containing, in order, the <var>elementSize</var> sequence of bytes starting with <var>block</var>[<var>byteIndex</var>].</del><br><ins>If <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>arrayBuffer</var>) then: </ins><ol><li><ins>Let <var>accessAtomic</var> be <emu-val>true</emu-val> if <var>isTypedArray</var> is <emu-val>true</emu-val> and <var>type</var> is <code>"Int8"</code>, <code>"Uint8"</code>, <code>"Int16"</code>, <code>"Uint16"</code>, <code>"Int32"</code>, or <code>"Uint32"</code>, otherwise <emu-val>false</emu-val></ins></li><li><ins>Let <var>rawValue</var> be <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref>(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>elementSize</var>)</ins></li><li><ins>Assert: <var>rawValue</var> is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of size <var>elementSize</var></ins></li></ol></li><li><ins>Else, let <var>rawValue</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> containing, in order, the <var>elementSize</var> sequence of bytes starting with <var>block</var>[<var>byteIndex</var>].</ins></li><li>If <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to <del>either <emu-val>true</emu-val> or <emu-val>false</emu-val>. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref> abstract operation</del> <ins>the value of the [[LittleEndian]] internal slot of the surrounding agent's <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref></ins>.</li><li>...
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.SetValueInBuffer" aoid="SetValueInBuffer">
        <h1><span class="secnum">7.1.1.4</span>SetValueInBuffer( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>,  <ins><var>isTypedArray</var>,</ins> <var>value</var>, <var>isLittleEndian</var> ) (<a href="https://tc39.github.io/ecma262/#sec-setvalueinbuffer">ES7 24.1.1.6</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">#</a></span></span></h1>
        <p> This algorithm is modified as follows:</p>
        <p> The abstract operation SetValueInBuffer takes  <del>five</del><ins>six</ins> parameters, an ArrayBuffer  <ins>or SharedArrayBuffer</ins> <var>arrayBuffer</var>, an integer <var>byteIndex</var>, a String <var>type</var>, a Boolean <var>isTypedArray</var>, a Number <var>value</var>, and optionally a Boolean <var>isLittleEndian</var>. This operation performs the following steps:</p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="IsDetachedBuffer"><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li>Assert: There are sufficient bytes in <var>arrayBuffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li>Assert: <var>byteIndex</var> is an integer value ≥ 0.</li><li>Assert: <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>value</var>) is Number.</li><li><del>Let</del> <ins>If <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>arrayBuffer</var>) then let <var>block</var> be <var>arrayBuffer</var>.[[SharedArrayBufferData]], else let</ins> <var>block</var> be <var>arrayBuffer</var>.[[ArrayBufferData]].</li><li>Assert: <var>block</var> is not <emu-val>undefined</emu-val>.</li><li>If <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to <del>either <emu-val>true</emu-val> or <emu-val>false</emu-val>. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref> abstract operation</del> <ins>the value of the [[LittleEndian]] internal slot of the surrounding agent's <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref></ins>.</li><li>If <var>type</var> is <code>"Float32"</code>, then<ol><li>...</li></ol></li><li>Else if <var>type</var> is <code>"Float64"</code>, then<ol><li>...</li></ol></li><li>Else,<ol><li>...</li></ol></li><li><del> Store the individual bytes of <var>rawBytes</var> into <var>block</var>, in order, starting at <var>block</var>[<var>byteIndex</var>]. </del><br> <ins> If <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>arrayBuffer</var>) then: </ins><ol><li><ins>Let <var>accessAtomic</var> be <emu-val>true</emu-val> if <var>isTypedArray</var> is <emu-val>true</emu-val> and <var>type</var> is <code>"Int8"</code>, <code>"Uint8"</code>, <code>"Int16"</code>, <code>"Uint16"</code>, <code>"Int32"</code>, or <code>"Uint32"</code>, otherwise <emu-val>false</emu-val></ins></li><li><ins>Call <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref>(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>elementSize</var>, <var>rawBytes</var>)</ins></li></ol></li><li><ins> Else, Store the individual bytes of <var>rawBytes</var> into <var>block</var>, in order, starting at <var>block</var>[<var>byteIndex</var>]. </ins></li><li>Return <emu-xref aoid="NormalCompletion"><a href="https://tc39.github.io/ecma262/#sec-normalcompletion">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).
        </li></ol></emu-alg>
      </emu-clause>

    </emu-clause> <!-- abstract -->
  </emu-clause> <!-- ArrayBuffer -->

  <emu-clause id="StructuredData.DataView">
    <h1><span class="secnum">7.2</span>DataView Objects (<a href="https://tc39.github.io/ecma262/#sec-dataview-objects">ES7 24.2</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.DataView">#</a></span></span></h1>

    <!-- es6num="24.2.1" -->
    <emu-clause id="sec-abstract-operations-for-dataview-objects">
      <h1><span class="secnum">7.2.1</span>Abstract Operations For DataView Objects (<a href="https://tc39.github.io/ecma262/#sec-abstract-operations-for-dataview-objects">ES7 24.2.1</a>)<span class="utils"><span class="anchor"><a href="#sec-abstract-operations-for-dataview-objects">#</a></span></span></h1>

      <!-- es6num="24.2.1.1" -->
      <emu-clause id="sec-getviewvalue" aoid="GetViewValue">
        <h1><span class="secnum">7.2.1.1</span>GetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var> ) (<a href="https://tc39.github.io/ecma262/#sec-getviewvalue">ES7 24.2.1.1</a>)<span class="utils"><span class="anchor"><a href="#sec-getviewvalue">#</a></span></span></h1>
        <p> This algorithm is modified as follows:  </p>

        <p> In the call to <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>, pass <emu-val>false</emu-val> as the fourth argument to indicate that the operation is performed on a DataView.  </p>
      </emu-clause>

      <!-- es6num="24.2.1.2" -->
      <emu-clause id="sec-setviewvalue" aoid="SetViewValue">
        <h1><span class="secnum">7.2.1.2</span>SetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var>, <var>value</var> ) (<a href="https://tc39.github.io/ecma262/#sec-setviewvalue">ES7 24.2.1.2</a>)<span class="utils"><span class="anchor"><a href="#sec-setviewvalue">#</a></span></span></h1>
        <p> This algorithm is modified as follows:  </p>

        <p> In the call to <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>, pass <emu-val>false</emu-val> as the fourth argument to indicate that the operation is performed on a DataView.  </p>
      </emu-clause>

    </emu-clause>

    <emu-clause id="StructuredData.DataView.constructor">
      <h1><span class="secnum">7.2.2</span>The DataView Constructor (<a href="https://tc39.github.io/ecma262/#sec-dataview-constructor">ES7 24.2.2</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.DataView.constructor">#</a></span></span></h1>
      <emu-clause id="StructuredData.DataView.constructor.detail">
        <h1><span class="secnum">7.2.2.1</span>DataView( <var>buffer</var> [ , <var>byteOffset</var> [ , <var>byteLength</var> ] ] ) (<a href="https://tc39.github.io/ecma262/#sec-dataview-buffer-byteoffset-bytelength">ES7 24.2.2.1</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.DataView.constructor.detail">#</a></span></span></h1>
        <p> This algorithm is modified as follows:  </p>
        <p>When the <code>DataView</code> is called with at least one argument <var>buffer</var>, the following steps are taken:</p>
        <emu-alg><ol><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>buffer</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>buffer</var> does not have an [[ArrayBufferData]] <ins>or a [[SharedArrayBufferData]]</ins> internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>offset</var> be ? ToIndex(<var>byteOffset</var>).</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><del>Let</del> <ins>If <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>buffer</var>) then let <var>bufferByteLength</var> be <var>buffer</var>.[[SharedArrayBufferByteLength]], else let</ins> <var>bufferByteLength</var> be <var>buffer</var>.[[ArrayBufferByteLength]].</li><li>...
        </li></ol></emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause> <!-- DataView -->

  <emu-clause id="StructuredData.SharedArrayBuffer">
    <h1><span class="secnum">7.3</span>SharedArrayBuffer Objects<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer">#</a></span></span></h1>

    <emu-clause id="StructuredData.SharedArrayBuffer.abstract">
      <h1><span class="secnum">7.3.1</span>Abstract Operations for SharedArrayBuffer<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.abstract">#</a></span></span></h1>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer">
        <h1><span class="secnum">7.3.1.1</span>AllocateSharedArrayBuffer( <var>constructor</var>, <var>byteLength</var> )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer">#</a></span></span></h1>
        <p> The abstract operation AllocateSharedArrayBuffer with arguments <var>constructor</var> and <var>byteLength</var> is used to create a SharedArrayBuffer object. It performs the following steps:</p>

        <emu-alg><ol><li>Let <var>obj</var> be <emu-xref aoid="OrdinaryCreateFromConstructor"><a href="https://tc39.github.io/ecma262/#sec-ordinarycreatefromconstructor">OrdinaryCreateFromConstructor</a></emu-xref>(constructor, "%SharedArrayBufferPrototype%", «‍[[SharedArrayBufferData]], [[SharedArrayBufferByteLength]]» ).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>obj</var>).</li><li>Assert: <var>byteLength</var> is a nonnegative integer.</li><li>Let <var>block</var> be CreateSharedByteDataBlock(<var>byteLength</var>).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>block</var>).</li><li>Set <var>obj</var>’s [[SharedArrayBufferData]] internal slot to block.</li><li>Set <var>obj</var>’s [[SharedArrayBufferByteLength]] internal slot to <var>byteLength</var>.</li><li>Return <var>obj</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.IsSharedMemory" aoid="IsSharedMemory">
        <h1><span class="secnum">7.3.1.2</span>IsSharedMemory( <var>obj</var> )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">#</a></span></span></h1>
        <p> IsSharedMemory tests whether an object represents shared memory.  </p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>obj</var>) is Object and it has an [[ArrayBufferData]] internal slot or a [[SharedArrayBufferData]] internal slot.</li><li>If <var>obj</var> has a [[SharedArrayBufferData]] internal slot then return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.
        </li></ol></emu-alg>
      </emu-clause>

    </emu-clause> <!-- abstract -->

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor">
      <h1><span class="secnum">7.3.2</span>The SharedArrayBuffer Constructor<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor">#</a></span></span></h1>
      <p> The SharedArrayBuffer constructor is the %SharedArrayBuffer% intrinsic object and the initial value of the <code>SharedArrayBuffer</code> property of the <emu-xref href="#global-object"><a href="https://tc39.github.io/ecma262/#global-object">global object</a></emu-xref>. When called as a constructor it creates and initializes a new SharedArrayBuffer object.  The SharedArrayBuffer constructor is not intended to be called as a function and will throw an exception when called in that manner.  </p>

      <p> The SharedArrayBuffer constructor is designed to be subclassable. It may be used as the value of an <code>extends</code> clause of a class definition. Subclass constructors that intend to inherit the specified SharedArrayBuffer behaviour must include a <code>super</code> call to the SharedArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support the <code>SharedArrayBuffer.prototype</code> built-in methods.  </p>

      <emu-note><span class="note">Note</span>
        <p> Unlike an ArrayBuffer, a SharedArrayBuffer cannot become detached, and its internal [[SharedArrayBufferData]] slot is never <emu-val>undefined</emu-val>.</p>
      </emu-note>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.withLength">
        <h1><span class="secnum">7.3.2.1</span>SharedArrayBuffer( <var>length</var> )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.withLength">#</a></span></span></h1>
        <p> SharedArrayBuffer called with argument <var>length</var> performs the following steps:  </p>
        <emu-alg><ol><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>numberLength</var> be <emu-xref aoid="ToNumber"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>length</var>).</li><li>Let <var>byteLength</var> be <emu-xref aoid="ToLength"><a href="https://tc39.github.io/ecma262/#sec-tolength">ToLength</a></emu-xref>(<var>numberLength</var>).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>byteLength</var>).</li><li>If <emu-xref aoid="SameValueZero"><a href="https://tc39.github.io/ecma262/#sec-samevaluezero">SameValueZero</a></emu-xref>(<var>numberLength</var>, <var>byteLength</var>) is <emu-val>false</emu-val>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Return AllocateSharedArrayBuffer(NewTarget, <var>byteLength</var>).
        </li></ol></emu-alg>
      </emu-clause>
    </emu-clause> <!-- constructor -->

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties">
      <h1><span class="secnum">7.3.3</span>Properties of the SharedArrayBuffer constructor<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.properties">#</a></span></span></h1>

      <p>The value of the [[Prototype]] internal slot of the SharedArrayBuffer constructor is the intrinsic object <emu-xref href="#sec-properties-of-the-function-constructor"><a href="https://tc39.github.io/ecma262/#sec-properties-of-the-function-constructor">%FunctionPrototype%</a></emu-xref> (q.v.).</p>

      <p>Besides its <code>length</code> property (whose value is 1), the SharedArrayBuffer constructor has the following properties:</p>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.prototype">
        <h1><span class="secnum">7.3.3.1</span>SharedArrayBuffer.prototype<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.properties.prototype">#</a></span></span></h1>
        <p> The initial value of SharedArrayBuffer.prototype is the intrinsic object %SharedArrayBufferPrototype% (q.v.).</p>
        <p> This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>false</emu-val> }.</p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.get_species">
        <h1><span class="secnum">7.3.3.2</span>get SharedArrayBuffer [ @@species ]<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.properties.get_species">#</a></span></span></h1>
        <p><code>SharedArrayBuffer[@@species]</code> is an accessor property whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
        <emu-alg><ol><li>Return the <emu-val>this</emu-val> value.
        </li></ol></emu-alg>
        <p> The value of the name property of this function is "<code>get [Symbol.species]</code>".</p>
      </emu-clause>
    </emu-clause> <!-- properties -->

    <emu-clause id="StructuredData.SharedArrayBuffer.prototype">
      <h1><span class="secnum">7.3.4</span>Properties of the SharedArrayBuffer prototype object<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype">#</a></span></span></h1>

      <p>The SharedArrayBuffer prototype object is the intrinsic object %SharedArrayBufferPrototype%. The value of the [[Prototype]] internal slot of the SharedArrayBuffer prototype object is the intrinsic object <emu-xref href="#sec-properties-of-the-object-prototype-object"><a href="https://tc39.github.io/ecma262/#sec-properties-of-the-object-prototype-object">%ObjectPrototype%</a></emu-xref> (19.1.3). The SharedArrayBuffer prototype object is an ordinary object. It does not have a [[SharedArrayBufferData]] or [[SharedArrayBufferByteLength]] internal slot.</p>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.get_byteLength">
        <h1><span class="secnum">7.3.4.1</span>get SharedArrayBuffer.prototype.byteLength<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.get_byteLength">#</a></span></span></h1>

        <p> SharedArrayBuffer.prototype.byteLength is an accessor property whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:  </p>

        <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>O</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>O</var> does not have a [[SharedArrayBufferData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>length</var> be the value of <var>O</var>’s [[SharedArrayBufferByteLength]] internal slot.</li><li>Return <var>length</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.constructor">
        <h1><span class="secnum">7.3.4.2</span>SharedArrayBuffer.prototype.constructor<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.constructor">#</a></span></span></h1>
        <p> The initial value of <code>SharedArrayBuffer.prototype.constructor</code> is the intrinsic object %SharedArrayBuffer%.  </p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.slice">
        <h1><span class="secnum">7.3.4.3</span>SharedArrayBuffer.prototype.slice( <var>start</var>, <var>end</var> )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.slice">#</a></span></span></h1>
        <p> The following steps are taken:  </p>
        <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>O</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>O</var> does not have a [[SharedArrayBufferData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>len</var> be the value of <var>O</var>’s [[SharedArrayBufferByteLength]] internal slot.</li><li>Let <var>relativeStart</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>start</var>).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>relativeStart</var>).</li><li>If <var>relativeStart</var> &lt; 0, let first be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>((<var>len</var> + <var>relativeStart</var>), 0); else let first be <emu-xref aoid="min"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>end</var>).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>relativeEnd</var>).</li><li>If <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>((<var>len</var> + <var>relativeEnd</var>), 0); else let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li>Let <var>newLen</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(<var>final</var> - <var>first</var>, 0).</li><li>Let <var>ctor</var> be <emu-xref aoid="SpeciesConstructor"><a href="https://tc39.github.io/ecma262/#sec-speciesconstructor">SpeciesConstructor</a></emu-xref>(<var>O</var>, %SharedArrayBuffer%).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>ctor</var>).</li><li>Let <var>new</var> be <emu-xref aoid="Construct"><a href="https://tc39.github.io/ecma262/#sec-construct">Construct</a></emu-xref>(<var>ctor</var>, «newLen»).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>new</var>).</li><li>If <var>new</var> does not have a [[SharedArrayBufferData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="SameValue"><a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>new</var>, <var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If the value of <var>new</var>’s [[SharedArrayBufferByteLength]] internal slot &lt; <var>newLen</var>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>fromBuf</var> be the value of <var>O</var>’s [[SharedArrayBufferData]] internal slot.</li><li>Let <var>toBuf</var> be the value of <var>new</var>’s [[SharedArrayBufferData]] internal slot.</li><li>Perform <emu-xref aoid="CopyDataBlockBytes"><a href="https://tc39.github.io/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>toBuf</var>, 0, <var>fromBuf</var>, <var>first</var>, <var>newLen</var>).</li><li>Return <var>new</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.toString">
        <h1><span class="secnum">7.3.4.4</span>SharedArrayBuffer.prototype[ @@toStringTag ]<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.toString">#</a></span></span></h1>
        <p> The initial value of the @@toStringTag property is the String value <code>"SharedArrayBuffer"</code>.</p>

        <p>This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>true</emu-val> }.</p>
      </emu-clause>
    </emu-clause> <!-- prototype -->

    <emu-clause id="StructuredData.SharedArrayBuffer.instances">
      <h1><span class="secnum">7.3.5</span>Properties of the SharedArrayBuffer instances<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.instances">#</a></span></span></h1>

      <p> SharedArrayBuffer instances inherit properties from the SharedArrayBuffer prototype object. SharedArrayBuffer instances each have a [[SharedArrayBufferData]] internal slot and a [[SharedArrayBufferByteLength]] internal slot.  </p>

      <emu-note><span class="note">Note</span>
        <p> SharedArrayBuffer instances, unlike ArrayBuffer instances, are never detached.  </p>
      </emu-note>
    </emu-clause> <!-- instances -->

  </emu-clause> <!-- SharedArrayBuffer -->
</emu-clause> <!-- Structured data -->

<emu-clause id="AtomicsObject">
  <h1><span class="secnum">8</span>The Atomics Object<span class="utils"><span class="anchor"><a href="#AtomicsObject">#</a></span></span></h1>

  <p>The Atomics object is the  <dfn>%Atomics%</dfn> intrinsic object and the initial value of the <code>Atomics</code> property of the <emu-xref href="#global-object"><a href="https://tc39.github.io/ecma262/#global-object">global object</a></emu-xref>. The Atomics object is a single ordinary object.</p>
  <p> The Atomics object provides functions that operate indivisibly (atomically) on shared memory array cells as well as functions that let agents wait for and dispatch primitive events.  When used with discipline, the Atomics functions allow multi-agent programs that communicate through shared memory to execute in a well-understood order even on parallel CPUs.  The rules that govern shared-memory communication are provided by the  <dfn>memory model</dfn>, defined below.  </p>
  <p>The value of the [[Prototype]] internal slot of the Atomics object is the intrinsic object <emu-xref href="#sec-properties-of-the-object-prototype-object"><a href="https://tc39.github.io/ecma262/#sec-properties-of-the-object-prototype-object">%ObjectPrototype%</a></emu-xref>.</p>
  <p>The Atomics object is not a function object. It does not have a [[Construct]] internal method; it is not possible to use the Atomics object as a constructor with the <code>new</code> operator. The Atomics object also does not have a [[Call]] internal method; it is not possible to invoke the Atomics object as a function.</p>

  <emu-clause id="AtomicsObjectFunctionProps.semantics">
    <h1><span class="secnum">8.1</span>Runtime semantics<span class="utils"><span class="anchor"><a href="#AtomicsObjectFunctionProps.semantics">#</a></span></span></h1>

    <emu-clause id="AtomicsObject.MemoryModel">
      <h1><span class="secnum">8.1.1</span>Memory model<span class="utils"><span class="anchor"><a href="#AtomicsObject.MemoryModel">#</a></span></span></h1>

      <p> The <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> determines when a particular read from
        shared memory may observe a particular write to shared memory.
        This is straight-forward in the case when the program has no
        data races, as all shared memory reads and writes are then
        clearly ordered and reads can only see writes that happened
        before them in the order.  When the program has data races,
        however, reads may observe writes that appear to come out of
        the past, the future, or should not have happened, as some of
        the reads and writes (to the same location) that are unordered
        relative to each other may access the same memory without
        coordination.  This section provides rules that determine when
        a data race is not present in the program and also provides a
        conventional model that determines event ordering in data race
        free programs; it then provides additional rules that
        determine the allowable effects of data races.  </p>

      <p> ECMAScript shared memory obeys very weak type discipline, in
        that the byte array of a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> can be aliased by
        TypedArrays of different types and accessed without natural
        alignment via DataViews, and also in that atomic operations
        must be applied to cells that are not exclusively atomic.  (In
        this it is similar to the "low-level atomics" of C.)  In
        contrast, correct synchronization to achieve data race freedom
        requires a stronger type discipline where a location used for
        synchronization during some segment of the program's lifetime
        is used only for synchronization and where all atomic
        operations that touch the location during that segment use the
        exact same access range.  The weak type discipline thus
        complicates the description of synchronization.  </p>

      <emu-note><span class="note">Note</span>
        <p> (spec draft note) Acknowledgement: The description of many
          fundamentals and sequentially consistent execution owes much
          to the Java <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>.  </p>

        <p> This section provides an axiomatic model that it then
          augments with operational details to specify what might
          happen during data races.  If review indicates that this
          model has problems that are not easily fixable it is
          probable that we should move in an operational direction for
          the whole model, even if that makes it less nice to use.  </p>
      </emu-note>

      <emu-clause id="AtomicsObject.Fundamentals">
        <h1><span class="secnum">8.1.1.1</span>Fundamentals<span class="utils"><span class="anchor"><a href="#AtomicsObject.Fundamentals">#</a></span></span></h1>

        <p> Shared memory accesses (reads and writes) are divided into
          two groups, atomic accesses and data accesses, defined
          below.  </p>

        <p> An  <em>event</em> in an agent is a either a data access (a
          
          <em>non-synchronizing event</em>), or an atomic access or a
          call to Atomics.wake or Atomics.wait (<em>synchronizing
            events</em>).  Synchronizing events can additionally be
          embedding-specific.  </p>

        <emu-note><span class="note">Note 1</span>
          <p> Examples of embedding-specific synchronizing events that
            should be accounted for are: sending a SharedArrayBuffer
            from one agent to another (e.g., by <code>postMessage</code> in a
            browser), starting and stopping agents, and communicating
            within the agent cluster via channels other than shared
            memory.  </p>
        </emu-note>

        <p> Program transformations by a compiler or the hardware must
          not reorder an agent's non-synchronizing events with its
          synchronizing events, nor reorder its synchronizing events
          with each other.  </p>

        <emu-note><span class="note">Note 2</span>
          <p> The prohibition on reordering synchronizing events is
            stronger than in most mainstream concurrent languages.  </p>
        </emu-note>

        <p> The  <em>program order</em> of an agent is a total ordering
          of the agent's events that is consistent with the semantics
          of the ECMAScript program running in that agent.  </p>

        <p> The  <em>execution order</em> of an agent cluster is a
          total order of the events of an execution of the programs in
          the cluster; the execution order must be consistent with
          each agent's program order.  </p>

        <p> Shared memory access is always performed by two primitive
          subroutines, <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref> and <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref>.  These
          subroutines never perform non-shared-memory access.  </p>

        <p> Let the  <em>candidate atomic accesses</em> (candidate
          atomic reads, candidate atomic writes) be those algorithm
          steps that are labeled "With atomic access to shared memory"
          in the algorithms in subsequent sections, ie, the simple
          <code>load</code> and <code>store</code> operations and the read-modify-write
          operations <code>add</code>, <code>sub</code>, <code>and</code>, <code>or</code>, <code>xor</code>, <code>exchange</code>, and
          <code>compareExchange</code>; the accesses will ultimately be performed
          by <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref> and <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref>.  A
          read-modify-write atomic access is considered a read
          followed by a write.  </p>

        <p> Let the  <em>candidate data accesses</em> (candidate data
          reads, candidate data writes) be those invocations of
          <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref> and <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref> that are not part of
          the candidate atomic accesses.  </p>

        <p> Let the  <em>access range</em> of a shared memory access be
          the memory cells read or written by the access.  (These cells
          are always consecutive and within a single <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data
          Block</a></emu-xref>.)  </p>

        <p> A candidate atomic read R is  <em>viable</em> in an
          execution order E if it reads the value written by a
          candidate atomic write W that precedes R in E, W and R have
          identical access ranges, and there exists no write V in E
          s.t. W precedes V and V precedes R and V writes to any byte
          in the access range of R.  </p>

        <p> If a candidate atomic read <var>R</var> is not viable in some
          execution order, then <var>R</var> is simply  <em>not viable</em>.  </p>

        <p> Finally, let the  <em>atomic accesses</em> of the program
          be those candidate atomic accesses that are viable, and let
          the  <em>data accesses</em> be the union of the candidate
          data accesses and the non-viable candidate atomic
          accesses.  </p>

        <emu-note><span class="note">Note 3</span>
          <p> One goal of this section is to define data races, which
            means defining happens-before, which means defining
            synchronization order.  Synchronization order depends on
            well-defined atomic accesses: An atomic read is
            well-defined for synchronization only if it reads from an
            atomic write to the same access range, where that write
            does not race with any data writes or with atomic writes
            to an overlapping but not-equal access range.  We can't
            use the definition of data races directly to determine
            well-definedness (or the definition would be circular),
            and instead use the notion of visibility of writes in the
            execution order.  </p>
        </emu-note>

        <emu-note><span class="note">Note 4</span>
          <p> (Spec draft notes)  </p>

          <p> Claim: After requiring atomic reads to be viable there
            may still be data races (by the definition below) that
            involve atomic writes, but none of them will be observed
            by atomic reads.  Hence synchronization order is not
            affected by data races on atomics.  </p>

          <p> Without a working notion of viability it is not clear how
            we can salvage an axiomatic formalization of the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>.  </p>

          <p> The notion of viability used here is fairly strong.  It
            would be interesting to try to loosen it up.  </p>
        </emu-note>

        <p> Similarly, the <code>wait</code> event is viable (and thus considered
          as a synchronizing event) only if the atomic read it
          performs is viable.  </p>

        <p> Synchronizing events are then performed in a single total
          order -- known as the  <em>synchronization order</em> -- that
          is a sub-sequence of the execution order (and hence
          consistent with each agent's program order).  This induces
          a  <em>synchronized-with</em> relation on actions:  </p>

        <ul>
          <li> An atomic write of a location synchronizes-with all
            subsequent (later in the synchronization order) atomic reads of that
            location.
          
          </li><li> A <code>wake</code> call synchronizes-with a <code>wait</code> call that
            returns as a result of the <code>wake</code>.
          
          </li><li> In an embedding-specific synchronizing event that has a
            sender and a receiver (such as sending a SharedArrayBuffer
            from one agent to another), the sending action
            synchronizes-with the receiving action.
        
        </li></ul>

        <p> We can now define the happens-before relation, which gives
          rise to definitions of data races.  An event A  <em>happens
          before</em> another event B if either:</p>

        <ul>
          <li> A precedes B in the agent's program order,
          
          </li><li> A synchronizes-with B, or
          
          </li><li> A happens before C and C happens before B (transitivity).
        
        </li></ul>

        <p> Executions must be such that  <em>happens before</em> is
          irreflexive (acyclic).  </p>

        <p> Two shared memory accesses whose access ranges intersect
          constitute a  <em>data race</em> if neither happens before
          the other, at least one of them is a write, and they are not
          both atomic writes to the same access range.  </p>

        <p> If an atomic access is not in a data race, then the shared
          memory reads and writes issued by the atomic access must be
          performed indivisibly (following the rules of
          <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref> and <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref>), and in a
          read-modify-write atomic access no write by another agent must
          be allowed to execute between the read and the write.  </p>
      </emu-clause>

      <emu-clause id="AtomicsObject.SeqCst">
        <h1><span class="secnum">8.1.1.2</span>Sequential consistency<span class="utils"><span class="anchor"><a href="#AtomicsObject.SeqCst">#</a></span></span></h1>

        <p> An execution of a set of events is  <em>sequentially
            consistent</em> if the events occur in an execution order,
            and a read R of a location L sees a write W s.t. W
            precedes R in the execution order, and there is no other
            write V to L s.t. W precedes V and V precedes R.  </p>

        <emu-note><span class="note">Note</span>
          <p> Observe that a sequentially consistent execution can still
            have a data race since sequential consistency only requires
            a certain execution behavior for a specific ordering of an
            event set.  </p>
        </emu-note>

        <p> The program will appear to be sequentially consistent if
          all sequentially consistent executions of the program have
          no data races.  In that case, the following hold:  </p>

        <ul>
          <li> A data access read R only sees a write W that happens
            before R, where there is no write V such that V happens
            before R and W happens before V. 

          </li><li> An atomic read R sees either the last preceding (in
            synchronization order) atomic write U to the same
            location, or a non-atomic write W that happens before R,
            where there is no write V such that V happens before R and
            W happens before V.
        
        </li></ul>
      </emu-clause>

      <emu-clause id="AtomicsObject.DataRaces">
        <h1><span class="secnum">8.1.1.3</span>Data races<span class="utils"><span class="anchor"><a href="#AtomicsObject.DataRaces">#</a></span></span></h1>

        <p> In a data race the write-to-read visibility guarantees
          provided by sequential consistency do not hold; an atomic
          access in a data race is not indivisible; and generally
          programs with data races do not behave as if they were
          sequentially consistent.  Data races expose the effects of
          program transformations in the compiler and in the hardware,
          which are unintuitive and platform-specific.  ECMAScript
          programs with data races are safe (races cannot subvert the
          language implementation, they affect only the memory
          locations in Shared Data Blocks), but the values resulting
          from a data race are often hard to predict.  The effects of
          data races include observing values that, within limits,
          appear to come from the past (because they should have been
          written before other values, which have not been seen) or
          from the future (because they should have been written after
          other values, which have not been seen), or which should not
          exist at all (because some conflicting writes may interleave
          the bytes being written).  </p>

        <p> When an atomic access that is in a data race performs a
          read-write pair of memory accesses, those accesses are
          performed as if the qualifier "With atomic access to shared
          memory" were omitted from the algorithms below.  </p>

        <emu-note><span class="note">Note 1</span>
          <p> Hence, a write access from another agent may be allowed
            to execute between the read and the write of the pair,
            and, as defined by <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref> and
            <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref>, even the individual accesses in the
            atomic access may not be executed atomically.  </p>

          <p> For example, non-lock-free atomic operations will allow
            such a race to be observed.  </p>
        </emu-note>

        <p> The following rules restrict program behavior in the
          presence of data races:  </p>

        <ul>
          <!-- Deoptimization (maybe, unlikely); rematerialization -->
          <li> Any given read must only observe a single value.  (For
            example, if what is semantically a single read in the
            program is executed multiple times then the program is
            subsequently allowed to observe only one of the values
            read.) 

          </li><li> Any given read must only observe value changes in memory
            that follow from program semantics.  (For example, the
            compiler or hardware may not introduce certain observable
            writes, such as using read-modify-write operations on a
            larger location to write a smaller datum, writing a value
            to memory that the program could not have written, or
            spuriously writing a just-read value back to the location
            it was read from.  Note that byte interleavings resulting
            from races, described below, is within program semantics.) 

          </li><li> Any given read must only observe values that have been
            produced by the program's execution.  (For example, the
            compiler or hardware may not speculate about a value and
            then use that value to justify the speculation.)
        
        </li></ul>

        <emu-note><span class="note">Note 2</span>
          <p> Examples of program transformations that remain valid
            (assuming no intra-agent semantic change and no reordering
            with respect to synchronizing events) are: merging
            multiple data reads from the same location, reordering
            data reads from different locations, introducing
            speculative data reads, merging multiple data writes to
            the same location, and reordering data writes to different
            locations.    </p>
        </emu-note>

        <p> The subroutines <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref> and <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref>
          define the valid outcomes of data races.  In general a race
          allows a value to be read that is an interleaving of bytes
          being written and bytes already in memory.  However,
          <emu-xref aoid="ReadSharedMemory"><a href="#Atomics.ReadSharedMemory">ReadSharedMemory</a></emu-xref> and <emu-xref aoid="WriteSharedMemory"><a href="#Atomics.WriteSharedMemory">WriteSharedMemory</a></emu-xref> have special
          provisions that allow some classes of data races to have
          somewhat predictable outcomes.  </p>

        <emu-note><span class="note">Note 3</span>
          <p> The special provisions are present because all hardware
            supports the specialized behavior and because that
            behavior is valuable to programs in practice.  Note,
            however, that program transformations can have surprising
            effects on the timing of memory accesses: data accesses
            may be moved or removed if deemed redundant.  </p>
        </emu-note>

      </emu-clause>

    </emu-clause>

    <emu-clause id="Atomics.ReadSharedMemory" aoid="ReadSharedMemory">
      <h1><span class="secnum">8.1.2</span>ReadSharedMemory(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>numBytes</var>)<span class="utils"><span class="anchor"><a href="#Atomics.ReadSharedMemory">#</a></span></span></h1>

      <p> ReadSharedMemory takes four arguments, a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref>
        <var>block</var>, a nonnegative integer <var>byteIndex</var>, a Boolean
        <var>accessAtomic</var>, and a nonnegative integer <var>numBytes</var>, and
        returns a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> containing, in order, the <var>numBytes</var> sequence
        of bytes starting with <var>block</var>[<var>byteIndex</var>], using
        <var>accessAtomic</var> to guide the operation, as follows:  </p>

      <ol>
        <li> If the read has a data race with any number of writes where
          the read and the writes all access the exact same access
          range, and the read has no data race with any other writes,
          and <var>accessAtomic</var> is <emu-val>true</emu-val>, then the bytes that are returned
          are the bytes in memory before any of the writes occurred or
          the bytes written by one of the writes. 

        </li><li> Otherwise, the read may have a data race with any number of
          writes, and the bytes that are returned are selected
          individually in arbitrary order as follows.  For each location
          in the access range of the read, select either the byte in
          memory at that location or a byte from one of the values to be
          written if it provides a byte for that location.
      
      </li></ol>

      <p> ReadSharedMemory may contain machinery that speculates
        whether a read request will be made. If so, it may read
        (following the preceding steps) the value before the request
        is made, provided such speculation does not violate
        transformation rules described earlier (notably rules about
        reordering with respect to synchronizing events).  </p>

    </emu-clause>

    <emu-clause id="Atomics.WriteSharedMemory" aoid="WriteSharedMemory">
      <h1><span class="secnum">8.1.3</span>WriteSharedMemory(<var>block</var>, <var>byteIndex</var>, <var>accessAtomic</var>, <var>numBytes</var>, <var>rawBytes</var>)<span class="utils"><span class="anchor"><a href="#Atomics.WriteSharedMemory">#</a></span></span></h1>

      <p> WriteSharedMemory takes five arguments, a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> <var>block</var>,
        a nonnegative integer <var>byteIndex</var>, a Boolean
        <var>accessAtomic</var>, a nonnegative integer <var>numBytes</var>, and a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> <var>rawBytes</var> of <var>numBytes</var>, and stores the
        individual bytes of <var>rawBytes</var> into <var>block</var>, in order, starting
        at <var>block</var>[<var>byteIndex</var>], using <var>accessAtomic</var> to guide the
        operation, as follows:  </p>

      <ol>
        <li> If the write has a data race with any number of other writes
          where all the writes access the exact same access range, and
          the write has no data race with any other writes, and
          <var>accessAtomic</var> is <emu-val>true</emu-val>, then each write writes all of its
          bytes before the next write occurs, and the writes occur in
          some arbitrary order. 

        </li><li> Otherwise, the write may have a data race with any number of
          writes, and each write writes the bytes of its value
          individually in some arbitrary order, and the byte writes of
          all the writes can be interleaved in some arbitrary
          order.
      
      </li></ol>

      <p> WriteSharedMemory may contain machinery that delays the
        write request, and if so it may hold the bytes for later
        writing (following the preceding steps), provided such delay
        does not violate transformation rules described earlier
        (notably rules about reordering with respect to synchronizing
        events).  </p>

    </emu-clause>

    <emu-clause id="Atomics.ValidateSharedIntegerTypedArray" aoid="ValidateSharedIntegerTypedArray">
      <h1><span class="secnum">8.1.4</span>ValidateSharedIntegerTypedArray(<var>typedArray</var> [, <var>onlyInt32</var>] )<span class="utils"><span class="anchor"><a href="#Atomics.ValidateSharedIntegerTypedArray">#</a></span></span></h1>
      <emu-alg><ol><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>typedArray</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>typedArray</var> does not have a [[TypedArrayName]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>typeName</var> be the value of <var>typedArray</var>'s [[TypedArrayName]] internal slot</li><li>If <var>onlyInt32</var> is <emu-val>true</emu-val> then<ol><li>If <var>typeName</var> is not <code>"Int32Array"</code> then throw a <emu-val>TypeError</emu-val> exception</li></ol></li><li>Else<ol><li>If <var>typeName</var> is not <code>"Int8Array"</code>, <code>"Uint8Array"</code>, <code>"Int16Array"</code>, <code>"Uint16Array"</code>, <code>"Int32Array"</code>, or <code>"Uint32Array"</code> then throw a <emu-val>TypeError</emu-val> exception</li></ol></li><li>If <var>typedArray</var> does not have a [[ViewedArrayBuffer]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>buffer</var> be the value of <var>typedArray</var>’s [[ViewedArrayBuffer]] internal slot</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>buffer</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception</li><li>If <var>buffer</var> does not have a [[SharedArrayBufferData]] internal slot, throw a <emu-val>TypeError</emu-val> exception</li><li>Return <var>buffer</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.ValidateAtomicAccess" aoid="ValidateAtomicAccess">
      <h1><span class="secnum">8.1.5</span>ValidateAtomicAccess( <var>typedArray</var>, <var>requestIndex</var> )<span class="utils"><span class="anchor"><a href="#Atomics.ValidateAtomicAccess">#</a></span></span></h1>
      <p> Perform the following steps:  </p>
      <emu-alg><ol><li>Assert: <var>typedArray</var> is an Object that has a [[ViewedArrayBuffer]] internal slot</li><li>Let <var>numberIndex</var> be <emu-xref aoid="ToNumber"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>requestIndex</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>numberIndex</var>)</li><li>Let <var>accessIndex</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>numberIndex</var>)</li><li>If <var>numberIndex</var> ≠ <var>accessIndex</var>, throw a <emu-val>RangeError</emu-val> exception</li><li>Let <var>length</var> be the value of <var>typedArray</var>'s [[ArrayLength]] internal slot</li><li>If <var>accessIndex</var> &lt; 0 or <var>accessIndex</var> ≥ <var>length</var>, throw a <emu-val>RangeError</emu-val> exception</li><li>Return <var>accessIndex</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.AgentSignifier" aoid="AgentSignifier">
      <h1><span class="secnum">8.1.6</span>AgentSignifier( )<span class="utils"><span class="anchor"><a href="#Atomics.AgentSignifier">#</a></span></span></h1>
      <p> When AgentSignifier is called without arguments then the following steps are taken.</p>
      <emu-alg><ol><li>Let <var>W</var> be the value of the [[Signifier]] property of the <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref> of the <em>surrounding agent</em>.</li><li>Return <var>W</var>.
      </li></ol></emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.AgentCanSuspend" aoid="AgentCanSuspend">
      <h1><span class="secnum">8.1.7</span>AgentCanSuspend( )<span class="utils"><span class="anchor"><a href="#Atomics.AgentCanSuspend">#</a></span></span></h1>
      <p> When AgentCanSuspend is called without arguments then the following steps are taken.</p>
      <emu-alg><ol><li>Let <var>B</var> be the value of the [[CanBlock]] property of the <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref> of the <em>surrounding agent</em>.</li><li>Return <var>B</var>.
      </li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p> In some environments it may not be reasonable for a given agent to suspend.  For example,
          in a web browser environment, it may be reasonable to disallow suspending a document's main event
          handling thread, while still allowing workers' event handling threads to suspend.  </p>
      </emu-note>

    </emu-clause>

    <emu-clause id="GetWaiterList" aoid="GetWaiterList">
      <h1><span class="secnum">8.1.8</span>GetWaiterList( <var>G</var>, <var>i</var> )<span class="utils"><span class="anchor"><a href="#GetWaiterList">#</a></span></span></h1>
      <p> A  <dfn>WaiterList</dfn> is a semantic object that contains an ordered list of those agents that are waiting on a location (<var>G</var>, <var>i</var>) in shared memory; <var>G</var> is a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">Shared Data Block ID</a></emu-xref> and <var>i</var> a byte offset into the memory referenced by <var>G</var>.  </p>
      <p> The agent cluster has a store of WaiterList objects; the store is indexed by (<var>G</var>, <var>i</var>).  WaiterLists are agent-independent: a lookup in the store of WaiterLists by (<var>G</var>, <var>i</var>) will result in the same WaiterList object in any agent in the agent cluster.  </p>
      <p> Operations on a WaiterList -- adding and removing waiting agents, traversing the list of agents, suspending and waking agents on the list -- may only be performed by agents that have entered the WaiterList's critical section.    </p>
      <p> When GetWaiterList is called with <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">Shared Data Block ID</a></emu-xref> <var>G</var> and nonnegative integer <var>i</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: <var>G</var> is the <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">Shared Data Block ID</a></emu-xref> of some <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref></li><li>Assert: <var>i</var> and <var>i</var>+3 are valid byte offsets within the memory referenced by <var>G</var></li><li>Assert: <var>i</var> is divisible by 4</li><li>Return the <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> that is referenced by the pair (<var>G</var>, <var>i</var>)
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="EnterCriticalSection" aoid="EnterCriticalSection">
      <h1><span class="secnum">8.1.9</span>EnterCriticalSection( <var>WL</var> )<span class="utils"><span class="anchor"><a href="#EnterCriticalSection">#</a></span></span></h1>
      <p> When EnterCriticalSection is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: The calling agent is not in the critical section for any <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref></li><li>Wait until no agent is in the critical section for <var>WL</var>, then enter the critical section for <var>WL</var> (without allowing any other agent to enter)
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="LeaveCriticalSection" aoid="LeaveCriticalSection">
      <h1><span class="secnum">8.1.10</span>LeaveCriticalSection( <var>WL</var> )<span class="utils"><span class="anchor"><a href="#LeaveCriticalSection">#</a></span></span></h1>
      <p> When LeaveCriticalSection is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var></li><li>Leave the critical section for <var>WL</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.AddWaiter" aoid="AddWaiter">
      <h1><span class="secnum">8.1.11</span>AddWaiter( <var>WL</var>, <var>W</var> )<span class="utils"><span class="anchor"><a href="#Atomics.AddWaiter">#</a></span></span></h1>
      <p> When AddWaiter is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var> and agent signifier <var>W</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var></li><li>Assert: <var>W</var> is not on the list of waiters in any <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref></li><li>Add <var>W</var> to the end of the list of waiters in <var>WL</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.RemoveWaiter" aoid="RemoveWaiter">
      <h1><span class="secnum">8.1.12</span>RemoveWaiter( <var>WL</var>, <var>W</var> )<span class="utils"><span class="anchor"><a href="#Atomics.RemoveWaiter">#</a></span></span></h1>
      <p> When RemoveWaiter is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var> and agent signifier <var>W</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var></li><li>Assert: <var>W</var> is on the list of waiters in <var>WL</var></li><li>Remove <var>W</var> from the list of waiters in <var>WL</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.RemoveWaiters" aoid="RemoveWaiters">
      <h1><span class="secnum">8.1.13</span>RemoveWaiters( <var>WL</var>, <var>c</var> )<span class="utils"><span class="anchor"><a href="#Atomics.RemoveWaiters">#</a></span></span></h1>
      <p> When RemoveWaiters is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var> and nonnegative integer <var>c</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var></li><li>Let <var>L</var> be the empty list</li><li>Let <var>S</var> be a reference to the list of waiters in <var>WL</var></li><li>While <var>c</var> &gt; 0 and <var>S</var> is not the empty list:<ol><li>Let <var>W</var> be the first waiter in <var>S</var></li><li>Add <var>W</var> to the end of <var>L</var></li><li>Remove <var>W</var> from <var>S</var></li><li>Subtract 1 from <var>c</var></li></ol></li><li>Return <var>L</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.Suspend" aoid="Suspend">
      <h1><span class="secnum">8.1.14</span>Suspend( <var>WL</var>, <var>W</var>, <var>timeout</var> )<span class="utils"><span class="anchor"><a href="#Atomics.Suspend">#</a></span></span></h1>
      <p> When Suspend is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var>, agent signifier <var>W</var>, and nonnegative number <var>timeout</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var></li><li>Assert: <var>W</var> is equal to <emu-xref aoid="AgentSignifier"><a href="#Atomics.AgentSignifier">AgentSignifier</a></emu-xref>()</li><li>Assert: <var>W</var> is on the list of waiters in <var>WL</var></li><li>Assert: <emu-xref aoid="AgentCanSuspend"><a href="#Atomics.AgentCanSuspend">AgentCanSuspend</a></emu-xref>() is equal to true</li><li>Call <emu-xref aoid="LeaveCriticalSection"><a href="#LeaveCriticalSection">LeaveCriticalSection</a></emu-xref>( <var>WL</var> ) and suspend <var>W</var> for up to <var>timeout</var> milliseconds, performing the combined operation in such a way that a wakeup that arrives after the critical section is exited but before the suspension takes effect is not lost.  <var>W</var> can wake up either because the timeout expired or because it was woken explicitly by another agent calling <emu-xref aoid="WakeWaiter"><a href="#Atomics.WakeWaiter">WakeWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>), and not for any other reasons at all.</li><li>Call <emu-xref aoid="EnterCriticalSection"><a href="#EnterCriticalSection">EnterCriticalSection</a></emu-xref>( <var>WL</var> )</li><li>If <var>W</var> was woken explicitly by another agent calling <emu-xref aoid="WakeWaiter"><a href="#Atomics.WakeWaiter">WakeWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>), then return <emu-val>true</emu-val></li><li>Return <emu-val>false</emu-val>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.WakeWaiter" aoid="WakeWaiter">
      <h1><span class="secnum">8.1.15</span>WakeWaiter( <var>WL</var>, <var>W</var> )<span class="utils"><span class="anchor"><a href="#Atomics.WakeWaiter">#</a></span></span></h1>
      <p> When WakeWaiter is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var> and agent signifier <var>W</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var></li><li>Assert: <var>W</var> is on the list of waiters in <var>WL</var></li><li>Wake the agent <var>W</var>
      </li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p> The embedding may delay waking <var>W</var>, eg for resource management reasons, but <var>W</var> must eventually be woken in order to guarantee forward progress.  </p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.FetchOp" aoid="AtomicFetchOp">
      <h1><span class="secnum">8.1.16</span>AtomicFetchOp( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>op</var> )<span class="utils"><span class="anchor"><a href="#Atomics.FetchOp">#</a></span></span></h1>
      <p> AtomicFetchOp is a semantic function that atomically loads
        a value, combines it with another value, and stores the result
        of the combination.  It returns the loaded value.  It is
        parameterized by the (pure) combining operation.  The following
        steps are taken:  </p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>buffer</var>)</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>i</var>)</li><li>Let <var>v</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>value</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>value</var>).</li><li>Let <var>arrayTypeName</var> be the value of <var>typedArray</var>'s [[TypedArrayName]] internal slot</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be the value of <var>typedArray</var>’s [[ByteOffset]] internal slot.</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var></li><li>With atomic access to shared memory, do:<ol><li>Let <var>r</var> be the result of <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var> )</li><li>Compute: Let <var>w</var> be <var>op</var>(<var>r</var>, <var>v</var>)</li><li>Call <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>w</var> )</li></ol></li><li>Return <var>r</var>
      </li></ol></emu-alg>
    </emu-clause>
  </emu-clause> <!-- runtime semantics -->

  <emu-clause id="AtomicsObjectFunctionProps">
    <h1><span class="secnum">8.2</span>Function Properties of the Atomics Object<span class="utils"><span class="anchor"><a href="#AtomicsObjectFunctionProps">#</a></span></span></h1>

    <emu-clause id="Atomics.add">
      <h1><span class="secnum">8.2.1</span>Atomics.add( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.add">#</a></span></span></h1>
      <p> Let <code>add</code> denote a semantic function of two number arguments that returns the sum of the arguments.  </p>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>result</var> be <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>( <var>typedArray</var>, <var>index</var>, <var>value</var>, <code>add</code> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>)</li><li>Return <var>result</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.and">
      <h1><span class="secnum">8.2.2</span>Atomics.and( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.and">#</a></span></span></h1>
      <p> Let <code>and</code> denote a semantic function of two number arguments that returns the bitwise "and" of the arguments.  </p>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>result</var> be <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>( <var>typedArray</var>, <var>index</var>, <var>value</var>, <code>and</code> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>)</li><li>Return <var>result</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.compareExchange">
      <h1><span class="secnum">8.2.3</span>Atomics.compareExchange( <var>typedArray</var>, <var>index</var>, <var>expectedValue</var>, <var>replacementValue</var> )<span class="utils"><span class="anchor"><a href="#Atomics.compareExchange">#</a></span></span></h1>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>buffer</var>)</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>i</var>)</li><li>Let <var>expected</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>expectedValue</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>expected</var>)</li><li>Let <var>replacement</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>replacedValue</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>replacement</var>)</li><li>Let <var>arrayTypeName</var> be the value of <var>typedArray</var>'s [[TypedArrayName]] internal slot</li><li>Let <var>convOp</var> be the conversion operation specified in Table 49 for <var>arrayTypeName</var></li><li>Let <var>x</var> be <var>convOp</var> ( <var>expected</var> )</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be the value of <var>typedArray</var>’s [[ByteOffset]] internal slot.</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var></li><li>With atomic access to shared memory, do:<ol><li>Let <var>r</var> be <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var> )</li><li>If <var>r</var> is the same as <var>x</var> then:<ol><li>Call <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>replacement</var> )</li></ol></li></ol></li><li>Return <var>r</var>
      </li></ol></emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.exchange">
      <h1><span class="secnum">8.2.4</span>Atomics.exchange( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.exchange">#</a></span></span></h1>
      <p> Let <code>second</code> denote a semantic function of two number arguments that returns its second argument.  </p>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>result</var> be <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>( <var>typedArray</var>, <var>index</var>, <var>value</var>, <code>second</code> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>)</li><li>Return <var>result</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.isLockFree">
      <h1><span class="secnum">8.2.5</span>Atomics.isLockFree( <var>size</var> )<span class="utils"><span class="anchor"><a href="#Atomics.isLockFree">#</a></span></span></h1>

      <emu-alg><ol><li>Let <var>n</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>size</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>n</var>)</li><li>If <var>n</var> equals 1 then return the value of the [[IsLockFree1]] property of the <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref> of the <em>surrounding agent</em>.</li><li>If <var>n</var> equals 2 then return the value of the [[IsLockFree2]] property of the <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref> of the <em>surrounding agent</em>.</li><li>If <var>n</var> equals 4 then return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>
      </li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p> Atomics.isLockFree() is an optimization primitive.  The
          intuition is that if the atomic step of an atomic primitive
          (<code>compareExchange</code>, <code>load</code>, <code>store</code>, <code>add</code>, <code>sub</code>, <code>and</code>,
          <code>or</code>, <code>xor</code>, or <code>exchange</code>) on a datum of size <var>n</var> bytes
          will be performed without the calling agent acquiring a lock
          outside the <var>n</var> bytes comprising the datum, then
          Atomics.isLockFree(<var>n</var>) will return <emu-val>true</emu-val>.
          High-performance algorithms will use Atomics.isLockFree to
          determine whether to use locks or atomic operations in
          critical sections.  If an atomic primitive is not lock-free
          then it is often more efficient for an algorithm to provide
          its own locking.  </p>

        <p> Atomics.isLockFree(4) always returns <emu-val>true</emu-val> as that can be
          supported on all known relevant hardware.  Being able to
          assume this will generally simplify programs.  </p>

      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.load">
      <h1><span class="secnum">8.2.6</span>Atomics.load( <var>typedArray</var>, <var>index</var> )<span class="utils"><span class="anchor"><a href="#Atomics.load">#</a></span></span></h1>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>buffer</var>)</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>i</var>)</li><li>Let <var>arrayTypeName</var> be the value of <var>typedArray</var>'s [[TypedArrayName]] internal slot</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be the value of <var>typedArray</var>’s [[ByteOffset]] internal slot.</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var></li><li>With atomic access to shared memory, do:<ol><li>Let <var>r</var> be the result of <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var> )</li></ol></li><li>Return <var>r</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.or">
      <h1><span class="secnum">8.2.7</span>Atomics.or( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.or">#</a></span></span></h1>
      <p> Let <code>or</code> denote a semantic function of two number arguments that returns the bitwise "or" of the arguments.  </p>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>result</var> be <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>( <var>typedArray</var>, <var>index</var>, <var>value</var>, <code>or</code> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>)</li><li>Return <var>result</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.store">
      <h1><span class="secnum">8.2.8</span>Atomics.store( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.store">#</a></span></span></h1>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>buffer</var>)</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>i</var>)</li><li>Let <var>v</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>value</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>v</var>)</li><li>Let <var>arrayTypeName</var> be the value of <var>typedArray</var>'s [[TypedArrayName]] internal slot</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be the value of <var>typedArray</var>’s [[ByteOffset]] internal slot.</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var></li><li>With atomic access to shared memory, do:<ol><li>Call <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>v</var> )</li></ol></li><li>Return <var>v</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.sub">
      <h1><span class="secnum">8.2.9</span>Atomics.sub( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.sub">#</a></span></span></h1>
      <p> Let <code>subtract</code> denote a semantic function of two number arguments that returns the difference of the arguments.  </p>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>result</var> be <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>( <var>typedArray</var>, <var>index</var>, <var>value</var>, <code>subtract</code> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>)</li><li>Return <var>result</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.wait">
      <h1><span class="secnum">8.2.10</span>Atomics.wait( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )<span class="utils"><span class="anchor"><a href="#Atomics.wait">#</a></span></span></h1>
      <p> Atomics.wait puts the calling agent in a wait queue and puts it to sleep until it is awoken or the sleep times out. The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>, <emu-val>true</emu-val>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>buffer</var>)</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>i</var>)</li><li>Let <var>v</var> be the result of <emu-xref aoid="ToInt32"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref>(<var>value</var>).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>v</var>)</li><li>If <var>timeout</var> is not provided or is <emu-val>undefined</emu-val> then let <var>t</var> be <emu-val>+∞</emu-val>.  Otherwise:<ol><li>Let <var>q</var> be the result of <emu-xref aoid="ToNumber"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>timeout</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>q</var>)</li><li>If <var>q</var> is <emu-val>NaN</emu-val> then let <var>t</var> be <emu-val>+∞</emu-val>, otherwise let <var>t</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(0, <var>q</var>).</li></ol></li><li>Let <var>B</var> be <emu-xref aoid="AgentCanSuspend"><a href="#Atomics.AgentCanSuspend">AgentCanSuspend</a></emu-xref>()</li><li>If <var>B</var> is <emu-val>false</emu-val> then throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>bufferVal</var> be the value of the internal [[SharedArrayBufferData]] property of <var>buffer</var>.</li><li>Let <var>G</var> be <emu-xref aoid="SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">SharedDataBlockID</a></emu-xref>(<var>bufferVal</var>)</li><li>Let <var>arrayTypeName</var> be the value of <var>typedArray</var>'s [[TypedArrayName]] internal slot</li><li>Let <var>offset</var> be the value of <var>typedArray</var>'s [[ByteOffset]] internal slot.</li><li>Let <var>indexedPosition</var> be (<var>i</var> × 4) + <var>offset</var></li><li>Let <var>WL</var> be <emu-xref aoid="GetWaiterList"><a href="#GetWaiterList">GetWaiterList</a></emu-xref>(<var>G</var>, <var>indexedPosition</var>)</li><li>Call <emu-xref aoid="EnterCriticalSection"><a href="#EnterCriticalSection">EnterCriticalSection</a></emu-xref>(<var>WL</var>)</li><li>Let <var>w</var> be Atomics.load(<var>typedArray</var>, <var>i</var>)</li><li>If <var>v</var> does not equal <var>w</var> then:<ol><li>Call <emu-xref aoid="LeaveCriticalSection"><a href="#LeaveCriticalSection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>)</li><li>Return the string <code>"not-equal"</code>.</li></ol></li><li>Let <var>W</var> be <emu-xref aoid="AgentSignifier"><a href="#Atomics.AgentSignifier">AgentSignifier</a></emu-xref>().</li><li>Call <emu-xref aoid="AddWaiter"><a href="#Atomics.AddWaiter">AddWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>)</li><li>Let awoken be <emu-xref aoid="Suspend"><a href="#Atomics.Suspend">Suspend</a></emu-xref>(<var>WL</var>, <var>W</var>, <var>t</var>)</li><li>Call <emu-xref aoid="RemoveWaiter"><a href="#Atomics.RemoveWaiter">RemoveWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>)</li><li>Call <emu-xref aoid="LeaveCriticalSection"><a href="#LeaveCriticalSection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>)</li><li>If awoken is <emu-val>true</emu-val> then return the string <code>"ok"</code>.</li><li>Return the string <code>"timed-out"</code>.
      </li></ol></emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.wake">
      <h1><span class="secnum">8.2.11</span>Atomics.wake( <var>typedArray</var>, <var>index</var>, <var>count</var> )<span class="utils"><span class="anchor"><a href="#Atomics.wake">#</a></span></span></h1>
      <p> Atomics.wake wakes up some agents that are sleeping in the wait queue.  The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>( <var>typedArray</var>, <emu-val>true</emu-val> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>( <var>buffer</var> )</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>( <var>i</var> )</li><li>If <var>count</var> is not provided or is <emu-val>undefined</emu-val> then let <var>c</var> be <emu-val>+∞</emu-val>.  Otherwise:<ol><li>Let <var>tmp</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>( <var>count</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>( <var>tmp</var> )</li><li>Let <var>c</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>( <emu-val>+0</emu-val>, <var>tmp</var> ).</li></ol></li><li>Let <var>bufferVal</var> be the value of the internal [[SharedArrayBufferData]] property of <var>buffer</var>.</li><li>Let <var>G</var> be <emu-xref aoid="SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">SharedDataBlockID</a></emu-xref>( <var>bufferVal</var> )</li><li>Let <var>arrayTypeName</var> be the value of <var>typedArray</var>'s [[TypedArrayName]] internal slot</li><li>Let <var>offset</var> be the value of <var>typedArray</var>'s [[ByteOffset]] internal slot.</li><li>Let <var>indexedPosition</var> be (<var>i</var> × 4) + <var>offset</var></li><li>Let <var>WL</var> be <emu-xref aoid="GetWaiterList"><a href="#GetWaiterList">GetWaiterList</a></emu-xref>(<var>G</var>, <var>indexedPosition</var>)</li><li>Let <var>n</var> be 0</li><li>Call <emu-xref aoid="EnterCriticalSection"><a href="#EnterCriticalSection">EnterCriticalSection</a></emu-xref>(<var>WL</var>):</li><li>Let <var>S</var> be <emu-xref aoid="RemoveWaiters"><a href="#Atomics.RemoveWaiters">RemoveWaiters</a></emu-xref>( <var>WL</var>, <var>c</var> )</li><li>While <var>S</var> is not the empty list:<ol><li>Let <var>W</var> be the first agent in <var>S</var></li><li>Remove <var>W</var> from the front of <var>S</var></li><li>Call <emu-xref aoid="WakeWaiter"><a href="#Atomics.WakeWaiter">WakeWaiter</a></emu-xref>( <var>WL</var>, <var>W</var> )</li><li>Add 1 to <var>n</var></li></ol></li><li>Call <emu-xref aoid="LeaveCriticalSection"><a href="#LeaveCriticalSection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>)</li><li>Return <var>n</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.xor">
      <h1><span class="secnum">8.2.12</span>Atomics.xor( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.xor">#</a></span></span></h1>
      <p> Let <code>xor</code> denote a semantic function of two number arguments that returns the bitwise "xor" of the arguments.  </p>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>result</var> be <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>( <var>typedArray</var>, <var>index</var>, <var>value</var>, <code>xor</code> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>)</li><li>Return <var>result</var>
      </li></ol></emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="WebBrowserEmbedding">
  <h1><span class="secnum">9</span>Web browser embedding (informative)<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding">#</a></span></span></h1>

  <p> This section outlines how the Shared Memory and Atomics
    specification fits into the current web ecosystem with the minimum
    amount of change to that ecosystem.  This section is not part of
    the proposal, it is informative only.    </p>

  <p> In a web browser an  <em>agent</em> is an HTML  <em>event
    loop</em> <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">[here]</a>.
    The event loop is realized as either a main thread (which may be
    shared among tabs, as it is in Firefox) or some type of worker
    thread.  The event loops are running jobs in the sense of ES262,
    and the forward-progress requirement of this specification
    (section&nbsp;3.1.1) is generally met as long as each agent has
    its own dedicated operating system thread or shared-thread agents
    can't block.  </p>

  <p> Browsers will typically let agents that run on the browser's
    main thread have [[CanBlock]] equal to <emu-val>false</emu-val>, to prevent blocking the
    UI and to allow the main thread to do work on behalf of other
    threads.  </p>

  <p> Normal ("dedicated") <code>Worker</code>s must be supported as agents for
    this proposal to make much sense.  </p>

  <p> Memory will be shared among agents by using <code>postMessage</code> to
    transmit SharedArrayBuffer objects or TypedArray objects that
    have SharedArrayBuffer buffers; this requires an extension to
    the Structured Clone mechanism.  There is agreement on the general
    syntax and semantics for that extension.  </p>

  <p> Agent-to-agent communication extends the synchronizes-with relation
    of the program, as follows:</p>

  <ul>
    <li> The call to the <code>Worker</code> constructor in the parent
      synchronizes-with the execution of the main script in the worker. 

    </li><li> (Worker termination is not directly observable in current
      browsers, but this is a moot point; see below.) 

    </li><li> A <code>postMessage</code> to another agent synchronizes-with the event
      that fires in the agent.
  
  </li></ul>

  <p> So long as the browser does not allow a <code>ServiceWorker</code> or
    <code>SharedWorker</code> ("non-page worker") to share memory with a <code>Worker</code>
    it will not violate the suspend/wake cohort rule of this
    specification (section&nbsp;3.3).  The restriction on sharing
    memory can be implemented in the extension to the Structured Clone
    mechanism.  For example, a non-page worker may simply not be
    allowed to receive shared memory (leading to a null value or an
    error signal).  There is not yet any agreement on this point, but
    it is clear that the restriction must be on the receiving side of
    the communication, as the sender may be sending on a <code>MessagePort</code>
    that is not yet connected, but may in the future be connected to
    either a valid or invalid recipient.  </p>

  <p> At the moment, I believe dedicated workers are in the same
    process as their owning tab in all browsers, so if the process
    crashes then the workers will crash too.  I also don't know any
    reason a browser should forcibly terminate a worker except when a
    tab is closed.  In sum, the termination signaling requirement of
    this specification (section&nbsp;3.3) is probably met by existing
    browsers.  </p>

  <p> The web platform should evolve to serve the shared memory use
    case better: by incorporating inspectable worker state and worker
    lifecycle events, and by tightening the wording in the HTML spec
    (currently the browser is allowed to kill a worker at any time for
    any reason, which is not quite what we want).  WebIDL should
    evolve to allow Web APIs to be described as to when they can and
    cannot receive shared memory parameters.  However, only an
    extension to the Structured Clone algorithm is needed to support
    the Shared Memory and Atomics specification in practice on current
    browsers.  </p>

</emu-clause>
</body>
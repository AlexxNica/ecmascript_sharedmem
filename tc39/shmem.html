<!doctype html>
<head><meta charset="utf-8">
<title>ECMAScript Shared Memory and Atomics</title>
<script src="https://bterlson.github.io/ecmarkup/ecmarkup.js"></script>
<link rel="stylesheet" href="https://bterlson.github.io/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">

<script type="application/json" id="menu-search-biblio">[{"type":"clause","id":"intro","aoid":null,"title":"Introduction","number":"","namespace":"<no location>","location":"","key":"Introduction"},{"type":"clause","id":"Overview","aoid":null,"title":"Overview (ES6 4)","number":"1","namespace":"<no location>","location":"","key":"Overview (ES6 4)"},{"type":"clause","id":"Overview.Overview","aoid":null,"title":"ECMAScript Overview (ES6 4.2)","number":"1.1","namespace":"<no location>","location":"","key":"ECMAScript Overview (ES6 4.2)"},{"type":"clause","id":"DataTypesValues","aoid":null,"title":"ECMAScript Data Types and Values (ES6 6)","number":"2","namespace":"<no location>","location":"","key":"ECMAScript Data Types and Values (ES6 6)"},{"type":"clause","id":"DataTypesValues.LanguageTypes","aoid":null,"title":"ECMAScript Language Types (ES6 6.1)","number":"2.1","namespace":"<no location>","location":"","key":"ECMAScript Language Types (ES6 6.1)"},{"type":"clause","id":"DataTypesValues.LanguageTypes.Number","aoid":null,"title":"The Number Type (ES6 6.1.6)","number":"2.1.1","namespace":"<no location>","location":"","key":"The Number Type (ES6 6.1.6)"},{"type":"clause","id":"DataTypesValues.LanguageTypes.Object","aoid":null,"title":"The Object Type (ES6 6.1.7)","number":"2.1.2","namespace":"<no location>","location":"","key":"The Object Type (ES6 6.1.7)"},{"type":"clause","id":"DataTypesValues.LanguageTypes.Object.Intrinsic","aoid":null,"title":"Well-Known Intrinsic Objects (ES6 6.1.7.4)","number":"2.1.2.1","namespace":"<no location>","location":"","key":"Well-Known Intrinsic Objects (ES6 6.1.7.4)"},{"type":"clause","id":"DataTypesValues.SpecTypes","aoid":null,"title":"ECMAScript Specification Types (ES6 6.2)","number":"2.2","namespace":"<no location>","location":"","key":"ECMAScript Specification Types (ES6 6.2)"},{"type":"clause","id":"DataTypesValues.SpecTypes.DataBlocks","aoid":null,"title":"Data blocks (ES6 6.2.6)","number":"2.2.1","namespace":"<no location>","location":"","key":"Data blocks (ES6 6.2.6)"},{"type":"clause","id":"DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes","aoid":null,"title":"CopyDataBlockBytes (_toBlock_, _toIndex_, _fromBlock_, _fromIndex_, _count_) (ES6 6.2.6.2)","number":"2.2.1.1","namespace":"<no location>","location":"","key":"CopyDataBlockBytes (_toBlock_, _toIndex_, _fromBlock_, _fromIndex_, _count_) (ES6 6.2.6.2)"},{"type":"clause","id":"DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock","aoid":null,"title":"CreateSharedByteDataBlock( size )","number":"2.2.1.2","namespace":"<no location>","location":"","key":"CreateSharedByteDataBlock( size )"},{"type":"op","aoid":"SharedDataBlockID","refId":"DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID","location":"","key":"SharedDataBlockID"},{"type":"clause","id":"DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID","aoid":"SharedDataBlockID","title":"SharedDataBlockID( block )","number":"2.2.1.3","namespace":"<no location>","location":"","key":"SharedDataBlockID( block )"},{"type":"clause","id":"ExecutableCodeAndContexts","aoid":null,"title":"Executable Code and Execution Contexts (ES6 8)","number":"3","namespace":"<no location>","location":"","key":"Executable Code and Execution Contexts (ES6 8)"},{"type":"clause","id":"ExecutableCodeAndContexts.JobsAndJobQueues","aoid":null,"title":"Jobs and Job Queues (ES6 8.4)","number":"3.1","namespace":"<no location>","location":"","key":"Jobs and Job Queues (ES6 8.4)"},{"type":"clause","id":"ExecutableCodeAndContexts.JobsAndJobQueues.Progress","aoid":null,"title":"Forward Progress Guarantees","number":"3.1.1","namespace":"<no location>","location":"","key":"Forward Progress Guarantees"},{"type":"clause","id":"ExecutableCodeAndContexts.AgentCluster","aoid":null,"title":"Agents (AMENDMENTS)","number":"3.2","namespace":"<no location>","location":"","key":"Agents (AMENDMENTS)"},{"type":"clause","id":"ExecutableCodeAndContexts.AgentCluster","aoid":null,"title":"Agent Clusters (NEW)","number":"3.3","namespace":"<no location>","location":"","key":"Agent Clusters (NEW)"},{"type":"clause","id":"GlobalObject","aoid":null,"title":"The Global Object (ES6 18)","number":"4","namespace":"<no location>","location":"","key":"The Global Object (ES6 18)"},{"type":"clause","id":"GlobalObject.ConstructorProps","aoid":null,"title":"Constructor Properties of the Global Object (ES6 18.3)","number":"4.1","namespace":"<no location>","location":"","key":"Constructor Properties of the Global Object (ES6 18.3)"},{"type":"clause","id":"GlobalObject.ConstructorProps.SharedArrayBuffer","aoid":null,"title":"SharedArrayBuffer","number":"4.1.1","namespace":"<no location>","location":"","key":"SharedArrayBuffer"},{"type":"clause","id":"GlobalObject.ConstructorProps.Atomics","aoid":null,"title":"Atomics","number":"4.1.2","namespace":"<no location>","location":"","key":"Atomics"},{"type":"clause","id":"IndexedCollections","aoid":null,"title":"Indexed Collections (ES6 22)","number":"5","namespace":"<no location>","location":"","key":"Indexed Collections (ES6 22)"},{"type":"clause","id":"IndexedCollections.TypedArray","aoid":null,"title":"TypedArray Objects (ES6 22.2)","number":"5.1","namespace":"<no location>","location":"","key":"TypedArray Objects (ES6 22.2)"},{"type":"clause","id":"IndexedCollections.TypedArray.intrinsic","aoid":null,"title":"The %TypedArray% intrinsic object (ES6 22.2.1)","number":"5.1.1","namespace":"<no location>","location":"","key":"The %TypedArray% intrinsic object (ES6 22.2.1)"},{"type":"clause","id":"IndexedCollections.TypedArray.intrinsic.constructFromObject","aoid":null,"title":"%TypedArray%( object ) (ES6 22.2.1.4)","number":"5.1.1.1","namespace":"<no location>","location":"","key":"%TypedArray%( object ) (ES6 22.2.1.4)"},{"type":"clause","id":"IndexedCollections.TypedArray.intrinsic.constructFromBuffer","aoid":null,"title":"%TypedArray%( buffer [ , byteOffset [ , length ] ] ) (ES6 22.2.1.5)","number":"5.1.1.2","namespace":"<no location>","location":"","key":"%TypedArray%( buffer [ , byteOffset [ , length ] ] ) (ES6 22.2.1.5)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype","aoid":null,"title":"Properties of the %TypedArrayPrototype% object (ES6 22.2.3)","number":"5.1.2","namespace":"<no location>","location":"","key":"Properties of the %TypedArrayPrototype% object (ES6 22.2.3)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype.set","aoid":null,"title":" %TypedArray%.prototype.set( overloaded [ , offset ] ) (ES6 22.2.3.22)","number":"5.1.2.1","namespace":"<no location>","location":"","key":" %TypedArray%.prototype.set( overloaded [ , offset ] ) (ES6 22.2.3.22)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype.setFromTypedArray","aoid":null,"title":"%TypedArray%.prototype.set( typedArray [, offset ] ) (ES6 22.2.3.22.2)","number":"5.1.2.1.1","namespace":"<no location>","location":"","key":"%TypedArray%.prototype.set( typedArray [, offset ] ) (ES6 22.2.3.22.2)"},{"type":"clause","id":"StructuredData","aoid":null,"title":"Structured Data (ES6 24)","number":"6","namespace":"<no location>","location":"","key":"Structured Data (ES6 24)"},{"type":"clause","id":"StructuredData.ArrayBuffer","aoid":null,"title":"ArrayBuffer Objects (ES6 24.1)","number":"6.1","namespace":"<no location>","location":"","key":"ArrayBuffer Objects (ES6 24.1)"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract","aoid":null,"title":"Abstract Operations for ArrayBuffer (ES6 24.1.1)","number":"6.1.1","namespace":"<no location>","location":"","key":"Abstract Operations for ArrayBuffer (ES6 24.1.1)"},{"type":"op","aoid":"IsDetachedBuffer","refId":"StructuredData.ArrayBuffer.abstract.IsDetachedBuffer","location":"","key":"IsDetachedBuffer"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract.IsDetachedBuffer","aoid":"IsDetachedBuffer","title":"IsDetachedBuffer( arrayBuffer ) (ES6 24.1.1.2)","number":"6.1.1.1","namespace":"<no location>","location":"","key":"IsDetachedBuffer( arrayBuffer ) (ES6 24.1.1.2)"},{"type":"op","aoid":"CloneArrayBuffer","refId":"StructuredData.ArrayBuffer.abstract.CloneArrayBuffer","location":"","key":"CloneArrayBuffer"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract.CloneArrayBuffer","aoid":"CloneArrayBuffer","title":"CloneArrayBuffer( srcBuffer, srcByteOffset [, cloneConstructor] ) (ES6 24.1.1.4)","number":"6.1.1.2","namespace":"<no location>","location":"","key":"CloneArrayBuffer( srcBuffer, srcByteOffset [, cloneConstructor] ) (ES6 24.1.1.4)"},{"type":"op","aoid":"GetValueFromBuffer","refId":"StructuredData.ArrayBuffer.abstract.GetValueFromBuffer","location":"","key":"GetValueFromBuffer"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract.GetValueFromBuffer","aoid":"GetValueFromBuffer","title":"GetValueFromBuffer( arrayBuffer, byteIndex, type, isLittleEndian ) (ES6 24.1.1.5)","number":"6.1.1.3","namespace":"<no location>","location":"","key":"GetValueFromBuffer( arrayBuffer, byteIndex, type, isLittleEndian ) (ES6 24.1.1.5)"},{"type":"op","aoid":"SetValueInBuffer","refId":"StructuredData.ArrayBuffer.abstract.SetValueInBuffer","location":"","key":"SetValueInBuffer"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract.SetValueInBuffer","aoid":"SetValueInBuffer","title":"SetValueInBuffer( arrayBuffer, byteIndex, type, value, isLittleEndian ) (ES6 24.1.1.6)","number":"6.1.1.4","namespace":"<no location>","location":"","key":"SetValueInBuffer( arrayBuffer, byteIndex, type, value, isLittleEndian ) (ES6 24.1.1.6)"},{"type":"clause","id":"StructuredData.DataView","aoid":null,"title":"DataView Objects (ES6 24.2)","number":"6.2","namespace":"<no location>","location":"","key":"DataView Objects (ES6 24.2)"},{"type":"clause","id":"StructuredData.DataView.constructor","aoid":null,"title":"The DataView Constructor (ES6 24.2.2)","number":"6.2.1","namespace":"<no location>","location":"","key":"The DataView Constructor (ES6 24.2.2)"},{"type":"clause","id":"StructuredData.DataView.constructor.detail","aoid":null,"title":"DataView( buffer [ , byteOffset [ , byteLength ] ] ) (ES6 24.2.2.1)","number":"6.2.1.1","namespace":"<no location>","location":"","key":"DataView( buffer [ , byteOffset [ , byteLength ] ] ) (ES6 24.2.2.1)"},{"type":"clause","id":"StructuredData.SharedArrayBuffer","aoid":null,"title":"SharedArrayBuffer Objects","number":"6.3","namespace":"<no location>","location":"","key":"SharedArrayBuffer Objects"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.abstract","aoid":null,"title":"Abstract Operations for SharedArrayBuffer","number":"6.3.1","namespace":"<no location>","location":"","key":"Abstract Operations for SharedArrayBuffer"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer","aoid":null,"title":"AllocateSharedArrayBuffer( constructor, byteLength )","number":"6.3.1.1","namespace":"<no location>","location":"","key":"AllocateSharedArrayBuffer( constructor, byteLength )"},{"type":"op","aoid":"IsSharedMemory","refId":"StructuredData.SharedArrayBuffer.abstract.IsSharedMemory","location":"","key":"IsSharedMemory"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.abstract.IsSharedMemory","aoid":"IsSharedMemory","title":"IsSharedMemory( obj )","number":"6.3.1.2","namespace":"<no location>","location":"","key":"IsSharedMemory( obj )"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor","aoid":null,"title":"The SharedArrayBuffer Constructor","number":"6.3.2","namespace":"<no location>","location":"","key":"The SharedArrayBuffer Constructor"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor.withLength","aoid":null,"title":"SharedArrayBuffer( length )","number":"6.3.2.1","namespace":"<no location>","location":"","key":"SharedArrayBuffer( length )"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor.properties","aoid":null,"title":"Properties of the SharedArrayBuffer constructor","number":"6.3.3","namespace":"<no location>","location":"","key":"Properties of the SharedArrayBuffer constructor"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor.properties.prototype","aoid":null,"title":"SharedArrayBuffer.prototype","number":"6.3.3.1","namespace":"<no location>","location":"","key":"SharedArrayBuffer.prototype"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor.properties.get_species","aoid":null,"title":"get SharedArrayBuffer [ @@species ]","number":"6.3.3.2","namespace":"<no location>","location":"","key":"get SharedArrayBuffer [ @@species ]"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype","aoid":null,"title":"Properties of the SharedArrayBuffer prototype object","number":"6.3.4","namespace":"<no location>","location":"","key":"Properties of the SharedArrayBuffer prototype object"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype.get_byteLength","aoid":null,"title":"get SharedArrayBuffer.prototype.byteLength","number":"6.3.4.1","namespace":"<no location>","location":"","key":"get SharedArrayBuffer.prototype.byteLength"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype.constructor","aoid":null,"title":"SharedArrayBuffer.prototype.constructor","number":"6.3.4.2","namespace":"<no location>","location":"","key":"SharedArrayBuffer.prototype.constructor"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype.slice","aoid":null,"title":"SharedArrayBuffer.prototype.slice( start, end )","number":"6.3.4.3","namespace":"<no location>","location":"","key":"SharedArrayBuffer.prototype.slice( start, end )"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype.toString","aoid":null,"title":"SharedArrayBuffer.prototype[ @@toStringTag ]","number":"6.3.4.4","namespace":"<no location>","location":"","key":"SharedArrayBuffer.prototype[ @@toStringTag ]"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.instances","aoid":null,"title":"Properties of the SharedArrayBuffer instances","number":"6.3.5","namespace":"<no location>","location":"","key":"Properties of the SharedArrayBuffer instances"},{"type":"clause","id":"AtomicsObject","aoid":null,"title":"The Atomics Object","number":"7","namespace":"<no location>","location":"","key":"The Atomics Object"},{"type":"clause","id":"AtomicsObjectFunctionProps.semantics","aoid":null,"title":"Runtime semantics","number":"7.1","namespace":"<no location>","location":"","key":"Runtime semantics"},{"type":"clause","id":"Atomics.WithAtomicAccessTo","aoid":null,"title":"With atomic access to shared memory","number":"7.1.1","namespace":"<no location>","location":"","key":"With atomic access to shared memory"},{"type":"op","aoid":"ValidateSharedIntegerTypedArray","refId":"Atomics.ValidateSharedIntegerTypedArray","location":"","key":"ValidateSharedIntegerTypedArray"},{"type":"clause","id":"Atomics.ValidateSharedIntegerTypedArray","aoid":"ValidateSharedIntegerTypedArray","title":"Runtime semantics: ValidateSharedIntegerTypedArray( typedArray [, onlyInt32] )","number":"7.1.2","namespace":"<no location>","location":"","key":"Runtime semantics: ValidateSharedIntegerTypedArray( typedArray [, onlyInt32] )"},{"type":"op","aoid":"ValidateAtomicAccess","refId":"Atomics.ValidateAtomicAccess","location":"","key":"ValidateAtomicAccess"},{"type":"clause","id":"Atomics.ValidateAtomicAccess","aoid":"ValidateAtomicAccess","title":"Runtime semantics: ValidateAtomicAccess( typedArray, requestIndex )","number":"7.1.3","namespace":"<no location>","location":"","key":"Runtime semantics: ValidateAtomicAccess( typedArray, requestIndex )"},{"type":"clause","id":"WithinTheWaitWakeCriticalSection","aoid":null,"title":"Within the wait/wake critical section ...","number":"7.1.4","namespace":"<no location>","location":"","key":"Within the wait/wake critical section ..."},{"type":"op","aoid":"AgentSignifier","refId":"Atomics.AgentSignifier","location":"","key":"AgentSignifier"},{"type":"clause","id":"Atomics.AgentSignifier","aoid":"AgentSignifier","title":"Runtime semantics: AgentSignifier( )","number":"7.1.5","namespace":"<no location>","location":"","key":"Runtime semantics: AgentSignifier( )"},{"type":"op","aoid":"AgentCanSuspend","refId":"Atomics.AgentCanSuspend","location":"","key":"AgentCanSuspend"},{"type":"clause","id":"Atomics.AgentCanSuspend","aoid":"AgentCanSuspend","title":"Runtime semantics: AgentCanSuspend( )","number":"7.1.6","namespace":"<no location>","location":"","key":"Runtime semantics: AgentCanSuspend( )"},{"type":"op","aoid":"AddWaiter","refId":"Atomics.AddWaiter","location":"","key":"AddWaiter"},{"type":"clause","id":"Atomics.AddWaiter","aoid":"AddWaiter","title":"Runtime semantics: AddWaiter( W, G, i )","number":"7.1.7","namespace":"<no location>","location":"","key":"Runtime semantics: AddWaiter( W, G, i )"},{"type":"op","aoid":"RemoveWaiter","refId":"Atomics.RemoveWaiter","location":"","key":"RemoveWaiter"},{"type":"clause","id":"Atomics.RemoveWaiter","aoid":"RemoveWaiter","title":"Runtime semantics: RemoveWaiter( W, G, i )","number":"7.1.8","namespace":"<no location>","location":"","key":"Runtime semantics: RemoveWaiter( W, G, i )"},{"type":"op","aoid":"RemoveWaiters","refId":"Atomics.RemoveWaiters","location":"","key":"RemoveWaiters"},{"type":"clause","id":"Atomics.RemoveWaiters","aoid":"RemoveWaiters","title":"Runtime semantics: RemoveWaiters( G, i, c )","number":"7.1.9","namespace":"<no location>","location":"","key":"Runtime semantics: RemoveWaiters( G, i, c )"},{"type":"op","aoid":"Suspend","refId":"Atomics.Suspend","location":"","key":"Suspend"},{"type":"clause","id":"Atomics.Suspend","aoid":"Suspend","title":"Runtime semantics: Suspend( W, timeout )","number":"7.1.10","namespace":"<no location>","location":"","key":"Runtime semantics: Suspend( W, timeout )"},{"type":"op","aoid":"WakeWaiter","refId":"Atomics.WakeWaiter","location":"","key":"WakeWaiter"},{"type":"clause","id":"Atomics.WakeWaiter","aoid":"WakeWaiter","title":"Runtime semantics: WakeWaiter( W )","number":"7.1.11","namespace":"<no location>","location":"","key":"Runtime semantics: WakeWaiter( W )"},{"type":"op","aoid":"AtomicFetchOp","refId":"Atomics.FetchOp","location":"","key":"AtomicFetchOp"},{"type":"clause","id":"Atomics.FetchOp","aoid":"AtomicFetchOp","title":"Runtime semantics: AtomicFetchOp( typedArray, index, value, op )","number":"7.1.12","namespace":"<no location>","location":"","key":"Runtime semantics: AtomicFetchOp( typedArray, index, value, op )"},{"type":"clause","id":"AtomicsObjectFunctionProps","aoid":null,"title":"Function Properties of the Atomics Object","number":"7.2","namespace":"<no location>","location":"","key":"Function Properties of the Atomics Object"},{"type":"clause","id":"Atomics.add","aoid":null,"title":"Atomics.add( typedArray, index, value )","number":"7.2.1","namespace":"<no location>","location":"","key":"Atomics.add( typedArray, index, value )"},{"type":"clause","id":"Atomics.and","aoid":null,"title":"Atomics.and( typedArray, index, value )","number":"7.2.2","namespace":"<no location>","location":"","key":"Atomics.and( typedArray, index, value )"},{"type":"clause","id":"Atomics.compareExchange","aoid":null,"title":"Atomics.compareExchange( typedArray, index, expectedValue, replacementValue )","number":"7.2.3","namespace":"<no location>","location":"","key":"Atomics.compareExchange( typedArray, index, expectedValue, replacementValue )"},{"type":"clause","id":"Atomics.exchange","aoid":null,"title":"Atomics.exchange( typedArray, index, value )","number":"7.2.4","namespace":"<no location>","location":"","key":"Atomics.exchange( typedArray, index, value )"},{"type":"clause","id":"Atomics.wait","aoid":null,"title":"Atomics.wait( typedArray, index, value, timeout )","number":"7.2.5","namespace":"<no location>","location":"","key":"Atomics.wait( typedArray, index, value, timeout )"},{"type":"clause","id":"Atomics.wake","aoid":null,"title":"Atomics.wake( typedArray, index, count )","number":"7.2.6","namespace":"<no location>","location":"","key":"Atomics.wake( typedArray, index, count )"},{"type":"clause","id":"Atomics.isLockFree","aoid":null,"title":"Atomics.isLockFree( size )","number":"7.2.7","namespace":"<no location>","location":"","key":"Atomics.isLockFree( size )"},{"type":"clause","id":"Atomics.load","aoid":null,"title":"Atomics.load( typedArray, index )","number":"7.2.8","namespace":"<no location>","location":"","key":"Atomics.load( typedArray, index )"},{"type":"clause","id":"Atomics.or","aoid":null,"title":"Atomics.or( typedArray, index, value )","number":"7.2.9","namespace":"<no location>","location":"","key":"Atomics.or( typedArray, index, value )"},{"type":"clause","id":"Atomics.store","aoid":null,"title":"Atomics.store( typedArray, index, value )","number":"7.2.10","namespace":"<no location>","location":"","key":"Atomics.store( typedArray, index, value )"},{"type":"clause","id":"Atomics.sub","aoid":null,"title":"Atomics.sub( typedArray, index, value )","number":"7.2.11","namespace":"<no location>","location":"","key":"Atomics.sub( typedArray, index, value )"},{"type":"clause","id":"Atomics.xor","aoid":null,"title":"Atomics.xor( typedArray, index, value )","number":"7.2.12","namespace":"<no location>","location":"","key":"Atomics.xor( typedArray, index, value )"},{"type":"clause","id":"WebBrowserEmbedding","aoid":null,"title":"Web browser embedding (informative)","number":"8","namespace":"<no location>","location":"","key":"Web browser embedding (informative)"},{"type":"clause","id":"WebBrowserEmbedding.Agents","aoid":null,"title":"Agent mapping","number":"8.1","namespace":"<no location>","location":"","key":"Agent mapping"},{"type":"clause","id":"WebBrowserEmbedding.MemoryModel","aoid":null,"title":"Agent communication semantics","number":"8.2","namespace":"<no location>","location":"","key":"Agent communication semantics"},{"type":"clause","id":"WebBrowserEmbedding.DOM","aoid":null,"title":"DOM, browser APIs, WebIDL","number":"8.3","namespace":"<no location>","location":"","key":"DOM, browser APIs, WebIDL"},{"type":"clause","id":"WebBrowserEmbedding.CloneAndTransfer","aoid":null,"title":"Transmitting and Cloning SharedArrayBuffers and Views","number":"8.4","namespace":"<no location>","location":"","key":"Transmitting and Cloning SharedArrayBuffers and Views"},{"type":"clause","id":"WebBrowserEmbedding.WorkerSemantics","aoid":null,"title":"Clarifications and changes to Web Worker semantics","number":"8.5","namespace":"<no location>","location":"","key":"Clarifications and changes to Web Worker semantics"},{"type":"clause","id":"WebBrowserEmbedding.WorkerSemantics.Start","aoid":null,"title":"Actions to start a worker","number":"8.5.1","namespace":"<no location>","location":"","key":"Actions to start a worker"},{"type":"clause","id":"WebBrowserEmbedding.WorkerSemantics.Jobs","aoid":null,"title":"Workers are agents","number":"8.5.2","namespace":"<no location>","location":"","key":"Workers are agents"},{"type":"clause","id":"WebBrowserEmbedding.WorkerSemantics.LicenseToKill","aoid":null,"title":"Curtail the license to kill","number":"8.5.3","namespace":"<no location>","location":"","key":"Curtail the license to kill"},{"type":"clause","id":"WebBrowserEmbedding.WorkerSemantics.Introspection","aoid":null,"title":"Termination detection","number":"8.5.4","namespace":"<no location>","location":"","key":"Termination detection"},{"type":"clause","id":"WebBrowserEmbedding.Termination","aoid":null,"title":"Agent termination","number":"8.6","namespace":"<no location>","location":"","key":"Agent termination"},{"type":"table","id":"table-agent-record","number":1,"caption":"Table 1: Agent Record Fields","namespace":"<no location>","location":"","key":"Table 1: Agent Record Fields"},{"type":"term","term":"Shared Data Block","refId":"DataTypesValues.SpecTypes.DataBlocks","namespace":"<no location>","location":"","key":"Shared Data Block"},{"type":"term","term":"Shared Data Block ID","refId":"DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID","namespace":"<no location>","location":"","key":"Shared Data Block ID"},{"type":"term","term":"Agent Record","refId":"ExecutableCodeAndContexts.AgentCluster","namespace":"<no location>","location":"","key":"Agent Record"}]</script></head><body><div id="menu-toggle">☰</div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#intro" title="Introduction"><span class="secnum"></span> Introduction</a></li><li><span class="item-toggle">◢</span><a href="#Overview" title="Overview (ES6 4)"><span class="secnum">1</span> Overview (ES6 4)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#Overview.Overview" title="ECMAScript Overview (ES6 4.2)"><span class="secnum">1.1</span> ECMAScript Overview (ES6 4.2)</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#DataTypesValues" title="ECMAScript Data Types and Values (ES6 6)"><span class="secnum">2</span> ECMAScript Data Types and Values (ES6 6)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#DataTypesValues.LanguageTypes" title="ECMAScript Language Types (ES6 6.1)"><span class="secnum">2.1</span> ECMAScript Language Types (ES6 6.1)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#DataTypesValues.LanguageTypes.Number" title="The Number Type (ES6 6.1.6)"><span class="secnum">2.1.1</span> The Number Type (ES6 6.1.6)</a></li><li><span class="item-toggle">◢</span><a href="#DataTypesValues.LanguageTypes.Object" title="The Object Type (ES6 6.1.7)"><span class="secnum">2.1.2</span> The Object Type (ES6 6.1.7)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#DataTypesValues.LanguageTypes.Object.Intrinsic" title="Well-Known Intrinsic Objects (ES6 6.1.7.4)"><span class="secnum">2.1.2.1</span> Well-Known Intrinsic Objects (ES6 6.1.7.4)</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#DataTypesValues.SpecTypes" title="ECMAScript Specification Types (ES6 6.2)"><span class="secnum">2.2</span> ECMAScript Specification Types (ES6 6.2)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#DataTypesValues.SpecTypes.DataBlocks" title="Data blocks (ES6 6.2.6)"><span class="secnum">2.2.1</span> Data blocks (ES6 6.2.6)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes" title="CopyDataBlockBytes (_toBlock_, _toIndex_, _fromBlock_, _fromIndex_, _count_) (ES6 6.2.6.2)"><span class="secnum">2.2.1.1</span> CopyDataBlockBytes (<var>toBlock</var>, <var>toIndex</var>, <var>fromBlock</var>, <var>fromIndex</var>, <var>count</var>) (ES6 6.2.6.2)</a></li><li><span class="item-toggle-none"></span><a href="#DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock" title="CreateSharedByteDataBlock( size )"><span class="secnum">2.2.1.2</span> CreateSharedByteDataBlock( size )</a></li><li><span class="item-toggle-none"></span><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID" title="SharedDataBlockID( block )"><span class="secnum">2.2.1.3</span> SharedDataBlockID( block )</a></li></ol></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#ExecutableCodeAndContexts" title="Executable Code and Execution Contexts (ES6 8)"><span class="secnum">3</span> Executable Code and Execution Contexts (ES6 8)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#ExecutableCodeAndContexts.JobsAndJobQueues" title="Jobs and Job Queues (ES6 8.4)"><span class="secnum">3.1</span> Jobs and Job Queues (ES6 8.4)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.JobsAndJobQueues.Progress" title="Forward Progress Guarantees"><span class="secnum">3.1.1</span> Forward Progress Guarantees</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.AgentCluster" title="Agents (AMENDMENTS)"><span class="secnum">3.2</span> Agents (AMENDMENTS)</a></li><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.AgentCluster" title="Agent Clusters (NEW)"><span class="secnum">3.3</span> Agent Clusters (NEW)</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#GlobalObject" title="The Global Object (ES6 18)"><span class="secnum">4</span> The Global Object (ES6 18)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#GlobalObject.ConstructorProps" title="Constructor Properties of the Global Object (ES6 18.3)"><span class="secnum">4.1</span> Constructor Properties of the Global Object (ES6 18.3)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#GlobalObject.ConstructorProps.SharedArrayBuffer" title="SharedArrayBuffer"><span class="secnum">4.1.1</span> SharedArrayBuffer</a></li><li><span class="item-toggle-none"></span><a href="#GlobalObject.ConstructorProps.Atomics" title="Atomics"><span class="secnum">4.1.2</span> Atomics</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#IndexedCollections" title="Indexed Collections (ES6 22)"><span class="secnum">5</span> Indexed Collections (ES6 22)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray" title="TypedArray Objects (ES6 22.2)"><span class="secnum">5.1</span> TypedArray Objects (ES6 22.2)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray.intrinsic" title="The %TypedArray% intrinsic object (ES6 22.2.1)"><span class="secnum">5.1.1</span> The %TypedArray% intrinsic object (ES6 22.2.1)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#IndexedCollections.TypedArray.intrinsic.constructFromObject" title="%TypedArray%( object ) (ES6 22.2.1.4)"><span class="secnum">5.1.1.1</span> %TypedArray%( object ) (ES6 22.2.1.4)</a></li><li><span class="item-toggle-none"></span><a href="#IndexedCollections.TypedArray.intrinsic.constructFromBuffer" title="%TypedArray%( buffer [ , byteOffset [ , length ] ] ) (ES6 22.2.1.5)"><span class="secnum">5.1.1.2</span> %TypedArray%( buffer [ , byteOffset [ , length ] ] ) (ES6 22.2.1.5)</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray.prototype" title="Properties of the %TypedArrayPrototype% object (ES6 22.2.3)"><span class="secnum">5.1.2</span> Properties of the %TypedArrayPrototype% object (ES6 22.2.3)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray.prototype.set" title=" %TypedArray%.prototype.set( overloaded [ , offset ] ) (ES6 22.2.3.22)"><span class="secnum">5.1.2.1</span> %TypedArray%.prototype.set( overloaded [ , offset ] ) (ES6 22.2.3.22)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#IndexedCollections.TypedArray.prototype.setFromTypedArray" title="%TypedArray%.prototype.set( typedArray [, offset ] ) (ES6 22.2.3.22.2)"><span class="secnum">5.1.2.1.1</span> %TypedArray%.prototype.set( typedArray [, offset ] ) (ES6 22.2.3.22.2)</a></li></ol></li></ol></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData" title="Structured Data (ES6 24)"><span class="secnum">6</span> Structured Data (ES6 24)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.ArrayBuffer" title="ArrayBuffer Objects (ES6 24.1)"><span class="secnum">6.1</span> ArrayBuffer Objects (ES6 24.1)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.ArrayBuffer.abstract" title="Abstract Operations for ArrayBuffer (ES6 24.1.1)"><span class="secnum">6.1.1</span> Abstract Operations for ArrayBuffer (ES6 24.1.1)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer" title="IsDetachedBuffer( arrayBuffer ) (ES6 24.1.1.2)"><span class="secnum">6.1.1.1</span> IsDetachedBuffer( arrayBuffer ) (ES6 24.1.1.2)</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.CloneArrayBuffer" title="CloneArrayBuffer( srcBuffer, srcByteOffset [, cloneConstructor] ) (ES6 24.1.1.4)"><span class="secnum">6.1.1.2</span> CloneArrayBuffer( srcBuffer, srcByteOffset [, cloneConstructor] ) (ES6 24.1.1.4)</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" title="GetValueFromBuffer( arrayBuffer, byteIndex, type, isLittleEndian ) (ES6 24.1.1.5)"><span class="secnum">6.1.1.3</span> GetValueFromBuffer( arrayBuffer, byteIndex, type, isLittleEndian ) (ES6 24.1.1.5)</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer" title="SetValueInBuffer( arrayBuffer, byteIndex, type, value, isLittleEndian ) (ES6 24.1.1.6)"><span class="secnum">6.1.1.4</span> SetValueInBuffer( arrayBuffer, byteIndex, type, value, isLittleEndian ) (ES6 24.1.1.6)</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.DataView" title="DataView Objects (ES6 24.2)"><span class="secnum">6.2</span> DataView Objects (ES6 24.2)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.DataView.constructor" title="The DataView Constructor (ES6 24.2.2)"><span class="secnum">6.2.1</span> The DataView Constructor (ES6 24.2.2)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.DataView.constructor.detail" title="DataView( buffer [ , byteOffset [ , byteLength ] ] ) (ES6 24.2.2.1)"><span class="secnum">6.2.1.1</span> DataView( buffer [ , byteOffset [ , byteLength ] ] ) (ES6 24.2.2.1)</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer" title="SharedArrayBuffer Objects"><span class="secnum">6.3</span> SharedArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.abstract" title="Abstract Operations for SharedArrayBuffer"><span class="secnum">6.3.1</span> Abstract Operations for SharedArrayBuffer</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer" title="AllocateSharedArrayBuffer( constructor, byteLength )"><span class="secnum">6.3.1.1</span> AllocateSharedArrayBuffer( constructor, byteLength )</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory" title="IsSharedMemory( obj )"><span class="secnum">6.3.1.2</span> IsSharedMemory( obj )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.constructor" title="The SharedArrayBuffer Constructor"><span class="secnum">6.3.2</span> The SharedArrayBuffer Constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.constructor.withLength" title="SharedArrayBuffer( length )"><span class="secnum">6.3.2.1</span> SharedArrayBuffer( length )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.constructor.properties" title="Properties of the SharedArrayBuffer constructor"><span class="secnum">6.3.3</span> Properties of the SharedArrayBuffer constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.constructor.properties.prototype" title="SharedArrayBuffer.prototype"><span class="secnum">6.3.3.1</span> SharedArrayBuffer.prototype</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.constructor.properties.get_species" title="get SharedArrayBuffer [ @@species ]"><span class="secnum">6.3.3.2</span> get SharedArrayBuffer [ @@species ]</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.prototype" title="Properties of the SharedArrayBuffer prototype object"><span class="secnum">6.3.4</span> Properties of the SharedArrayBuffer prototype object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.get_byteLength" title="get SharedArrayBuffer.prototype.byteLength"><span class="secnum">6.3.4.1</span> get SharedArrayBuffer.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.constructor" title="SharedArrayBuffer.prototype.constructor"><span class="secnum">6.3.4.2</span> SharedArrayBuffer.prototype.constructor</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.slice" title="SharedArrayBuffer.prototype.slice( start, end )"><span class="secnum">6.3.4.3</span> SharedArrayBuffer.prototype.slice( start, end )</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.toString" title="SharedArrayBuffer.prototype[ @@toStringTag ]"><span class="secnum">6.3.4.4</span> SharedArrayBuffer.prototype[ @@toStringTag ]</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.instances" title="Properties of the SharedArrayBuffer instances"><span class="secnum">6.3.5</span> Properties of the SharedArrayBuffer instances</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#AtomicsObject" title="The Atomics Object"><span class="secnum">7</span> The Atomics Object</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#AtomicsObjectFunctionProps.semantics" title="Runtime semantics"><span class="secnum">7.1</span> Runtime semantics</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#Atomics.WithAtomicAccessTo" title="With atomic access to shared memory"><span class="secnum">7.1.1</span> With atomic access to shared memory</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.ValidateSharedIntegerTypedArray" title="Runtime semantics: ValidateSharedIntegerTypedArray( typedArray [, onlyInt32] )"><span class="secnum">7.1.2</span> Runtime semantics: ValidateSharedIntegerTypedArray( typedArray [, onlyInt32] )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.ValidateAtomicAccess" title="Runtime semantics: ValidateAtomicAccess( typedArray, requestIndex )"><span class="secnum">7.1.3</span> Runtime semantics: ValidateAtomicAccess( typedArray, requestIndex )</a></li><li><span class="item-toggle-none"></span><a href="#WithinTheWaitWakeCriticalSection" title="Within the wait/wake critical section ..."><span class="secnum">7.1.4</span> Within the wait/wake critical section ...</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AgentSignifier" title="Runtime semantics: AgentSignifier( )"><span class="secnum">7.1.5</span> Runtime semantics: AgentSignifier( )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AgentCanSuspend" title="Runtime semantics: AgentCanSuspend( )"><span class="secnum">7.1.6</span> Runtime semantics: AgentCanSuspend( )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AddWaiter" title="Runtime semantics: AddWaiter( W, G, i )"><span class="secnum">7.1.7</span> Runtime semantics: AddWaiter( W, G, i )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.RemoveWaiter" title="Runtime semantics: RemoveWaiter( W, G, i )"><span class="secnum">7.1.8</span> Runtime semantics: RemoveWaiter( W, G, i )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.RemoveWaiters" title="Runtime semantics: RemoveWaiters( G, i, c )"><span class="secnum">7.1.9</span> Runtime semantics: RemoveWaiters( G, i, c )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.Suspend" title="Runtime semantics: Suspend( W, timeout )"><span class="secnum">7.1.10</span> Runtime semantics: Suspend( W, timeout )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.WakeWaiter" title="Runtime semantics: WakeWaiter( W )"><span class="secnum">7.1.11</span> Runtime semantics: WakeWaiter( W )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.FetchOp" title="Runtime semantics: AtomicFetchOp( typedArray, index, value, op )"><span class="secnum">7.1.12</span> Runtime semantics: AtomicFetchOp( typedArray, index, value, op )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#AtomicsObjectFunctionProps" title="Function Properties of the Atomics Object"><span class="secnum">7.2</span> Function Properties of the Atomics Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#Atomics.add" title="Atomics.add( typedArray, index, value )"><span class="secnum">7.2.1</span> Atomics.add( typedArray, index, value )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.and" title="Atomics.and( typedArray, index, value )"><span class="secnum">7.2.2</span> Atomics.and( typedArray, index, value )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.compareExchange" title="Atomics.compareExchange( typedArray, index, expectedValue, replacementValue )"><span class="secnum">7.2.3</span> Atomics.compareExchange( typedArray, index, expectedValue, replacementValue )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.exchange" title="Atomics.exchange( typedArray, index, value )"><span class="secnum">7.2.4</span> Atomics.exchange( typedArray, index, value )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.wait" title="Atomics.wait( typedArray, index, value, timeout )"><span class="secnum">7.2.5</span> Atomics.wait( typedArray, index, value, timeout )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.wake" title="Atomics.wake( typedArray, index, count )"><span class="secnum">7.2.6</span> Atomics.wake( typedArray, index, count )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.isLockFree" title="Atomics.isLockFree( size )"><span class="secnum">7.2.7</span> Atomics.isLockFree( size )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.load" title="Atomics.load( typedArray, index )"><span class="secnum">7.2.8</span> Atomics.load( typedArray, index )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.or" title="Atomics.or( typedArray, index, value )"><span class="secnum">7.2.9</span> Atomics.or( typedArray, index, value )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.store" title="Atomics.store( typedArray, index, value )"><span class="secnum">7.2.10</span> Atomics.store( typedArray, index, value )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.sub" title="Atomics.sub( typedArray, index, value )"><span class="secnum">7.2.11</span> Atomics.sub( typedArray, index, value )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.xor" title="Atomics.xor( typedArray, index, value )"><span class="secnum">7.2.12</span> Atomics.xor( typedArray, index, value )</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#WebBrowserEmbedding" title="Web browser embedding (informative)"><span class="secnum">8</span> Web browser embedding (informative)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.Agents" title="Agent mapping"><span class="secnum">8.1</span> Agent mapping</a></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.MemoryModel" title="Agent communication semantics"><span class="secnum">8.2</span> Agent communication semantics</a></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.DOM" title="DOM, browser APIs, WebIDL"><span class="secnum">8.3</span> DOM, browser APIs, WebIDL</a></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.CloneAndTransfer" title="Transmitting and Cloning SharedArrayBuffers and Views"><span class="secnum">8.4</span> Transmitting and Cloning SharedArrayBuffers and Views</a></li><li><span class="item-toggle">◢</span><a href="#WebBrowserEmbedding.WorkerSemantics" title="Clarifications and changes to Web Worker semantics"><span class="secnum">8.5</span> Clarifications and changes to Web Worker semantics</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.WorkerSemantics.Start" title="Actions to start a worker"><span class="secnum">8.5.1</span> Actions to start a worker</a></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.WorkerSemantics.Jobs" title="Workers are agents"><span class="secnum">8.5.2</span> Workers are agents</a></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.WorkerSemantics.LicenseToKill" title="Curtail the license to kill"><span class="secnum">8.5.3</span> Curtail the license to kill</a></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.WorkerSemantics.Introspection" title="Termination detection"><span class="secnum">8.5.4</span> Termination detection</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding.Termination" title="Agent termination"><span class="secnum">8.6</span> Agent termination</a></li></ol></li></ol></div></div><h1>ECMAScript Shared Memory and Atomics</h1>
<p> Revised: 2016-06-30 </p>
<p> Some algorithms and semantics in this proposal are presented as modifications to existing ES262 algorithms and semantics.  The base revision of ES262 for the modifications is currently f35248729043089b47ccf29e4c47559386f5f6fd (2016-06-29). </p>

<emu-intro id="intro">
<h1><span class="secnum"></span>Introduction<span class="utils"><span class="anchor"><a href="#intro">#</a></span></span></h1>

<p> This proposal adds a simple form of shared memory to ECMAScript.
Shared memory is being exposed in the form of a new SharedArrayBuffer
type; the existing TypedArrays are adapted in such a way that they can
be used to create views on shared memory.  The new global Atomics
object provides atomic operations on shared memory locations,
including operations that can be used to create blocking
synchronization primitives.  Though not a part of this specification,
we intend for the role of "threads" to be played by Web Workers in web
browser environments.</p><p>

</p><p> At this time the proposal adds only low-level primitives to
ECMAScript; we expect the developer community to put together
abstractions that are useful in specific domains.  </p>

<p> The work has been driven by the following use cases:  </p><p>

</p><ul>
  <li> Support for threaded code in programs written in other
  languages that are translated to asm.js or plain JS or a combination
  of the two, notably C and C++ but also other safe languages. 

  </li><li> Support for hand-written JS or JS+asm.js that makes use of
  multiprocessing facilities for select tasks, such as image
  processing, asset management, or game AI.

</li></ul>

<p> The proposal makes only very basic assumptions about the required
hardware and should be broadly implementable with good performance.
Prototype implementations of the API are available in Firefox Nightly
and in Google Chrome (where it is not enabled by default).  </p>

<p>This specification constitutes a restatement and formalization of
an earlier
work,  <a href="https://github.com/tc39/ecmascript_sharedmem/blob/master/historical/Spec_JavaScriptSharedMemoryAtomicsandLocks.pdf">the
spec document for which</a> also contains additional rationale,
background information, discussions, implementation notes, and
comments.</p>

<p> This specification is substantially complete.  However, the
  following aspects are still undergoing refinement.  The refinements
  are expected to have only local effects on the specification.  </p>

<ul>
  <li> The memory model is being improved (Issues
    
    <a href="https://github.com/tc39/ecmascript_sharedmem/issues/22">22</a>,
    
    <a href="https://github.com/tc39/ecmascript_sharedmem/issues/37">37</a>, 
     
    <a href="https://github.com/tc39/ecmascript_sharedmem/issues/48">48</a>,
    
    <a href="https://github.com/tc39/ecmascript_sharedmem/issues/51">51</a>,
    
    <a href="https://github.com/tc39/ecmascript_sharedmem/issues/55">55</a>)

</li></ul>

<p>Changelog:</p>
<ul>
  <li> 2016-06-30 -- Modified algorithms include more context and are more clearly marked, and there's a defined ES262 base revision for those modifications.
  
  </li><li> 2016-05-12 -- (Issue 26) Editorial: Introduce some definition nodes to avoid incorrect cross references.
  
  </li><li> 2016-05-04 -- (Issue 32) Remove SharedArrayBuffer.isView, it is redundant.
  
  </li><li> 2016-05-04 -- (Issue 94, Issue 96) Clarified slightly the meaning of lock-free.
  
  </li><li> 2016-04-06 -- Moved Agent Clusters and shared memory specific agent properties back into this spec; the agents spec is being split into  <a href="https://github.com/tc39/ecma262/pull/522">a PR</a> and ideas specific to the shared memory proposal.
  
  </li><li> 2016-03-30 -- (Issue 95) Renamed Atomics.futexWait as Atomics.wait and Atomics.futexWake as Atomics.wake. No functional change.
  
  </li><li> 2016-03-30 -- (Issue 90) Factor <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref> out as a semantic algorithm, and reference it formally where appropriate. No functional change.
  
  </li><li> 2016-03-30 -- (Issue 69) Remove Atomics.OK, Atomics.TIMEDOUT, Atomics.NOTEQUAL.  Return strings from Atomics.futexWait.
  
  </li><li> 2016-03-30 -- (Issue 93) Fix buggy restriction on byteLength in AllocateSharedArrayBuffer.
  
  </li><li> 2016-03-24 -- (Issue 11) Removed Atomics.futexWakeOrRequeue.
  
  </li><li> 2016-03-24 -- (Issue 57) Added a note on how wait/wake can be throttled.
  
  </li><li> 2016-03-24 -- Removed an orphan note.
  
  </li><li> 2016-03-24 -- (Issue 46) Atomics.isLockFree(4) is guaranteed to return true.
  
  </li><li> 2016-03-24 -- (Issue 12) Removed references to the proposed "synchronic" spec, it was withdrawn.
  
  </li><li> 2016-03-18 -- (Issue 22, 51, 71) Flesh out the memory model.
  
  </li><li> 2016-03-16 -- (Issue 47) Clarified the meaning of "data access" in the memory model, removed irrelevant parameters to the memory model.
  
  </li><li> 2016-03-16 -- (Issue 81) Rewrote prose to reference the Agents spec where appropriate.
  
  </li><li> 2016-03-03 -- (Issue 78) Change <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref> to behave as the DataView and SIMD specs, atomic ops are related to those method suites.
  
  </li><li> 2016-03-03 -- (Issue 72) The <var>value</var> argument of the atomics ops that take a value are converted by <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>, not <emu-xref aoid="ToNumber"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>.
  
  </li><li> 2016-03-03 -- (Issue 63) The <var>count</var> argument of futexWake and futexWakeOrRequeue defaults to +Infinity, not 0.
  
  </li><li> 2016-03-03 -- (Issue 79, Issue 80) Replaced most of the section on web browser embedding with references to agents spec and structured cloning spec.
  
  </li><li> 2016-02-26 -- Editorial work in preparation for first review.
  
  </li><li> 2016-02-10 -- (Issue 62) Rewrote <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref> so as to process index values in the same way as ES6.
  
  </li><li> 2016-02-10 -- (Issue 58) Clarified with a NOTE that no additional rule is needed to establish a happens-before relationship from an atomic write to a futexWait or futexWakeOrRequeue that returns NOTEQUAL.
  
  </li><li> 2016-02-10 -- (Issue 60) <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref> needs to check for a TypedArrayName slot.  
    
  </li><li> 2016-01-23 -- Removed a reference to the note that was removed yesterday.
  
  </li><li> 2016-01-22 -- (Issue 43) Clarified language.  Removed part of a note that attempted to explain an illegal optimization but got it wrong; will be re-introduced later.
  
  </li><li> 2016-01-22 -- (Issue 41) Corrected a bug in yesterday's fix.
  
  </li><li> 2016-01-22 -- Noted that the API is available in Firefox and Chrome.
    Removed mention of any work on relaxed ("unordered") atomics as that is premature.
    Removed mention of specific safe languages that might target this facility.
    Editorial and clarity changes.
  
  </li><li> 2016-01-21 -- (Issue 41) Correct the <emu-xref aoid="RemoveWaiters"><a href="#Atomics.RemoveWaiters">RemoveWaiters</a></emu-xref> algorithm to take less than the full list.
  
  </li><li> 2015-12-28 -- (Issue 36) Allow futexWait to throw an exception if blocking is not allowed on a thread, search for "<emu-xref aoid="AgentCanSuspend"><a href="#Atomics.AgentCanSuspend">AgentCanSuspend</a></emu-xref>".
  
  </li><li> 2015-09-23 -- Spec draft notes are all linked to Issues in the bug tracker.
  
  </li><li> 2015-09-18 -- Corrected the definition of atomic access viability.
  
  </li><li> 2015-09-17 -- Restated the memory model (again) after discussions.
  
  </li><li> 2015-09-15 -- (Issue 24) Spell out constraints on optimization.
  
  </li><li> 2015-09-01 -- (Issue 21) isLockFree returns false if its argument is not the byte size of some <emu-val>integer</emu-val> array.
  
  </li><li> 2015-08-21 -- Expanded the discussion of Service Workers and Shared Workers.
  
  </li><li> 2015-08-18 -- Reformat, update to ecmarkup 1.7.
  
  </li><li> 2015-08-06 -- Added sections on forward progress and clarifications and changes to worker semantics.
  
  </li><li> 2015-07-09 -- Ongoing cleanup and minor bug fixing.  Restated the memory model.
  
  </li><li> 2015-07-08 -- Initial translation from the original proposal.

</li></ul>

</emu-intro>

<emu-clause id="Overview">
  <h1><span class="secnum">1</span>Overview (ES6 4)<span class="utils"><span class="anchor"><a href="#Overview">#</a></span></span></h1>
  <emu-clause id="Overview.Overview">
    <h1><span class="secnum">1.1</span>ECMAScript Overview (ES6 4.2)<span class="utils"><span class="anchor"><a href="#Overview.Overview">#</a></span></span></h1>
    <p>In the third paragraph, include  <b>SharedArrayBuffer</b> after  <b>ArrayBuffer</b>.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="DataTypesValues">
  <h1><span class="secnum">2</span>ECMAScript Data Types and Values (ES6 6)<span class="utils"><span class="anchor"><a href="#DataTypesValues">#</a></span></span></h1>
  
  <emu-clause id="DataTypesValues.LanguageTypes">
    <h1><span class="secnum">2.1</span>ECMAScript Language Types (ES6 6.1)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes">#</a></span></span></h1>
    <emu-clause id="DataTypesValues.LanguageTypes.Number">
      <h1><span class="secnum">2.1.1</span>The Number Type (ES6 6.1.6)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes.Number">#</a></span></span></h1>
      <p>In the NOTE, include  <b>SharedArrayBuffer</b> along with  <b>ArrayBuffer</b>.</p>
    </emu-clause>
    <emu-clause id="DataTypesValues.LanguageTypes.Object">
      <h1><span class="secnum">2.1.2</span>The Object Type (ES6 6.1.7)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes.Object">#</a></span></span></h1>
      <emu-clause id="DataTypesValues.LanguageTypes.Object.Intrinsic">
        <h1><span class="secnum">2.1.2.1</span>Well-Known Intrinsic Objects (ES6 6.1.7.4)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes.Object.Intrinsic">#</a></span></span></h1>
        <p>In table 7, include rows for %SharedArrayBuffer% and %SharedArrayBufferPrototype% in the manner of the rows for ArrayBuffer.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  
  <emu-clause id="DataTypesValues.SpecTypes">
    <h1><span class="secnum">2.2</span>ECMAScript Specification Types (ES6 6.2)<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes">#</a></span></span></h1>
    <emu-clause id="DataTypesValues.SpecTypes.DataBlocks">
      <h1><span class="secnum">2.2.1</span>Data blocks (ES6 6.2.6)<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks">#</a></span></span></h1>
      <p> Insert the following paragraph after the third:  </p>

      <p> A data block that resides in memory that can be referenced from multiple agents is designated a  <dfn>Shared Data Block</dfn>.  </p>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes">
        <h1><span class="secnum">2.2.1.1</span>CopyDataBlockBytes (<var>toBlock</var>, <var>toIndex</var>, <var>fromBlock</var>, <var>fromIndex</var>, <var>count</var>) (ES6 6.2.6.2)<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes">#</a></span></span></h1>
        <p> This algorithm is modified as follows:</p>
        <p>When the abstract operation <emu-xref aoid="CopyDataBlockBytes"><a href="https://tc39.github.io/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref> is called, the following steps are taken:</p>
        <emu-alg><ol><li>Assert: <var>fromBlock</var> and <var>toBlock</var> are distinct <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> <ins>or <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref></ins> values.</li><li>...
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock">
        <h1><span class="secnum">2.2.1.2</span>CreateSharedByteDataBlock( size )<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock">#</a></span></span></h1>
        <p>When the abstract operation CreateSharedByteDataBlock is called with integer argument size, the following steps are taken:</p>
        <emu-alg><ol><li>Assert: <var>size</var> &gt;= 0.</li><li>Let <var>db</var> be a new <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> value consisting of <var>size</var> bytes. If it is impossible to create such a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref>, throw a <emu-const>RangeError</emu-const> exception.</li><li>Set all of the bytes of <var>db</var> to 0.</li><li>Return <var>db</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID" aoid="SharedDataBlockID">
        <h1><span class="secnum">2.2.1.3</span>SharedDataBlockID( block )<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">#</a></span></span></h1>
        <p>When the abstract operation SharedDataBlockID is called with <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> argument <var>block</var>, the following steps are taken:</p>
        <emu-alg><ol><li>Let <var>G</var> be an address-free identifier for <var>block</var>.  All agents in the same agent cluster must use the same value for <var>G</var> for any given <var>block</var>.</li><li>Return <var>G</var>.
        </li></ol></emu-alg>
        <emu-note><span class="note">Note</span>
          <p>The  <dfn>Shared Data Block ID</dfn> is used by the wait/wake mechanism and names <var>block</var> independently of any virtual addresses it may be mapped to in any particular agent.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="ExecutableCodeAndContexts">
  <h1><span class="secnum">3</span>Executable Code and Execution Contexts (ES6 8)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts">#</a></span></span></h1>
  <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues">

    <h1><span class="secnum">3.1</span>Jobs and Job Queues (ES6 8.4)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.JobsAndJobQueues">#</a></span></span></h1>
    <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues.Progress">
      <h1><span class="secnum">3.1.1</span>Forward Progress Guarantees<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.JobsAndJobQueues.Progress">#</a></span></span></h1>
      <p> The forward progress guarantee is provided by  <a href="https://github.com/tc39/ecma262/pull/522">this PR on ES262</a>.  </p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="ExecutableCodeAndContexts.AgentCluster">
    <h1><span class="secnum">3.2</span>Agents (AMENDMENTS)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.AgentCluster">#</a></span></span></h1>

    <p> Add the following properties to the  <dfn>Agent Record</dfn> which is provided by  <a href="https://github.com/tc39/ecma262/pull/522">this PR on ES262</a>:</p>

    <emu-table id="table-agent-record" caption="Agent Record Fields"><figure><figcaption>Table 1: Agent Record Fields</figcaption>
      <table>
        <tbody>
          <tr>
            <th>
	      Field name
	    
	    </th>
            <th>
	      Value
	    
	    </th>
            <th>
	      Meaning
	    
	    </th>
          </tr>
          <tr>
            <td> [[Signifier]]  </td>
            <td> A value that admits equality testing  </td>
            <td> Uniquely identifies the agent within its agent cluster.  Constant.  </td>
          </tr>
          <tr>
            <td> [[IsLockFree1]]  </td>
            <td> Boolean  </td>
            <td> True iff atomic operations on one-byte values are lock-free.  Constant.  </td>
          </tr>
          <tr>
            <td> [[IsLockFree2]]  </td>
            <td> Boolean  </td>
            <td> True iff atomic operations on two-byte values are lock-free.  Constant.  </td>
          </tr>
        </tbody>
      </table>
    </figure></emu-table>

    <emu-note><span class="note">Note</span>
      <p>The values of [[IsLockFree1]] and [[IsLockFree2]] are not
        necessarily constant on a given piece of hardware, but may
        reflect implementation choices that can vary over time and
        between ECMAScript implementations.</p>

      <p>There is no [[IsLockFree4]] property: 4-byte atomic
        operations are always lock-free.  </p>

      <p>Formally, atomic operations are lock-free if, infinitely
        often, some atomic operation finishes in a finite number of
        program steps.  In practice, if an atomic operation is
        implemented with any type of lock the operation is not
        lock-free.  Lock-free does not imply wait-free: there is no
        upper bound on how many machine steps may be required to
        complete a lock-free atomic operation.  </p>

      <p>That an atomic access of size  <em>n</em> is lock-free does
        not imply anything about the (perceived) atomicity of
        non-atomic accesses of size  <em>n</em>, specifically,
        non-atomic accesses may still be performed as a sequence of
        several separate memory accesses.  </p>
    </emu-note>

  </emu-clause>
  
  <emu-clause id="ExecutableCodeAndContexts.AgentCluster">
    <h1><span class="secnum">3.3</span>Agent Clusters (NEW)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.AgentCluster">#</a></span></span></h1>

    <p> An  <em>agent cluster</em> is a maximal set of agents that can
      communicate by operating on shared memory.  </p>

    <emu-note><span class="note">Note 1</span>
      <p> Programs within different agents may share memory by
        unspecified means.  At a minimum, the backing memory for
        <emu-const>SharedArrayBuffer</emu-const> objects can be shared among the agents in
        the cluster.  </p>

      <p> There may be agents that can communicate by message passing
	that cannot share memory; they are never in the same
	cluster.  </p>
    </emu-note>

    <p> Every agent belongs to exactly one agent cluster.  </p>

    <emu-note><span class="note">Note 2</span>
      <p> The agents in a cluster need not all be alive at some
	particular point in time.  If agent  <b>A</b> creates another
	agent  <b>B</b>, after which  <b>A</b> terminates and  <b>B</b>
	creates agent  <b>C</b>, the three agents are in the same
	cluster if  <b>A</b> could share some memory with  <b>B</b>
	and  <b>B</b> could share some memory with  <b>C</b>.  </p>
    </emu-note>

    <p> All agents within a cluster must have the same value for
      the [[LittleEndian]] property in their respective Agent Records.  </p>

    <emu-note><span class="note">Note 3</span>
      <p> (Spec draft note) Is the restriction on [[LittleEndian]] overreach?
	It seemed reasonable at the time, but on some architectures it's
	possible for different processes to have different endianness.  The rule
	precludes sharing memory among such processes, in any ECMAScript
	implementation.  </p>
    </emu-note>

    <p> All agents within a cluster must have the same values for
      the [[IsLockFree1]] property in their respective Agent Records; similarly for
      the [[IsLockFree2]] property.  </p>

    <p> All agents within a cluster must have different values for
      the [[Signifier]] property in their respective Agent Records.  </p>

    <p> An agent cluster is a specification mechanism and need not correspond to
      any particular artefact of an ECMAScript implementation.  </p>

    <p> An embedding may suspend and wake an agent without the agent's
      knowledge or cooperation.  If the embedding does so, it must
      suspend and wake all agents in an agent cluster together.  </p>

    <emu-note><span class="note">Note 4</span>
      <p> The purpose of that restriction is to avoid a situation
        where a worker deadlocks or starves because another agent has
        been suspended.  For example, if a DOM SharedWorker shares
        memory with a regular worker, and the regular worker is
        suspended while it holds a lock (because the web page the
        regular worker is in is pushed into the window history), and
        the SharedWorker tries to acquire the lock, then the
        SharedWorker will be blocked until the regular worker wakes up
        again, if ever.  Meanwhile other workers trying to access the
        SharedWorker from other web pages will starve.  </p>

      <p> The implication of the restriction is that it will not be
        possible to share memory between agents that don't belong to
        the same suspend/wake collective within the embedding.  </p>

      <p> (<a href="https://github.com/tc39/ecmascript_sharedmem/issues/39">Issue 39</a>) That, in
        turn, places interesting demands on the structured clone algorithm in web browsers.  </p>
    </emu-note>

    <p> An embedding may terminate an agent without any of the agent's
      cluster's other agents' prior knowledge or cooperation.  If an
      agent is terminated not by programmatic action of its own or of
      another agent in the cluster but by forces external to the
      cluster, then the embedding has two choices: Either terminate
      all the agents in the cluster, or provide reliable APIs that
      allow the agents in the cluster to coordinate so that at least
      one remaining member of the cluster will be able to detect the
      termination, with the termination data containing enough
      information to identify the agent that was terminated.  </p>

    <emu-note><span class="note">Note 5</span>
      <p> Examples of that type of termination are: operating systems
        or users terminating agents that are running in separate
        processes; the embedding itself terminating an agent that is
        running in-process with the other agents when per-agent
        resource accounting indicates that the agent is runaway.  </p>
    </emu-note>

    <emu-note><span class="note">Note 6</span>
      <p> (Spec draft note) Issue 55 contains discussions around the
        termination signaling requirement.  It is not
        uncontroversial.    </p>

      <p> This spec additionally requires that if termination is
        signaled then the signal creates the necessary happens-before
        edge in the memory ordering, which is a tougher requirement
        than the requirement that it be possible to detect
        termination.  </p>

      <p> The web platform provides nothing at the moment to detect or
        signal termination, regardless of shared memory, and this is
        already a problem for developers.  Agent clusters are more
        tightly coupled than pages that can signal each other, so the
        problem may be easier to solve for agent clusters.  In current
        browsers dedicated workers are anyway in-process and an agent
        cluster will normally terminate en masse, so the requirement
        is satisfied for now.  </p>
    </emu-note>

  </emu-clause> <!-- agent cluster -->

</emu-clause>

<emu-clause id="GlobalObject">
  <h1><span class="secnum">4</span>The Global Object (ES6 18)<span class="utils"><span class="anchor"><a href="#GlobalObject">#</a></span></span></h1>
  <emu-clause id="GlobalObject.ConstructorProps">
    <h1><span class="secnum">4.1</span>Constructor Properties of the Global Object (ES6 18.3)<span class="utils"><span class="anchor"><a href="#GlobalObject.ConstructorProps">#</a></span></span></h1>
    <emu-clause id="GlobalObject.ConstructorProps.SharedArrayBuffer">
      <h1><span class="secnum">4.1.1</span>SharedArrayBuffer<span class="utils"><span class="anchor"><a href="#GlobalObject.ConstructorProps.SharedArrayBuffer">#</a></span></span></h1>
      <p> Add a new subsection for SharedArrayBuffer, pointing to the appropriate new section (below).</p>
    </emu-clause>
    <emu-clause id="GlobalObject.ConstructorProps.Atomics">
      <h1><span class="secnum">4.1.2</span>Atomics<span class="utils"><span class="anchor"><a href="#GlobalObject.ConstructorProps.Atomics">#</a></span></span></h1>
      <p> Add a new subsection for Atomics, pointing to the appropriate new section (below).</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<!--
AllocateTypedArray only allocates an ArrayBuffer if length is specified.
These call AllocateTypedArray with a specified length:
  TypedArrayFrom (twice)
   called from:
     %TypedArray% ( object )
     %TypedArray%.from ( source [,mapFn [,thisArg]] )
  %TypedArray%.of ( ...items ) 
  %TypedArray%.prototype.filter ( callbackFn [, thisArg] )
  %TypedArray%.prototype.slice ( start, end )
  %TypedArray% ()
  %TypedArray% (length)
  -->

<emu-clause id="IndexedCollections">
  <h1><span class="secnum">5</span>Indexed Collections (ES6 22)<span class="utils"><span class="anchor"><a href="#IndexedCollections">#</a></span></span></h1>
  <emu-clause id="IndexedCollections.TypedArray">
    <h1><span class="secnum">5.1</span>TypedArray Objects (ES6 22.2)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray">#</a></span></span></h1>

    <emu-clause id="IndexedCollections.TypedArray.intrinsic">
      <h1><span class="secnum">5.1.1</span>The %TypedArray% intrinsic object (ES6 22.2.1)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.intrinsic">#</a></span></span></h1>

      <emu-clause id="IndexedCollections.TypedArray.intrinsic.constructFromObject">
        <h1><span class="secnum">5.1.1.1</span>%TypedArray%( object ) (ES6 22.2.1.4)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.intrinsic.constructFromObject">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p>This description applies only if the <var>TypedArray</var> function is called with at least one argument and the Type of the first argument is Object and that object does not have either a [[TypedArrayName]]  <del>or</del> <ins>,</ins> an [[ArrayBufferData]]<ins>, or a [[SharedArrayBufferData]]</ins> internal slot.</p>
        <p> ...  </p>
      </emu-clause>

      <emu-clause id="IndexedCollections.TypedArray.intrinsic.constructFromBuffer">
        <h1><span class="secnum">5.1.1.2</span>%TypedArray%( buffer [ , byteOffset [ , length ] ] ) (ES6 22.2.1.5)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.intrinsic.constructFromBuffer">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p>This description applies only if the <var>TypedArray</var> function is called with at least one argument and the Type of the first argument is Object and that object has an [[ArrayBufferData]]  <ins>or [[SharedArrayBufferData]]</ins> internal slot.</p>
        <p><var>TypedArray</var> called with at least one argument <var>buffer</var> performs the following steps:</p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>buffer</var>) is Object and <var>buffer</var> has an [[ArrayBufferData]] <ins>or a [[SharedArrayBufferData]]</ins> internal slot.</li><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>constructorName</var> be the String value of the Constructor Name value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for this <var>TypedArray</var> constructor.</li><li>Let <var>O</var> be ? <emu-xref aoid="AllocateTypedArray"><a href="https://tc39.github.io/ecma262/#sec-allocatetypedarray">AllocateTypedArray</a></emu-xref>(<var>constructorName</var>, NewTarget, <code>"%<var>TypedArray</var>Prototype%"</code>).</li><li>Let <var>constructorName</var> be the String value of <var>O</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Number value of the Element Size value in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>constructorName</var>.</li><li>Let <var>offset</var> be ? ToIndex(<var>byteOffset</var>).</li><li>If <var>offset</var> <emu-xref aoid="modulo"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">modulo</a></emu-xref> <var>elementSize</var> ≠ 0, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><del>Let</del> <ins> If <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>buffer</var>) then let <var>bufferByteLength</var> be <var>buffer</var>.[[SharedArrayBufferByteLength]], otherwise let</ins> <var>bufferByteLength</var> be <var>buffer</var>.[[ArrayBufferByteLength]].</li><li>...
        </li></ol></emu-alg>
      </emu-clause>

    </emu-clause> <!-- intrinsic object -->

    <emu-clause id="IndexedCollections.TypedArray.prototype">
      <h1><span class="secnum">5.1.2</span>Properties of the %TypedArrayPrototype% object (ES6 22.2.3)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype">#</a></span></span></h1>
      <emu-clause id="IndexedCollections.TypedArray.prototype.set">
        <h1><span class="secnum">5.1.2.1</span> %TypedArray%.prototype.set( overloaded [ , offset ] ) (ES6 22.2.3.22)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype.set">#</a></span></span></h1>
        <emu-clause id="IndexedCollections.TypedArray.prototype.setFromTypedArray">
          <h1><span class="secnum">5.1.2.1.1</span>%TypedArray%.prototype.set( typedArray [, offset ] ) (ES6 22.2.3.22.2)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype.setFromTypedArray">#</a></span></span></h1>
          <p>This algorithm is modified as follows:</p>
          <p>Sets multiple values in this <var>TypedArray</var>, reading the values from the <var>typedArray</var> argument object. The optional <var>offset</var> value indicates the first element index in this <var>TypedArray</var> where values are written. If omitted, it is assumed to be 0.</p>
          <emu-alg><ol><li>Assert: <var>typedArray</var> has a [[TypedArrayName]] internal slot. If it does not, the definition in <emu-xref href="#sec-%typedarray%.prototype.set-array-offset"><a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-array-offset">22.2.3.23.1</a></emu-xref> applies.</li><li>Let <var>target</var> be the <emu-val>this</emu-val> value.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>target</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>target</var> does not have a [[TypedArrayName]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>Assert: <var>target</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>targetOffset</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>offset</var>).</li><li>If <var>targetOffset</var> &lt; 0, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>targetBuffer</var> be <var>target</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer">IsDetachedBuffer</a></emu-xref>(<var>targetBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>targetLength</var> be <var>target</var>.[[ArrayLength]].</li><li>Let <var>srcBuffer</var> be <var>typedArray</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer">IsDetachedBuffer</a></emu-xref>(<var>srcBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>targetName</var> be the String value of <var>target</var>.[[TypedArrayName]].</li><li>Let <var>targetType</var> be the String value of the Element Type value in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>targetName</var>.</li><li>Let <var>targetElementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>targetName</var>.</li><li>Let <var>targetByteOffset</var> be <var>target</var>.[[ByteOffset]].</li><li>Let <var>srcName</var> be the String value of <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>srcType</var> be the String value of the Element Type value in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcElementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcLength</var> be <var>typedArray</var>.[[ArrayLength]].</li><li>Let <var>srcByteOffset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>If <var>srcLength</var> + <var>targetOffset</var> &gt; <var>targetLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li><ins>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is SharedArrayBuffer, then let <var>same</var> = <emu-xref aoid="SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">SharedDataBlockID</a></emu-xref>(<var>x</var>.[[SharedArrayBufferData]]) == <emu-xref aoid="SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">SharedDataBlockID</a></emu-xref>(<var>y</var>.[[SharedArrayBufferData]]); otherwise let <var>same</var> = <emu-xref aoid="SameValue"><a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>srcBuffer</var>, <var>targetBuffer</var>). </ins></li><li><del>If <emu-xref aoid="SameValue"><a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>srcBuffer</var>, <var>targetBuffer</var>)</del> <ins><var>same</var></ins> is <emu-val>true</emu-val>, then<ol><li>Let <var>srcBuffer</var> be ? <emu-xref aoid="CloneArrayBuffer"><a href="#StructuredData.ArrayBuffer.abstract.CloneArrayBuffer">CloneArrayBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteOffset</var>, <var>srcLength</var>, <emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.github.io/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>).</li><li>NOTE: <emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.github.io/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref> is used to clone <var>srcBuffer</var> because is it known to not have any observable side-effects.</li><li>Let <var>srcByteIndex</var> be 0.</li></ol></li><li>Else, let <var>srcByteIndex</var> be <var>srcByteOffset</var>.</li><li>...
          </li></ol></emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="StructuredData">
  <h1><span class="secnum">6</span>Structured Data (ES6 24)<span class="utils"><span class="anchor"><a href="#StructuredData">#</a></span></span></h1>

  <emu-clause id="StructuredData.ArrayBuffer">
    <h1><span class="secnum">6.1</span>ArrayBuffer Objects (ES6 24.1)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer">#</a></span></span></h1>

    <emu-clause id="StructuredData.ArrayBuffer.abstract">
      <h1><span class="secnum">6.1.1</span>Abstract Operations for ArrayBuffer (ES6 24.1.1)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract">#</a></span></span></h1>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.IsDetachedBuffer" aoid="IsDetachedBuffer">
        <h1><span class="secnum">6.1.1.1</span>IsDetachedBuffer( arrayBuffer ) (ES6 24.1.1.2)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer">#</a></span></span></h1>
        <p> This algorithm is modified as follows:  </p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>arrayBuffer</var>) is Object and it has an [[ArrayBufferData]] <ins>or a [[SharedArrayBufferData]]<ins> internal slot.</ins></ins></li><li>If <ins><var>arrayBuffer</var> has an [[ArrayBufferData]] internal slot and</ins> <var>arrayBuffer</var>.[[ArrayBufferData]] is <emu-val>null</emu-val>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.CloneArrayBuffer" aoid="CloneArrayBuffer">
        <h1><span class="secnum">6.1.1.2</span>CloneArrayBuffer( srcBuffer, srcByteOffset [, cloneConstructor] ) (ES6 24.1.1.4)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.CloneArrayBuffer">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p> The abstract operation CloneArrayBuffer takes four parameters, an ArrayBuffer  <ins>or SharedArrayBuffer</ins> <var>srcBuffer</var>, an integer offset <var>srcByteOffset</var>, an integer length <var>srcLength</var>, and optionally a constructor function <var>cloneConstructor</var>. It creates a new ArrayBuffer whose data is a copy of <var>srcBuffer</var>'s data over the range starting at <var>srcByteOffset</var> and continuing for <var>srcLength</var> bytes. This operation performs the following steps:</p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>srcBuffer</var>) is Object and it has an [[ArrayBufferData]] <ins>or [[SharedArrayBufferData]]</ins> internal slot.</li><li>If <var>cloneConstructor</var> is not present, then<ol><li>Let <var>cloneConstructor</var> be ? <emu-xref aoid="SpeciesConstructor"><a href="https://tc39.github.io/ecma262/#sec-speciesconstructor">SpeciesConstructor</a></emu-xref>(<var>srcBuffer</var>, <emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.github.io/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>).</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer">IsDetachedBuffer</a></emu-xref>(<var>srcBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>Else, Assert: <emu-xref aoid="IsConstructor"><a href="https://tc39.github.io/ecma262/#sec-isconstructor">IsConstructor</a></emu-xref>(<var>cloneConstructor</var>) is <emu-val>true</emu-val>.</li><li><del>Let</del> <ins>If <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>srcBuffer</var>) then let <var>srcBlock</var> be <var>srcBuffer</var>.[[SharedArrayBufferData]], else let</ins> <var>srcBlock</var> be <var>srcBuffer</var>.[[ArrayBufferData]].</li><li>...
        </li></ol></emu-alg>
      </emu-clause>
      
      <emu-clause id="StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" aoid="GetValueFromBuffer">
        <h1><span class="secnum">6.1.1.3</span>GetValueFromBuffer( arrayBuffer, byteIndex, type, isLittleEndian ) (ES6 24.1.1.5)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">#</a></span></span></h1>
        <p> This algorithm is modified as follows:</p>
        <p> The abstract operation GetValueFromBuffer takes four parameters, an ArrayBuffer  <ins>or SharedArrayBuffer</ins> <var>arrayBuffer</var>, an integer <var>byteIndex</var>, a String <var>type</var>, and optionally a Boolean <var>isLittleEndian</var>. This operation performs the following steps:</p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="IsDetachedBuffer"><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li>Assert: There are sufficient bytes in <var>arrayBuffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li>Assert: <var>byteIndex</var> is an integer value ≥ 0.</li><li><del>Let</del> <ins>If <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>arrayBuffer</var>) then let <var>block</var> be <var>arrayBuffer</var>.[[SharedArrayBufferData]], else let</ins> <var>block</var> be <var>arrayBuffer</var>.[[ArrayBufferData]].</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for Element Type <var>type</var>.</li><li>Let <var>rawValue</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of <var>elementSize</var> containing, in order, the <var>elementSize</var> sequence of bytes starting with <var>block</var>[<var>byteIndex</var>].</li><li>If <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to <del>either <emu-val>true</emu-val> or <emu-val>false</emu-val>. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref> abstract operation</del> <ins>the value of the [[LittleEndian]] internal slot of the surrounding agent's <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref></ins>.</li><li>...
        </li></ol></emu-alg>

        <emu-note><span class="note">Note</span>
          <p> If <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>( <var>arrayBuffer</var> ) is <emu-const>true</emu-const> then two consecutive calls to GetValueFromBuffer with the same arguments in the same agent may or may not return the same value even if there is no write to the buffer in that agent between the read calls: another agent may have written to the buffer.  </p>
        </emu-note>

      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.SetValueInBuffer" aoid="SetValueInBuffer">
        <h1><span class="secnum">6.1.1.4</span>SetValueInBuffer( arrayBuffer, byteIndex, type, value, isLittleEndian ) (ES6 24.1.1.6)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">#</a></span></span></h1>
        <p> This algorithm is modified as follows:</p>
        <p> The abstract operation SetValueInBuffer takes five parameters, an ArrayBuffer  <ins>or SharedArrayBuffer</ins> <var>arrayBuffer</var>, an integer <var>byteIndex</var>, a String <var>type</var>, a Number <var>value</var>, and optionally a Boolean <var>isLittleEndian</var>. This operation performs the following steps:</p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="IsDetachedBuffer"><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li>Assert: There are sufficient bytes in <var>arrayBuffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li>Assert: <var>byteIndex</var> is an integer value ≥ 0.</li><li>Assert: <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>value</var>) is Number.</li><li><del>Let</del> <ins>If <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>arrayBuffer</var>) then let <var>block</var> be <var>arrayBuffer</var>.[[SharedArrayBufferData]], else let</ins> <var>block</var> be <var>arrayBuffer</var>.[[ArrayBufferData]].</li><li>Assert: <var>block</var> is not <emu-val>undefined</emu-val>.</li><li>If <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to <del>either <emu-val>true</emu-val> or <emu-val>false</emu-val>. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref> abstract operation</del> <ins>the value of the [[LittleEndian]] internal slot of the surrounding agent's <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref></ins>.</li><li>...
        </li></ol></emu-alg>

        <emu-note><span class="note">Note</span>
          <p> When SetValueInBuffer is called to set bytes in shared memory the implementation may set several bytes at a time (and that is the normal case), but it may not use read-modify-write on a larger datum, as that might introduce data races where the source program has none.  Data races are discussed in the section on the Atomics object.  </p>
        </emu-note>
      </emu-clause>
      
    </emu-clause> <!-- abstract -->
  </emu-clause> <!-- ArrayBuffer -->

  <emu-clause id="StructuredData.DataView">
    <h1><span class="secnum">6.2</span>DataView Objects (ES6 24.2)<span class="utils"><span class="anchor"><a href="#StructuredData.DataView">#</a></span></span></h1>
    <emu-clause id="StructuredData.DataView.constructor">
      <h1><span class="secnum">6.2.1</span>The DataView Constructor (ES6 24.2.2)<span class="utils"><span class="anchor"><a href="#StructuredData.DataView.constructor">#</a></span></span></h1>
      <emu-clause id="StructuredData.DataView.constructor.detail">
        <h1><span class="secnum">6.2.1.1</span>DataView( buffer [ , byteOffset [ , byteLength ] ] ) (ES6 24.2.2.1)<span class="utils"><span class="anchor"><a href="#StructuredData.DataView.constructor.detail">#</a></span></span></h1>
        <p> This algorithm is modified as follows:  </p>
        <p>When the <code>DataView</code> is called with at least one argument <var>buffer</var>, the following steps are taken:</p>
        <emu-alg><ol><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>buffer</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>buffer</var> does not have an [[ArrayBufferData]] <ins>or a [[SharedArrayBufferData]]</ins> internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>offset</var> be ? ToIndex(<var>byteOffset</var>).</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="#StructuredData.ArrayBuffer.abstract.IsDetachedBuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><del>Let</del> <ins>If <emu-xref aoid="IsSharedMemory"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">IsSharedMemory</a></emu-xref>(<var>buffer</var>) then let <var>bufferByteLength</var> be <var>buffer</var>.[[SharedArrayBufferByteLength]], else let</ins> <var>bufferByteLength</var> be <var>buffer</var>.[[ArrayBufferByteLength]].</li><li>...
        </li></ol></emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause> <!-- DataView -->

  <emu-clause id="StructuredData.SharedArrayBuffer">
    <h1><span class="secnum">6.3</span>SharedArrayBuffer Objects<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer">#</a></span></span></h1>

    <emu-clause id="StructuredData.SharedArrayBuffer.abstract">
      <h1><span class="secnum">6.3.1</span>Abstract Operations for SharedArrayBuffer<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.abstract">#</a></span></span></h1>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer">
        <h1><span class="secnum">6.3.1.1</span>AllocateSharedArrayBuffer( constructor, byteLength )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer">#</a></span></span></h1>
        <p> The abstract operation AllocateSharedArrayBuffer with arguments <var>constructor</var> and <var>byteLength</var> is used to create a SharedArrayBuffer object. It performs the following steps:</p>

        <emu-alg><ol><li>Let <var>obj</var> be <emu-xref aoid="OrdinaryCreateFromConstructor"><a href="https://tc39.github.io/ecma262/#sec-ordinarycreatefromconstructor">OrdinaryCreateFromConstructor</a></emu-xref>(constructor, "%SharedArrayBufferPrototype%", «‍[[SharedArrayBufferData]], [[SharedArrayBufferByteLength]]» ).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>obj</var>).</li><li>Assert: <var>byteLength</var> is a nonnegative integer.</li><li>Let block be CreateSharedByteDataBlock(<var>byteLength</var>).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>block</var>).</li><li>Set <var>obj</var>’s [[SharedArrayBufferData]] internal slot to block.</li><li>Set <var>obj</var>’s [[SharedArrayBufferByteLength]] internal slot to <var>byteLength</var>.</li><li>Return <var>obj</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.IsSharedMemory" aoid="IsSharedMemory">
        <h1><span class="secnum">6.3.1.2</span>IsSharedMemory( obj )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedMemory">#</a></span></span></h1>
        <p> IsSharedMemory tests whether an object represents shared memory.  </p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>obj</var>) is <emu-const>Object</emu-const> and it has an [[ArrayBufferData]] internal slot or a [[SharedArrayBufferData]] internal slot.</li><li>If <var>obj</var> has a [[SharedArrayBufferData]] internal slot then return <emu-const>true</emu-const>.</li><li>Return <emu-const>false</emu-const>.
        </li></ol></emu-alg>
      </emu-clause>

    </emu-clause> <!-- abstract -->

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor">
      <h1><span class="secnum">6.3.2</span>The SharedArrayBuffer Constructor<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor">#</a></span></span></h1>
      <p> The SharedArrayBuffer constructor is the %SharedArrayBuffer% intrinsic object and the initial value of the <emu-const>SharedArrayBuffer</emu-const> property of the <emu-xref href="#global-object"><a href="https://tc39.github.io/ecma262/#global-object">global object</a></emu-xref>. When called as a constructor it creates and initializes a new SharedArrayBuffer object.  The SharedArrayBuffer constructor is not intended to be called as a function and will throw an exception when called in that manner.  </p>

      <p> The SharedArrayBuffer constructor is designed to be subclassable. It may be used as the value of an <emu-const>extends</emu-const> clause of a class definition. Subclass constructors that intend to inherit the specified SharedArrayBuffer behaviour must include a <emu-const>super</emu-const> call to the SharedArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support the <emu-const>SharedArrayBuffer.prototype</emu-const> built-in methods.  </p>

      <emu-note><span class="note">Note</span>
        <p> Unlike an ArrayBuffer, a SharedArrayBuffer cannot become detached, and its internal [[SharedArrayBufferData]] slot is never <emu-const>undefined</emu-const>.</p>
      </emu-note>
      
      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.withLength">
        <h1><span class="secnum">6.3.2.1</span>SharedArrayBuffer( length )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.withLength">#</a></span></span></h1>
        <p> SharedArrayBuffer called with argument length performs the following steps:  </p>
        <emu-alg><ol><li>If NewTarget is <emu-const>undefined</emu-const>, throw a <emu-const>TypeError</emu-const> exception.</li><li>Let <var>numberLength</var> be <emu-xref aoid="ToNumber"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>length</var>).</li><li>Let <var>byteLength</var> be <emu-xref aoid="ToLength"><a href="https://tc39.github.io/ecma262/#sec-tolength">ToLength</a></emu-xref>(<var>numberLength</var>).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>byteLength</var>).</li><li>If <emu-xref aoid="SameValueZero"><a href="https://tc39.github.io/ecma262/#sec-samevaluezero">SameValueZero</a></emu-xref>(<var>numberLength</var>, <var>byteLength</var>) is <emu-const>false</emu-const>, throw a <emu-const>RangeError</emu-const> exception.</li><li>Return AllocateSharedArrayBuffer(NewTarget, <var>byteLength</var>).
        </li></ol></emu-alg>
      </emu-clause>
    </emu-clause> <!-- constructor -->

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties">
      <h1><span class="secnum">6.3.3</span>Properties of the SharedArrayBuffer constructor<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.properties">#</a></span></span></h1>

      <p>The value of the [[Prototype]] internal slot of the SharedArrayBuffer constructor is the intrinsic object <emu-xref href="#sec-properties-of-the-function-constructor"><a href="https://tc39.github.io/ecma262/#sec-properties-of-the-function-constructor">%FunctionPrototype%</a></emu-xref> (q.v.).</p>

      <p>Besides its <emu-const>length</emu-const> property (whose value is 1), the SharedArrayBuffer constructor has the following properties:</p>
      
      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.prototype">
        <h1><span class="secnum">6.3.3.1</span>SharedArrayBuffer.prototype<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.properties.prototype">#</a></span></span></h1>
        <p> The initial value of SharedArrayBuffer.prototype is the intrinsic object %SharedArrayBufferPrototype% (q.v.).</p>
        <p> This property has the attributes { [[Writable]]: <emu-const>false</emu-const>, [[Enumerable]]: <emu-const>false</emu-const>, [[Configurable]]: <emu-const>false</emu-const> }.</p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.get_species">
        <h1><span class="secnum">6.3.3.2</span>get SharedArrayBuffer [ @@species ]<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.properties.get_species">#</a></span></span></h1>
        <p><code>SharedArrayBuffer[@@species]</code> is an accessor property whose set accessor function is <emu-const>undefined</emu-const>. Its get accessor function performs the following steps:</p>
        <emu-alg><ol><li>Return the <emu-const>this</emu-const> value.
        </li></ol></emu-alg>
        <p> The value of the name property of this function is "<code>get [Symbol.species]</code>".</p>
      </emu-clause>
    </emu-clause> <!-- properties -->

    <emu-clause id="StructuredData.SharedArrayBuffer.prototype">
      <h1><span class="secnum">6.3.4</span>Properties of the SharedArrayBuffer prototype object<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype">#</a></span></span></h1>

      <p>The SharedArrayBuffer prototype object is the intrinsic object %SharedArrayBufferPrototype%. The value of the [[Prototype]] internal slot of the SharedArrayBuffer prototype object is the intrinsic object <emu-xref href="#sec-properties-of-the-object-prototype-object"><a href="https://tc39.github.io/ecma262/#sec-properties-of-the-object-prototype-object">%ObjectPrototype%</a></emu-xref> (19.1.3). The SharedArrayBuffer prototype object is an ordinary object. It does not have a [[SharedArrayBufferData]] or [[SharedArrayBufferByteLength]] internal slot.</p>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.get_byteLength">
        <h1><span class="secnum">6.3.4.1</span>get SharedArrayBuffer.prototype.byteLength<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.get_byteLength">#</a></span></span></h1>

        <p> SharedArrayBuffer.prototype.byteLength is an accessor property whose set accessor function is <emu-const>undefined</emu-const>. Its get accessor function performs the following steps:  </p>

        <emu-alg><ol><li>Let <var>O</var> be the <emu-const>this</emu-const> value.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>O</var>) is not <emu-const>Object</emu-const>, throw a <emu-const>TypeError</emu-const> exception.</li><li>If <var>O</var> does not have a [[SharedArrayBufferData]] internal slot, throw a <emu-const>TypeError</emu-const> exception.</li><li>Let <var>length</var> be the value of <var>O</var>’s [[SharedArrayBufferByteLength]] internal slot.</li><li>Return <var>length</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.constructor">
        <h1><span class="secnum">6.3.4.2</span>SharedArrayBuffer.prototype.constructor<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.constructor">#</a></span></span></h1>
        <p> The initial value of <code>SharedArrayBuffer.prototype.constructor</code> is the intrinsic object %SharedArrayBuffer%.  </p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.slice">
        <h1><span class="secnum">6.3.4.3</span>SharedArrayBuffer.prototype.slice( start, end )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.slice">#</a></span></span></h1>
        <p> The following steps are taken:  </p>
        <emu-alg><ol><li>Let <var>O</var> be the <emu-const>this</emu-const> value.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>O</var>) is not <emu-const>Object</emu-const>, throw a <emu-const>TypeError</emu-const> exception.</li><li>If <var>O</var> does not have a [[SharedArrayBufferData]] internal slot, throw a <emu-const>TypeError</emu-const> exception.</li><li>Let <var>len</var> be the value of <var>O</var>’s [[SharedArrayBufferByteLength]] internal slot.</li><li>Let <var>relativeStart</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>start</var>).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>relativeStart</var>).</li><li>If <var>relativeStart</var> &lt; 0, let first be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>((<var>len</var> + <var>relativeStart</var>),0); else let first be <emu-xref aoid="min"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-const>undefined</emu-const>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>end</var>).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>relativeEnd</var>).</li><li>If <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>((<var>len</var> + <var>relativeEnd</var>),0); else let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li>Let <var>newLen</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(<var>final</var> - <var>first</var>,0).</li><li>Let <var>ctor</var> be <emu-xref aoid="SpeciesConstructor"><a href="https://tc39.github.io/ecma262/#sec-speciesconstructor">SpeciesConstructor</a></emu-xref>(<var>O</var>, %SharedArrayBuffer%).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>ctor</var>).</li><li>Let <var>new</var> be <emu-xref aoid="Construct"><a href="https://tc39.github.io/ecma262/#sec-construct">Construct</a></emu-xref>(<var>ctor</var>, «newLen»).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>new</var>).</li><li>If <var>new</var> does not have a [[SharedArrayBufferData]] internal slot, throw a <emu-const>TypeError</emu-const> exception.</li><li>If <emu-xref aoid="SameValue"><a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>new</var>, <var>O</var>) is <emu-const>true</emu-const>, throw a <emu-const>TypeError</emu-const> exception.</li><li>If the value of <var>new</var>’s [[SharedArrayBufferByteLength]] internal slot &lt; <var>newLen</var>, throw a <emu-const>TypeError</emu-const> exception.</li><li>Let <var>fromBuf</var> be the value of <var>O</var>’s [[SharedArrayBufferData]] internal slot.</li><li>Let <var>toBuf</var> be the value of <var>new</var>’s [[SharedArrayBufferData]] internal slot.</li><li>Perform <emu-xref aoid="CopyDataBlockBytes"><a href="https://tc39.github.io/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>toBuf</var>, 0, <var>fromBuf</var>, <var>first</var>, <var>newLen</var>).</li><li>Return <var>new</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.toString">
        <h1><span class="secnum">6.3.4.4</span>SharedArrayBuffer.prototype[ @@toStringTag ]<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.toString">#</a></span></span></h1>
        <p> The initial value of the @@toStringTag property is the String value <code>"SharedArrayBuffer"</code>.</p>

        <p>This property has the attributes { [[Writable]]: <emu-const>false</emu-const>, [[Enumerable]]: <emu-const>false</emu-const>, [[Configurable]]: <emu-const>true</emu-const> }.</p>
      </emu-clause>
    </emu-clause> <!-- prototype -->

    <emu-clause id="StructuredData.SharedArrayBuffer.instances">
      <h1><span class="secnum">6.3.5</span>Properties of the SharedArrayBuffer instances<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.instances">#</a></span></span></h1>

      <p> SharedArrayBuffer instances inherit properties from the SharedArrayBuffer prototype object. SharedArrayBuffer instances each have a [[SharedArrayBufferData]] internal slot and a [[SharedArrayBufferByteLength]] internal slot.  </p>

      <emu-note><span class="note">Note</span>
        <p> SharedArrayBuffer instances, unlike ArrayBuffer instances, are never detached.  </p>
      </emu-note>
    </emu-clause> <!-- instances -->

  </emu-clause> <!-- SharedArrayBuffer -->
</emu-clause> <!-- Structured data -->

<emu-clause id="AtomicsObject">
  <h1><span class="secnum">7</span>The Atomics Object<span class="utils"><span class="anchor"><a href="#AtomicsObject">#</a></span></span></h1>
  
  <emu-clause id="AtomicsObjectFunctionProps.semantics">
    <h1><span class="secnum">7.1</span>Runtime semantics<span class="utils"><span class="anchor"><a href="#AtomicsObjectFunctionProps.semantics">#</a></span></span></h1>
    
    <emu-clause id="Atomics.WithAtomicAccessTo">
      <h1><span class="secnum">7.1.1</span>With atomic access to shared memory<span class="utils"><span class="anchor"><a href="#Atomics.WithAtomicAccessTo">#</a></span></span></h1>
      
      <p> Let  <em>atomic accesses</em> be those algorithm steps that
        are labeled "With atomic access to shared memory" in the
        algorithms below, ie, atomic load, atomic store, and the
        atomic read-modify-write operations add, sub, and, or, xor,
        exchange, and compareExchange.</p>

      <p> Let  <em>data accesses</em> be those invocations of
        <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>() and <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>() that are not part
        of atomic accesses, when those invocations' <var>arrayBuffer</var>
        argument is a SharedArrayBuffer.  </p>
        
      <p> Let the  <em>access range</em> of an atomic or data access be the
        memory cells read or written by the access.  </p>

      <p> Atomic accesses that are  <em>viable</em> are performed in a
        single total order (the  <em>synchronization order</em>)
        consistent with each agent's program order.  An atomic access
        is not viable if its access range intersects with but is not
        equal to the access range of another atomic access from
        another agent that could be adjacent to it in the total order.
        (None of the accesses that intersect in that way are
        viable.)  </p>

      <emu-note><span class="note">Note 1</span>
        <p> ECMAScript allows TypedArrays to alias each other and
          exposes atomic accesses directly on TypedArrays.  It is thus
          possible for atomic accesses of different size to partly
          overlapping access ranges to be performed concurrently.
          Requiring overlapping concurrent atomic accesses to be part
          of the total atomics order would impose significant run-time
          costs on some, possibly all, platforms.</p>

        <p> For example, on a platform such as MIPS32 that only has
          4-byte atomics, an 8-byte atomic access (eg for Int64) must
          be implemented with a lock, yet it is desirable to implement
          4-byte atomic accesses directly.  Requiring overlapping
          concurrent accesses to be part of the total atomics order
          would require all atomic accesses to use the lock.  </p>

        <p> In a more general case, if we were to provide a method to
          (say) atomically compare-and-exchange a larger region of
          memory, such a primitive would have to use a lock on
          virtually all platforms, forcing all platforms to use locks
          even for smaller atomic accesses.  </p>
      </emu-note>

      <p> In the following, "atomic access" refers only to viable
        atomic accesses, and "data access" refers also to non-viable
        atomic accesses.  </p>
      
      <p> An  <em>event</em> in an agent is an atomic access, a
        data access, the sending of a SharedArrayBuffer, the receipt
        of a SharedArrayBuffer, the action of waking up a sleeping
        agent, or a sleeping agent being woken up.  Events can also be
        embedding-specific.  </p>

      <emu-note><span class="note">Note 2</span>
        <p> Examples of embedding-specific events are starting and stopping agents
          and communicating via other channels than shared memory.  </p>
      </emu-note>

      <p> An event A  <em>happens before</em> another event B if either:</p>
      <ol>
        <li> A precedes B in an agent's program order,
        
        </li><li> A is the sending of a SharedArrayBuffer and B is the
        receipt in another agent of that buffer,
        
        </li><li> A is the waking up a sleeping agent and B the agent being
          woken up,
        
        </li><li> A and B are paired embedding-specific events in separate
          agents where the embedding states that A happens before B,
        
        </li><li> A and B are both atomic accesses to identical access ranges,
          B follows A in the synchronization order, and B reads
          the value written by A, or
        
        </li><li> A happens before C and C happens before B (transitivity).
      
      </li></ol>

      <p> Executions must be such that  <em>happens before</em> is
        irreflexive (acyclic).  </p>

      <emu-note><span class="note">Note 3</span>
        <p> If a call to Atomics.wait returns <code>"not-equal"</code> then
          there is a happens-before relation between any atomic write
          that wrote the slot that is read by those functions, because
          those functions use an atomic read to read that slot.  </p>
      </emu-note>

      <p> A data access read R only sees a write W that happens before
        R, where there is no write V such that V happens before R and
        W happens before V.  </p>
      
      <p> An atomic read R sees either the last preceding (in
        synchronization order) atomic write U to the same location, or
        a non-atomic write W that happens before R, where there is no
        write V such that V happens before R and W happens before
        V.  </p>

      <p> Two memory accesses whose access ranges intersect constitute
        a  <em>data race</em> if neither happens before the other, at
        least one of them is not an atomic access, and at least one of
        them is a write.  </p>

      <emu-note><span class="note">Note 4</span>
        <p> If the execution of an agent cluster has no data races, then
          the agent cluster behaves according to one of its sequentially
          consistent executions.  </p>
      </emu-note>

      <p> The race affects the union of the access ranges involved in
        the race, for the duration of the race.  The race ends only
        when all the threads involved in the race have synchronized.  </p>

      <emu-note><span class="note">Note 5</span>
        <p> (Spec draft note) The race starts after the last
          preceding synchronization, but do we need to specify that further?  </p>
      </emu-note>
      
      <p> The access ranges involved in a race will contain
        unpredictable values for the duration of the race, according to the
        following rules:  </p>

      <ol>
        <li> A read from shared memory always produces a value.
        
        </li><li> The shared memory will always honor a write, but if there
          is a race the memory can arbitrarily select bits from the
          operands of the racing writes and the previous memory contents
          at the racy written-to locations.
        
        </li><li> The values at racy locations are not stable
          until the race has ended.
      
      </li></ol>

      <emu-note><span class="note">Note 6</span>
        <p> Mainstream memories behave according to these rules, so
          the rules are really restrictions on the compiler: if there
          is a race, and the compiler can prove that there is a race,
          it still must not produce a completely arbitrary value (thus
          risking revealing a secret by eg reusing register contents),
          but must produce a value that could be a combination of some
          values written to memory. (It could produce the last value
          written by the thread executing the read.)  </p>

        <p> The third rule precludes a so-called rematerialization
          optimization, where a read from shared memory can be
          performed multiple times in such a way that several
          different values are observed for what is a single value in
          the semantics.  If <emu-const>mem</emu-const> is some integer TypedArray the
          following program is not allowed to print 0:  </p>
        <pre>        let x = mem[n];
        if (x)
          print(x);
        </pre>
      </emu-note>

      <emu-note><span class="note">Note 7</span>
        <p> Although the rules above restrict the values that can be
          written to racy locations, races have highly unpredictable
          consequences: a racy -- ie largely unpredictable and
          non-portable -- value used in a condition can confuse the
          program and cause it to compute nonsensical or undesirable
          results which are then used in further computations.  </p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.ValidateSharedIntegerTypedArray" aoid="ValidateSharedIntegerTypedArray">
      <h1><span class="secnum">7.1.2</span>Runtime semantics: ValidateSharedIntegerTypedArray( typedArray [, onlyInt32] )<span class="utils"><span class="anchor"><a href="#Atomics.ValidateSharedIntegerTypedArray">#</a></span></span></h1>
      <emu-alg><ol><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>typedArray</var>) is not Object, throw a <emu-const>TypeError</emu-const> exception.</li><li>If <var>typedArray</var> does not have a [[TypedArrayName]] internal slot, throw a <emu-const>TypeError</emu-const> exception.</li><li>Let <var>typeName</var> be the value of <var>typedArray</var>'s [[TypedArrayName]] internal slot</li><li>If <var>onlyInt32</var> is <emu-const>true</emu-const> then<ol><li>If <var>typeName</var> is not "Int32Array" then throw a <emu-const>TypeError</emu-const> exception</li></ol></li><li>Else<ol><li>If <var>typeName</var> is not "Int8Array", "Uint8Array", "Int16Array", "Uint16Array", "Int32Array", or "Uint32Array" then throw a <emu-const>TypeError</emu-const> exception</li></ol></li><li>If <var>typedArray</var> does not have a [[ViewedArrayBuffer]] internal slot, throw a <emu-const>TypeError</emu-const> exception.</li><li>Let <var>buffer</var> be the value of <var>typedArray</var>’s [[ViewedArrayBuffer]] internal slot</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>buffer</var>) is not Object, throw a <emu-const>TypeError</emu-const> exception</li><li>If <var>buffer</var> does not have a [[SharedArrayBufferData]] internal slot, throw a <emu-const>TypeError</emu-const> exception</li><li>Return <var>buffer</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.ValidateAtomicAccess" aoid="ValidateAtomicAccess">
      <h1><span class="secnum">7.1.3</span>Runtime semantics: ValidateAtomicAccess( typedArray, requestIndex )<span class="utils"><span class="anchor"><a href="#Atomics.ValidateAtomicAccess">#</a></span></span></h1>
      <p> Perform the following steps:  </p>
      <emu-alg><ol><li>Assert: <var>typedArray</var> is an Object that has a [[ViewedArrayBuffer]] internal slot</li><li>Let <var>numberIndex</var> be <emu-xref aoid="ToNumber"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>requestIndex</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>numberIndex</var>)</li><li>Let <var>accessIndex</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>numberIndex</var>)</li><li>If <var>numberIndex</var> ≠ <var>accessIndex</var>, throw a <emu-const>RangeError</emu-const> exception</li><li>Let <var>length</var> be the value of <var>typedArray</var>'s [[ArrayLength]] internal slot</li><li>If <var>accessIndex</var> &lt; 0 or <var>accessIndex</var> ≥ <var>length</var>, throw a <emu-const>RangeError</emu-const> exception</li><li>Return <var>accessIndex</var>
      </li></ol></emu-alg>
    </emu-clause>
    
    <emu-clause id="WithinTheWaitWakeCriticalSection">
      <h1><span class="secnum">7.1.4</span>Within the wait/wake critical section ...<span class="utils"><span class="anchor"><a href="#WithinTheWaitWakeCriticalSection">#</a></span></span></h1>
      <p> In the algorithms below, the algorithm step 'Within the wait/wake critical section' means the following:</p>
      <ul>
        <li> There is a single critical section for the wait/wake operations that is shared among all agents in an agent cluster.
        
        </li><li> The phrase 'Within the wait/wake critical section' acquires that section exclusively; any return from the dependent statements releases the section.
      
      </li></ul>
    </emu-clause>

    <emu-note><span class="note">Note</span>
      <p> (<a href="https://github.com/tc39/ecmascript_sharedmem/issues/27">Issue 27</a>) The single critical section is an overspecification.  Really we only need a single critical section per address-free int32 cell.  This cell can be attached to the agent record as a property, but it may be that it is better provided by some semantic function of the address-free cell address.  </p>
    </emu-note>

    <emu-clause id="Atomics.AgentSignifier" aoid="AgentSignifier">
      <h1><span class="secnum">7.1.5</span>Runtime semantics: AgentSignifier( )<span class="utils"><span class="anchor"><a href="#Atomics.AgentSignifier">#</a></span></span></h1>
      <p> When AgentSignifier is called without arguments then the following steps are taken.</p>
      <emu-alg><ol><li>Let <var>W</var> be the value of the [[Signifier]] property of the <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref> of the <em>surrounding agent</em>.</li><li>Return <var>W</var>.
      </li></ol></emu-alg>

    </emu-clause>
    
    <emu-clause id="Atomics.AgentCanSuspend" aoid="AgentCanSuspend">
      <h1><span class="secnum">7.1.6</span>Runtime semantics: AgentCanSuspend( )<span class="utils"><span class="anchor"><a href="#Atomics.AgentCanSuspend">#</a></span></span></h1>
      <p> When AgentCanSuspend is called without arguments then the following steps are taken.</p>
      <emu-alg><ol><li>Let <var>B</var> be the value of the [[CanBlock]] property of the <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref> of the <em>surrounding agent</em>.</li><li>Return <var>B</var>.
      </li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p> In some environments it may not be reasonable for a given agent to suspend.  For example,
          in a web browser environment, it may be reasonable to disallow suspending a document's main event
          handling thread, while still allowing workers' event handling threads to suspend.  </p>
      </emu-note>

    </emu-clause>
    
    <emu-clause id="Atomics.AddWaiter" aoid="AddWaiter">
      <h1><span class="secnum">7.1.7</span>Runtime semantics: AddWaiter( W, G, i )<span class="utils"><span class="anchor"><a href="#Atomics.AddWaiter">#</a></span></span></h1>
      <p> When AddWaiter is called with an agent signifier <var>W</var>, a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">Shared Data Block ID</a></emu-xref> <var>G</var>, and a nonnegative integer <var>i</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: The calling agent is in the wait/wake critical section.</li><li>Assert: <var>W</var> is not in any global list of waiters</li><li>Add <var>W</var> to the end of the global list of all waiters that wait on (<var>G</var>, <var>i</var>)
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.RemoveWaiter" aoid="RemoveWaiter">
      <h1><span class="secnum">7.1.8</span>Runtime semantics: RemoveWaiter( W, G, i )<span class="utils"><span class="anchor"><a href="#Atomics.RemoveWaiter">#</a></span></span></h1>
      <p> When RemoveWaiter is called with an agent signifier <var>W</var>, a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">Shared Data Block ID</a></emu-xref> <var>G</var>, and a nonnegative integer <var>i</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: The calling agent is in the wait/wake critical section.</li><li>Assert: <var>W</var> is in the global list of all waiters that wait on (<var>G</var>, <var>i</var>)</li><li>Remove <var>W</var> from the global list of all waiters that wait on (<var>G</var>, <var>i</var>)
      </li></ol></emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.RemoveWaiters" aoid="RemoveWaiters">
      <h1><span class="secnum">7.1.9</span>Runtime semantics: RemoveWaiters( G, i, c )<span class="utils"><span class="anchor"><a href="#Atomics.RemoveWaiters">#</a></span></span></h1>
      <p> When RemoveWaiters is called with <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">Shared Data Block ID</a></emu-xref> <var>G</var> and nonnegative integers <var>i</var> and <var>c</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: The calling agent is in the wait/wake critical section.</li><li>Let <var>L</var> be the empty list</li><li>Let <var>S</var> be a reference to the global list of all waiters that wait on (<var>G</var>, <var>i</var>)</li><li>While <var>c</var> &gt; 0 and <var>S</var> is not the empty list:<ol><li>Let <var>W</var> be the first worker in <var>S</var></li><li>Add <var>W</var> to the end of <var>L</var></li><li>Remove <var>W</var> from <var>S</var></li><li>Subtract 1 from <var>c</var></li></ol></li><li>Return <var>L</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.Suspend" aoid="Suspend">
      <h1><span class="secnum">7.1.10</span>Runtime semantics: Suspend( W, timeout )<span class="utils"><span class="anchor"><a href="#Atomics.Suspend">#</a></span></span></h1>
      <p> When Suspend is called with a an agent signifier <var>W</var> and nonnegative number <var>timeout</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: The calling agent is in the wait/wake critical section.</li><li>Assert: The calling agent is on some global list of waiters</li><li>Assert: <var>W</var> is equal to <emu-xref aoid="AgentSignifier"><a href="#Atomics.AgentSignifier">AgentSignifier</a></emu-xref>()</li><li>Assert: <emu-xref aoid="AgentCanSuspend"><a href="#Atomics.AgentCanSuspend">AgentCanSuspend</a></emu-xref>() is equal to true</li><li>Atomically relinquish the wait/wake critical section and suspend <var>W</var> for up to <var>timeout</var> milliseconds.  <var>W</var> can wake up either because the timeout expired or because it was woken explicitly by another agent calling <emu-xref aoid="WakeWaiter"><a href="#Atomics.WakeWaiter">WakeWaiter</a></emu-xref>(<var>W</var>), and not for any other reasons at all.</li><li>Re-acquire the wait/wake critical section.</li><li>If <var>W</var> was woken explicitly by another agent calling <emu-xref aoid="WakeWaiter"><a href="#Atomics.WakeWaiter">WakeWaiter</a></emu-xref>(<var>W</var>), then return <emu-const>true</emu-const></li><li>Return <emu-const>false</emu-const>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.WakeWaiter" aoid="WakeWaiter">
      <h1><span class="secnum">7.1.11</span>Runtime semantics: WakeWaiter( W )<span class="utils"><span class="anchor"><a href="#Atomics.WakeWaiter">#</a></span></span></h1>
      <p> When WakeWaiter is called with an agent signifier <var>W</var>, then the following steps are taken.  </p>
      <emu-alg><ol><li>Assert: The calling agent is in the wait/wake critical section.</li><li>Assert: <var>W</var> is on some global list of waiters</li><li>Wake the agent <var>W</var>
      </li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p> The embedding may delay waking <var>W</var>, eg for resource
          management reasons, but <var>W</var> must eventually be woken in
          order to guarantee forward progress.  </p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.FetchOp" aoid="AtomicFetchOp">
      <h1><span class="secnum">7.1.12</span>Runtime semantics: AtomicFetchOp( typedArray, index, value, op )<span class="utils"><span class="anchor"><a href="#Atomics.FetchOp">#</a></span></span></h1>
      <p> AtomicFetchOp is a semantic function that atomically loads
        a value, combines it with another value, and stores the result
        of the combination.  It returns the loaded value.  It is
        parameterized by the (pure) combining operation.  The following
        steps are taken:  </p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>buffer</var>)</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>i</var>)</li><li>Let <var>v</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>value</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>value</var>).</li><li>Let <var>arrayTypeName</var> be the value of <var>typedArray</var>'s [[TypedArrayName]] internal slot</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be the value of <var>typedArray</var>’s [[ByteOffset]] internal slot.</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var></li><li>With atomic access to shared memory, do:<ol><li>Let <var>r</var> be the result of <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var> )</li><li>Compute: Let <var>w</var> be <var>op</var>(<var>r</var>, <var>v</var>)</li><li>Call <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>w</var> )</li></ol></li><li>Return <var>r</var>
      </li></ol></emu-alg>
    </emu-clause>
  </emu-clause> <!-- runtime semantics -->

  <emu-clause id="AtomicsObjectFunctionProps">
    <h1><span class="secnum">7.2</span>Function Properties of the Atomics Object<span class="utils"><span class="anchor"><a href="#AtomicsObjectFunctionProps">#</a></span></span></h1>

    <emu-clause id="Atomics.add">
      <h1><span class="secnum">7.2.1</span>Atomics.add( typedArray, index, value )<span class="utils"><span class="anchor"><a href="#Atomics.add">#</a></span></span></h1>
      <p> Let <code>add</code> denote a semantic function of two number arguments that returns the sum of the arguments.  </p>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>result</var> be <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>( <var>typedArray</var>, <var>index</var>, <var>value</var>, <code>add</code> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>)</li><li>Return <var>result</var>
      </li></ol></emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.and">
      <h1><span class="secnum">7.2.2</span>Atomics.and( typedArray, index, value )<span class="utils"><span class="anchor"><a href="#Atomics.and">#</a></span></span></h1>
      <p> Let <code>and</code> denote a semantic function of two number arguments that returns the bitwise "and" of the arguments.  </p>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>result</var> be <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>( <var>typedArray</var>, <var>index</var>, <var>value</var>, <code>and</code> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>)</li><li>Return <var>result</var>
      </li></ol></emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.compareExchange">
      <h1><span class="secnum">7.2.3</span>Atomics.compareExchange( typedArray, index, expectedValue, replacementValue )<span class="utils"><span class="anchor"><a href="#Atomics.compareExchange">#</a></span></span></h1>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>buffer</var>)</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>i</var>)</li><li>Let <var>expected</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>expectedValue</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>expected</var>)</li><li>Let <var>replacement</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>replacedValue</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>replacement</var>)</li><li>Let <var>arrayTypeName</var> be the value of <var>typedArray</var>'s [[TypedArrayName]] internal slot</li><li>Let <var>convOp</var> be the conversion operation specified in Table 49 for <var>arrayTypeName</var></li><li>Let <var>x</var> be <var>convOp</var> ( <var>expected</var> )</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be the value of <var>typedArray</var>’s [[ByteOffset]] internal slot.</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var></li><li>With atomic access to shared memory, do:<ol><li>Let <var>r</var> be <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var> )</li><li>If <var>r</var> is the same as <var>x</var> then:<ol><li>Call <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>replacement</var> )</li></ol></li></ol></li><li>Return <var>r</var>
      </li></ol></emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.exchange">
      <h1><span class="secnum">7.2.4</span>Atomics.exchange( typedArray, index, value )<span class="utils"><span class="anchor"><a href="#Atomics.exchange">#</a></span></span></h1>
      <p> Let <code>second</code> denote a semantic function of two number arguments that returns its second argument.  </p>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>result</var> be <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>( <var>typedArray</var>, <var>index</var>, <var>value</var>, <code>second</code> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>)</li><li>Return <var>result</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.wait">
      <h1><span class="secnum">7.2.5</span>Atomics.wait( typedArray, index, value, timeout )<span class="utils"><span class="anchor"><a href="#Atomics.wait">#</a></span></span></h1>
      <p> Atomics.wait puts the calling agent in a wait queue and puts it to sleep until it is awoken or the sleep times out. The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>, <emu-const>true</emu-const>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>buffer</var>)</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>i</var>)</li><li>Let <var>v</var> be the result of <emu-xref aoid="ToInt32"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref>(<var>value</var>).</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>v</var>)</li><li>If <var>timeout</var> is not provided or is <emu-const>undefined</emu-const> then let <var>t</var> be +Infinity.  Otherwise:<ol><li>Let <var>q</var> be the result of <emu-xref aoid="ToNumber"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>timeout</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>q</var>)</li><li>If <var>q</var> is NaN then let <var>t</var> be +Infinity, otherwise let <var>t</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(0, <var>q</var>).</li></ol></li><li>Let <var>B</var> be <emu-xref aoid="AgentCanSuspend"><a href="#Atomics.AgentCanSuspend">AgentCanSuspend</a></emu-xref>()</li><li>If <var>B</var> is <emu-const>false</emu-const> then throw a <emu-const>TypeError</emu-const> exception.</li><li>Let <var>bufferVal</var> be the value of the internal [[SharedArrayBufferData]] property of <var>buffer</var>.</li><li>Let <var>G</var> be <emu-xref aoid="SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">SharedDataBlockID</a></emu-xref>(<var>bufferVal</var>)</li><li>Within the wait/wake critical section do:<ol><li>Let <var>w</var> be Atomics.load(<var>typedArray</var>, <var>i</var>)</li><li>If <var>v</var> does not equal <var>w</var> then:<ol><li>Return the string <code>"not-equal"</code>.</li></ol></li><li>Let <var>W</var> be <emu-xref aoid="AgentSignifier"><a href="#Atomics.AgentSignifier">AgentSignifier</a></emu-xref>().</li><li>Call <emu-xref aoid="AddWaiter"><a href="#Atomics.AddWaiter">AddWaiter</a></emu-xref>(<var>W</var>, <var>G</var>, <var>i</var>)</li><li>Let awoken = <emu-xref aoid="Suspend"><a href="#Atomics.Suspend">Suspend</a></emu-xref>(<var>W</var>, <var>t</var>)</li><li>Call <emu-xref aoid="RemoveWaiter"><a href="#Atomics.RemoveWaiter">RemoveWaiter</a></emu-xref>(<var>W</var>, <var>G</var>, <var>i</var>)</li></ol></li><li>If awoken is <emu-const>true</emu-const> then return the string <code>"ok"</code>.</li><li>Return the string <code>"timed-out"</code>.
      </li></ol></emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.wake">
      <h1><span class="secnum">7.2.6</span>Atomics.wake( typedArray, index, count )<span class="utils"><span class="anchor"><a href="#Atomics.wake">#</a></span></span></h1>
      <p> Atomics.wake wakes up some agents that are sleeping in the wait queue.  The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>( <var>typedArray</var>, <emu-const>true</emu-const> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>( <var>buffer</var> )</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>( <var>i</var> )</li><li>If <var>count</var> is not provided or is <emu-const>undefined</emu-const> then let <var>c</var> be +Infinity.  Otherwise:<ol><li>Let <var>tmp</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>( <var>count</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>( <var>tmp</var> )</li><li>Let <var>c</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>( +0, <var>tmp</var> ).</li></ol></li><li>Let <var>bufferVal</var> be the value of the internal [[SharedArrayBufferData]] property of <var>buffer</var>.</li><li>Let <var>G</var> be <emu-xref aoid="SharedDataBlockID"><a href="#DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID">SharedDataBlockID</a></emu-xref>( <var>bufferVal</var> )</li><li>Let <var>n</var> = 0</li><li>Within the wait/wake critical section do:<ol><li>Let <var>S</var> be <emu-xref aoid="RemoveWaiters"><a href="#Atomics.RemoveWaiters">RemoveWaiters</a></emu-xref>( <var>G</var>, <var>i</var>, <var>c</var> )</li><li>While <var>S</var> is not the empty list:<ol><li>Let <var>W</var> be the first agent in <var>S</var></li><li>Remove <var>W</var> from the front of <var>S</var></li><li>Call <emu-xref aoid="WakeWaiter"><a href="#Atomics.WakeWaiter">WakeWaiter</a></emu-xref>( <var>W</var> )</li><li>Add 1 to <var>n</var></li></ol></li></ol></li><li>Return <var>n</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.isLockFree">
      <h1><span class="secnum">7.2.7</span>Atomics.isLockFree( size )<span class="utils"><span class="anchor"><a href="#Atomics.isLockFree">#</a></span></span></h1>

      <emu-alg><ol><li>Let <var>n</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>size</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>n</var>)</li><li>If <var>n</var> equals 1 then return the value of the [[IsLockFree1]] property of the <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref> of the <em>surrounding agent</em>.</li><li>If <var>n</var> equals 2 then return the value of the [[IsLockFree2]] property of the <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref> of the <em>surrounding agent</em>.</li><li>If <var>n</var> equals 4 then return <emu-const>true</emu-const>.</li><li>Return <emu-const>false</emu-const>
      </li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p> Atomics.isLockFree() is an optimization primitive.  The
          intuition is that if the atomic step of an atomic primitive
          (compareExchange, load, store, add, sub, and, or, xor, or
          exchange) on a datum of size <var>n</var> bytes will be performed
          without the calling agent acquiring a lock outside the <var>n</var>
          bytes comprising the datum, then Atomics.isLockFree(<var>n</var>)
          will return <emu-const>true</emu-const>.  High-performance algorithms will use
          Atomics.isLockFree() to determine whether to use locks or
          atomic operations in critical sections.  If an atomic
          primitive is not lock-free then it is often more efficient
          for an algorithm to provide its own locking.  </p>

        <p> Atomics.isLockFree(4) always returns <emu-const>true</emu-const> as that can be
          supported on all known relevant hardware.  Being able to
          assume this will generally simplify programs.  </p>

      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.load">
      <h1><span class="secnum">7.2.8</span>Atomics.load( typedArray, index )<span class="utils"><span class="anchor"><a href="#Atomics.load">#</a></span></span></h1>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>buffer</var>)</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>i</var>)</li><li>Let <var>arrayTypeName</var> be the value of <var>typedArray</var>'s [[TypedArrayName]] internal slot</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be the value of <var>typedArray</var>’s [[ByteOffset]] internal slot.</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var></li><li>With atomic access to shared memory, do:<ol><li>Let <var>r</var> be the result of <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var> )</li></ol></li><li>Return <var>r</var>
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.or">
      <h1><span class="secnum">7.2.9</span>Atomics.or( typedArray, index, value )<span class="utils"><span class="anchor"><a href="#Atomics.or">#</a></span></span></h1>
      <p> Let <code>or</code> denote a semantic function of two number arguments that returns the bitwise "or" of the arguments.  </p>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>result</var> be <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>( <var>typedArray</var>, <var>index</var>, <var>value</var>, <code>or</code> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>)</li><li>Return <var>result</var>
      </li></ol></emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.store">
      <h1><span class="secnum">7.2.10</span>Atomics.store( typedArray, index, value )<span class="utils"><span class="anchor"><a href="#Atomics.store">#</a></span></span></h1>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>buffer</var> be <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>buffer</var>)</li><li>Let <var>i</var> be <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>( <var>typedArray</var>, <var>index</var> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>i</var>)</li><li>Let <var>v</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>value</var>)</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>v</var>)</li><li>Let <var>arrayTypeName</var> be the value of <var>typedArray</var>'s [[TypedArrayName]] internal slot</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be the value of <var>typedArray</var>’s [[ByteOffset]] internal slot.</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var></li><li>With atomic access to shared memory, do:<ol><li>Call <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>( <var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>v</var> )</li></ol></li><li>Return <var>v</var>
      </li></ol></emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.sub">
      <h1><span class="secnum">7.2.11</span>Atomics.sub( typedArray, index, value )<span class="utils"><span class="anchor"><a href="#Atomics.sub">#</a></span></span></h1>
      <p> Let <code>subtract</code> denote a semantic function of two number arguments that returns the difference of the arguments.  </p>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>result</var> be <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>( <var>typedArray</var>, <var>index</var>, <var>value</var>, <code>subtract</code> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>)</li><li>Return <var>result</var>
      </li></ol></emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.xor">
      <h1><span class="secnum">7.2.12</span>Atomics.xor( typedArray, index, value )<span class="utils"><span class="anchor"><a href="#Atomics.xor">#</a></span></span></h1>
      <p> Let <code>xor</code> denote a semantic function of two number arguments that returns the bitwise "xor" of the arguments.  </p>
      <p> The following steps are taken:  </p>
      <emu-alg><ol><li>Let <var>result</var> be <emu-xref aoid="AtomicFetchOp"><a href="#Atomics.FetchOp">AtomicFetchOp</a></emu-xref>( <var>typedArray</var>, <var>index</var>, <var>value</var>, <code>xor</code> )</li><li><emu-xref aoid="ReturnIfAbrupt"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>)</li><li>Return <var>result</var>
      </li></ol></emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="WebBrowserEmbedding">
  <h1><span class="secnum">8</span>Web browser embedding (informative)<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding">#</a></span></span></h1>

  <emu-note><span class="note">Note</span>
    <p> The  <a href="https://github.com/whatwg/html/pull/727">emerging
      revision of the Structured Clone specification</a> has details
      on how SharedArrayBuffers are transmitted among agents.  What is
      left here comprises constraints and agent mapping detail.  </p>
  </emu-note>

  <emu-clause id="WebBrowserEmbedding.Agents">
    <h1><span class="secnum">8.1</span>Agent mapping<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.Agents">#</a></span></span></h1>

    <p> In a web browser an  <em>agent</em> is an HTML  <em>event
      loop</em> <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">[here]</a>.    </p>

    <p> Browsers will typically let agents that run on the browser's
      main thread have [[CanBlock]]=false.  Browsers that support
      several tabs within the same content process may share a single
      agent execution thread across all the tabs in that case (Firefox
      does).  </p>

    <p> Normal ("dedicated") Web Workers must be supported.</p>

    <p> There are reasons not to support transmitting shared memory
      from a web page to a ServiceWorker or SharedWorker ("non-page
      workers").  In some browsers, non-page workers may be
      technically incapable of receiving shared memory segments due to
      process separation.  Also, if a non-page is communicating
      through shared memory with a web worker, a deadlock can ensue if
      the non-page worker is waiting to be woken up by the web worker
      and the web worker is suspended or killed because its owning
      document is placed into the history or closed.  </p>

    <p> The structured clone spec makes (or will make) an allowance for
      the transmission to fail.  If shared memory cannot be transmitted
      that failure mechanism will be invoked.  </p>

  </emu-clause>
  
  <emu-clause id="WebBrowserEmbedding.MemoryModel">
    <h1><span class="secnum">8.2</span>Agent communication semantics<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.MemoryModel">#</a></span></span></h1>

    <p>Agent-to-agent communication extends the happens-before
    relation of the program, as follows:</p>

    <ul>
      <li>The call to the Worker constructor in the parent
        happens-before the execution of the main script in the worker.
      
      </li><li>The termination of a worker happens-before the parent of the
        worker (or any other agent) can determine that the worker has
        terminated.
      
      </li><li>A postMessage to a worker happens-before the event fires in the worker.
    
    </li></ul>

  </emu-clause>

  <emu-clause id="WebBrowserEmbedding.DOM">
    <h1><span class="secnum">8.3</span>DOM, browser APIs, WebIDL<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.DOM">#</a></span></span></h1>

    <p> APIs that can accept shared memory should do so explicitly.
      See  <a href="https://github.com/tc39/ecmascript_sharedmem/issues/38">Issue
      #38</a> for a discussion of possible changes to WebIDL to make
      the necessary annotations possible.  </p>

  </emu-clause>

  <emu-clause id="WebBrowserEmbedding.CloneAndTransfer">
    <h1><span class="secnum">8.4</span>Transmitting and Cloning SharedArrayBuffers and Views<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.CloneAndTransfer">#</a></span></span></h1>

    <p> Transmitting and cloning in a web browser are addressed by the
      HTML spec.
      See  <a href="https://github.com/tc39/ecmascript_sharedmem/issues/65">Issue
      #65</a> for a discussion and for the prose that was previously
      here,  <a href="https://github.com/whatwg/html/pull/727">Issue
      #727 of the WHATWG spec</a> for the proposed changes (and many
      other things),
      and  <a href="https://github.com/tc39/ecmascript_sharedmem/issues/39">Issue
      #39</a> for a discussion of how transfering and cloning can
      fail.  </p>

  </emu-clause>

  <emu-clause id="WebBrowserEmbedding.WorkerSemantics">
    <h1><span class="secnum">8.5</span>Clarifications and changes to Web Worker semantics<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.WorkerSemantics">#</a></span></span></h1>

    <emu-note><span class="note">Note</span>
      <p> Several of these issues have been reported as bugs against the WHATWG
      spec,  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29039">see
      this bug report</a>.  </p>
    </emu-note>

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Start">
      <h1><span class="secnum">8.5.1</span>Actions to start a worker<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.WorkerSemantics.Start">#</a></span></span></h1>
      <p> (Clarification) The only action required to start a worker is to call
	"new Worker()".  </p>

      <emu-note><span class="note">Note 1</span>
	<p> (Spec draft note) Firefox requires a trip through the event loop
	  to start the worker.  I'm told this won't be fixed, spec or no spec.  </p>

	<p> The current state of affairs is a minor deadlock hazard.  If one
	  worker creates another and then blocks on a futex waiting
	  for the new worker to unblock it, the workers may deadlock
	  since the new one may not have been created.  The hazard is
	  reduced by (a) prohibiting blocking on the main thread and
	  (b) either disallowing nested workers or not requiring
	  workers to return to their event loops to get a nested
	  worker started.  </p>
      </emu-note>

      <p> (Compatible change) If a worker cannot be started for reasons of
	resource exhaustion (notably, no threads available, including arbitrary
	implementation limits on the number of threads) then an error must be
	reported in some manner TBD (TODO).  </p>

      <emu-note><span class="note">Note 2</span>
        <p> (Spec draft note) In current Firefox, there is a per-domain limit on
          the number of workers.  An attempt to create a worker will silently
          not start the worker if the limit has been reached; the worker will be
          queued and started when another worker has terminated.  Again, this
          creates deadlock hazards.  </p>

        <p> There are other error situations during worker startup that can't
          necessarily be signaled synchronously, notably, a load error on the
          URL.  Those have to be signaled via an event callback, or the creating
          agent must poll the state of the worker to see if it enters an error
          state (see more below on the state).  A callback is probably cleanest,
          but we'll want the state variable anyway, so maybe both.  </p>
      </emu-note>
    </emu-clause> <!-- start -->

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Jobs">
      <h1><span class="secnum">8.5.2</span>Workers are agents<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.WorkerSemantics.Jobs">#</a></span></span></h1>
      <p> (Clarification) Every worker implements an independent agent as defined above.  </p>
      <emu-note><span class="note">Note</span>
        <p> Thus the forward-progress guarantee of jobs also applies to workers.  </p>
      </emu-note>
    </emu-clause> <!-- jobs -->

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.LicenseToKill">
      <h1><span class="secnum">8.5.3</span>Curtail the license to kill<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.WorkerSemantics.LicenseToKill">#</a></span></span></h1>

      <p> (Compatible change) Workers may be killed by the browser
	only for specific reasons.  These reasons are TBD (TODO) but
	include evicting the owning page from the history and closing
	the owning page.  These reasons do not include workers that
	'run too long'.  </p>

      <emu-note><span class="note">Note</span>
        <p> Currently the WHATWG spec allows the browser to kill any worker at
          any time.  The purpose of the rule is probably a combination of the
          need to stop runaway scripts (without the normal slow-script dialog)
          and the need to remove workers once a page is evicted from the browser
          cache or a tab is closed.  However, the wording is overly broad.
          Also, common uses of workers for computation conflict with the ability
          to detect "runaway" agents:</p>

        <ul>
          <li> The worker may perform a genuinely long-running computation
          
          </li><li> The worker will have its own user-implemented "event" loop,
            communicating synchronously through shared memory; it will not use the
            browser's event loop
        
        </li></ul>
      </emu-note>

    </emu-clause> <!-- license to kill -->

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Introspection">
      <h1><span class="secnum">8.5.4</span>Termination detection<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.WorkerSemantics.Introspection">#</a></span></span></h1>
      <p> (Compatible(?) change) The worker object should have a read-only
	property called "state" whose value represents the state of the worker (eg
	a string naming the state).  One state might be "terminated", indicating
	the worker is dead.  </p>

      <emu-note><span class="note">Note 1</span>
        <p> There appears to be no way at present to directly determine whether
        a Worker has terminated.  </p>
      </emu-note>

      <emu-note><span class="note">Note 2</span>
        <p> Possible complementary mechanisms include throwing an exception when
          a message is sent to a terminated worker, and to send an error event to
          the creating agent when a worker is killed.  </p>
      </emu-note>

      <emu-note><span class="note">Note 3</span>
	<p> The spec here can be related back to the properties of the <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref>, specified
	  earlier.  </p>
      </emu-note>
    </emu-clause> <!-- introspection -->
  </emu-clause> <!-- worker semantics -->
  
  <emu-clause id="WebBrowserEmbedding.Termination">
    <h1><span class="secnum">8.6</span>Agent termination<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding.Termination">#</a></span></span></h1>

    <p>If a worker is terminated by a call to its terminate method while it is
      blocked in then the worker is first woken and then immediately terminated
      (the wakeup is not observable to code running in the worker).  </p>

    <emu-note><span class="note">Note 1</span>
      <p> (Spec draft note) Firefox supports close handlers that could in
	principle be used to clean up inconsistent state, but I think that's not in
	the HTML5 spec.  </p>
    </emu-note>

    <p>If a worker is terminated for any other reason, such as the user agent
      reloading or closing the window or frame, and the worker is blocked in a
      call to futexWait when it is terminated, then the worker is first woken
      and then immediately terminated (the wakeup is not observable to code
      running in the worker).</p>

    <emu-note><span class="note">Note 2</span>
      <p> (Spec draft note) After the running script has been terminated the
	worker's close handler(s) will be run as if the wait had not been
	aborted.</p>
    </emu-note>
  </emu-clause> <!-- termination -->

</emu-clause>
</body>
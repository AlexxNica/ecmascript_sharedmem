<!-- -*- indent-tabs-mode: nil -*-

     Process this file with ../format.sh to produce shmem.html.  See comments in that file.
-->
<!doctype html>
<meta charset="utf8">
<title>DOM/ECMAScript "Agents"</title>
<script src="https://bterlson.github.io/ecmarkup/ecmarkup.js"></script>
<link rel="stylesheet" href="https://bterlson.github.io/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">

<h1>DOM/ECMAScript "Agents"</h1>

<p> Early draft.  Revised: 2016-02-20.  lhansen@mozilla.com </p>

<emu-intro id="intro">
<h1>Introduction</h1>

<p> This is a companion spec to the Shared memory and Atomics specification
  ("SAB spec", for short).  The purpose of the present specification is to
  formalize what the SAB spec means when it refers to "agent", to place the
  runtime semantic operations that the SAB spec depends on on solid ground, and
  to hook "agent" into the ES6 spec at appropriate points (not very many). </p>

<p> This companion spec has two parts, one for the ECMAScript spec and one for
  the DOM/HTML spec.  The latter is a secondary concern to this spec's author. </p>

<p> Terminology: I'm going to use "agent" for the time being since that is what
  the SAB spec uses; C++ uses it too, for its similar concept.  "Vat" and
  "continent" would be OK too, I suggest we bikeshed a name later. </p>

<p> Obvious discussion items: </p>
<ul>
  <li> Is it OK to expose the <em>surrounding agent</em> in the way I've done
    here as an implicit container for the execution context machinery of the
    existing spec?  I don't think there's much room for confusion.

  <li> Do we need to expose semantic operations on agents, or is what we
    have good enough?  Operations could be: adding a job to an agent's
    queue; message send and receive (abstractly); introspection on the
    agent's state.

  <li> SharedArrayBuffer leaks a little bit into this spec but I've tried to
    keep that spec separate from this.  I could separate them even more if
    desired.

  <li> Also search for "TODO".
</ul>

<p> Relevant links: </p>
<ul>
  <li> <a href="https://github.com/tc39/ecmascript_sharedmem/issues/27">SAB spec Issue #27, overall issue bringing up realms, job queues, the appropriateness of any name, and other things</a>
  <li> <a href="https://github.com/tc39/ecmascript_sharedmem/issues/28">SAB spec Issue #28, about forward progress</a>
  <li> <a href="https://github.com/tc39/ecmascript_sharedmem/issues/55">SAB spec Issue #55, about partial failure</a>
  <li> <a href="https://github.com/tc39/ecma262/pull/226">Ecma 262 Issue #226, Domenic's "continents" proposal and discussion around it</a>
  <li> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4439.pdf">C++ paper on forward progress, not sure yet if this is the latest</a>
  <li> <a href="https://mail.mozilla.org/pipermail/es-discuss/2014-October/039985.html">Allen's explanation of how things hang together, and useful followups</a>
  <li> <a href="https://esdiscuss.org/topic/holy-mixed-metaphors-batman-was-event-loops-in-navigated-away-from-windows#content-2">More discussion of the name, notably the origin of "continent"</a>
</ul>

</emu-intro>

<!--
<emu-clause id="Overview">
  <h1>Overview (ES6 4)</h1>
  <emu-clause id="Overview.Overview">
    <h1>ECMAScript Overview (ES6 4.2)</h1>
    <p>In the third paragraph, include <b>SharedArrayBuffer</b> after <b>ArrayBuffer</b>.</p>
  </emu-clause>
  <emu-clause id="Overview.Terms">
    <h1>Terms and Definitions (ES6 4.3)</h1>
    <emu-clause id="Overview.Terms.Agent">
      <h1>Agent</h1>
      <p> The combination of an instance of an ECMAScript execution environment and the ECMAScript programs running within that environment. </p>
      <emu-note>
        <p> (Issue 27) This should be worded in terms of running 'jobs', and it needs to be broken out of Terms and Definitions and given a proper section, probably within ES6 section 8. </p>
      </emu-note>
    </emu-clause>
    <emu-clause id="Overview.Terms.AgentComm">
      <h1>Agent communication</h1>
      <p> Two agents are said to be able to communicate through shared
      memory if there can exist a Shared Data Block that can come to
      be referenced from both agents, not necessarily at the same
      time.  (Note this does not require the agents to have
      overlapping lifetimes.) </p>
    </emu-clause>
    <emu-clause id="Overview.Terms.Cluster">
      <h1>Agent cluster</h1>
      <p> A maximal set of agents that are able to communicate through shared memory. </p>
    </emu-clause>
    <emu-clause id="Overview.Terms.AgentEvent">
      <h1>Agent event</h1>
      <p> (TBD, but we're looking for something that captures an agent's observation of an external effect, or the causing of such observation in another agent.  In the Sharedmem spec these events are things like sending and receiving messages.) </p>
    </emu-clause>
    <emu-clause id="Overview.Terms.ProgramOrder">
      <h1>Program order</h1>
      <p> The order of steps within a single agent as determined by the language semantics </p>
    </emu-clause>
  </emu-clause>
</emu-clause>
-->

<emu-clause id="ExecutableCodeAndContexts">
  <h1>Executable Code and Execution Contexts (ES6 8)</h1>

  <emu-clause id="ExecutableCodeAndContexts.ExecutionContexts">
    <h1>Execution contexts (ES6 8.3)</h1>
    <p> Paragraph one: Change the last two sentences to the following (changes bolded): </p>
    <blockquote>
      At any point in time, there is at most one execution context <b>per
      agent</b> that is actually executing code. This is known as
      the <b>agent's</b> <em>running execution context</em>.  <b>All references
      to the <em>running execution context</em> in this specification 
      reference the running execution context of the <em>surrounding agent</em>.</b>
    </blockquote>
  </emu-clause> <!-- execution contexts -->

  <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues">
    <h1>Jobs and Job Queues (ES6 8.4)</h1>

    <p> In the paragraph between tables 25 and table 26, append the following
      sentence: </p>

    <blockquote>
      <b> Each agent has its own set of named job queues.  All references to a
	named job queue in this specification, such as within the EnqueueJob and NextJob semantic
	functions, reference the named queue in the <em>surrounding agent</em>.</b>
    </blockquote>

    <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues.Progress">
      <h1>Forward Progress Guarantees</h1>

      <p>Implementations must ensure that all unblocked jobs eventually make
	progress. </p>

      <emu-note>
        <p>(Issue 28) This section may be formalized at least partly in the
          terms of the C++ working paper on forward progress, see the referenced
          issue, or it may be left as-is.  An ES6 execution thread is most plausibly a
          'Concurrent agent' in the terms of that paper. </p>
      </emu-note>
    </emu-clause> <!-- progress -->
  </emu-clause> <!-- jobs and job queues -->

  <emu-clause id="ExecutableCodeAndContexts.Agent">
    <h1>Agents (NEW)</h1>

    <p> An <em>agent</em> comprises a set of ECMAScript execution contexts, an
      execution context stack, a running execution context, a set of named job
      queues, a set of attributes, and an executing thread.  Except for the
      executing thread, the constituents of an agent belong exclusively to that
      agent. </p>

    <p> An agent's executing thread executes the jobs in the agent's job queues
      on the agent's execution contexts independently of other agents.  An
      execution thread may be used as the execution thread by multiple agents
      only if none of the agents sharing the thread have a <b>canBlock</b>
      attribute that is ~true~. </p>

    <emu-note>
      <p> This is a case of bowing to reality, since browsers do share the main
	thread across tabs in the same process and will prohibit main-thread
	code from blocking.  Forward progress is guaranteed by implementations
	that set a time limit on how long the main thread can execute in a tab
	without returning to its event loop. </p>
    </emu-note>

    <p> While an agent's executing thread executes the jobs in the agent's job
      queues, the agent is the <em>surrounding agent</em> for the code in those
      jobs.  The code uses the surrounding agent to access the specification
      level execution objects held within the agent: the <em>running execution
      context</em>, the execution context stack, the named job queues, and the
      agent attributes. </p>

    <p> The set of per-agent attributes is at least this:</p>
    <ul>
      <li> <b> littleEndian </b>: the default value computed for
	the <em>isLittleEndian</em> parameter when it is needed by E262
	algorithms GetValueFromBuffer and SetValueInBuffer.  The choice is
	implementation dependent and should be the alternative that is most
	efficient for the implementation.  Set at agent creation time; constant.
      <li> <b> canBlock </b>: determines whether the agent can block (to wait for an
	external unblock event) or not.  Set at agent creation time; constant.
      <li> <b> state </b>: the state of the agent.  It can take on the following symbolic
	values:
	<ul>
	  <li> <b> Creating </b>: agent is in the process of being created
	  <li> <b> Waiting </b>: agent is waiting for work to appear in a queue
	  <li> <b> Running </b>: agent is processing a job
	  <li> <b> Blocked </b>: agent has put itself to sleep
	  <li> <b> Destroying </b>: agent is in the process of being destroyed
	  <li> <b> Destroyed </b>: agent has been destroyed
	</ul>
      <li> (The SAB spec will add several constant attributes: <b>signifier</b>, <b>lockFree1</b>,
	<b>lockFree2</b>, <b>lockFree4</b>)
    </ul>

    <emu-note>
      <p> (Spec draft note) The <b>state</b> values are not yet being used, but will
	be used by to-be-drafted semantic functions in the SAB spec, and may be used
	here to discuss agent termination. </p>
    </emu-note>

    <p> An agent is a specification mechanism and need not correspond to any
      particular artefact of an ECMAScript implementation.  It is
      embedding-dependent whether ECMAScript code can directly access or observe
      an agent.  If an agent has a value representation within an ECMAScript
      program it is as a host object value. </p>

    <emu-note>
      <p> (Spec draft note) The SpiderMonkey shell allows workers to be created
	but has no JS representation for workers.  SharedArrayBuffers are shared
	not through messages but through a global mailbox mechanism. </p>

      <p> Also, the MessagePort mechanism in HTML5 allows workers to be passed
	around implicitly; it is possible to communicate with a worker without
	having a direct representation for the worker, only for a channel that
	the worker listens on. </p>
    </emu-note>

  </emu-clause> <!-- agent -->

  <emu-clause id="ExecutableCodeAndContexts.AgentCluster">
    <h1>Agent Clusters (NEW)</h1>

    <p> An <em>agent cluster</em> is a maximal time-varying set of agents that
      can communicate by operating on shared memory.  The agent cluster also has
      a set of attributes. </p>

    <p> Every agent belongs to exactly one agent cluster. </p>

    <emu-note>
      <p> (Spec draft note) The agent cluster notion is needed by the SAB spec
	to talk about memory ordering.  It doesn't have to be part of the agent
	spec, but I'm exposing it here in case there are other benefits to be
	had from it. </p>

      <p> Agent clusters comprise agents that are all "on the same machine".
	There may be agents that can communicate by message passing that cannot
	share memory; they are never in the same cluster. </p>
    </emu-note>

    <emu-note>
      <p> Observe that the agents in a cluster need not all be alive at some
	point in time, <b>A</b> can share a buffer with <b>B</b>, after
	which <b>A</b> terminates and <b>B</b> creates <b>C</b> and shares a
	buffer with <b>C</b>.  Observe also that the two buffers need not be the
	same. </p>
    </emu-note>

    <emu-note>
      <p> When an agent in an agent cluster shares a SharedArrayBuffer with an
	agent not in that agent cluster, then the two agents' agent clusters are
	merged and the resulting agent cluster becomes the agent cluster of all
	of the agents in the new agent cluster.  The agent cluster shrinks when
	one of the agents in the agent cluster terminates or drops the last
	reference to the last buffer that keeps it in the cluster. </p>
    </emu-note>

    <p> The agent cluster's set of attributes includes: </p>
    <ul>
      <li> (The SAB spec will add several, notably <b>futexMutex</b>.)
    </ul>

    <p> All agents within a cluster must have the same value for
      their <b>littleEndian</b> attributes. </p>

    <emu-note>
      <p> (Spec draft note) Is the restriction on <b>littleEndian</b> overreach?
	It seemed reasonable at the time, but on some architectures it's
	possible for different processes to have different endianness.  The rule
	precludes sharing memory among such processes, in any ECMAScript
	implementation. </p>
    </emu-note>

    <p> An agent cluster is a specification mechanism and need not correspond to
      any particular artefact of an ECMAScript implementation.  It is
      embedding-dependent whether ECMAScript code can directly access or observe
      an agent cluster.  If an agent cluster has a value representation within
      an ECMAScript program it is as a host object value. </p>

    <emu-note>
      <p> (Spec draft note) Should an agent cluster be an object in an
	implementation then it may actually expose GC, since it may become
	detectable that an agent cluster has shrunk.  We can fix that by saying
	that an agent cluster can only grow, for example, or by outlawing agent
	cluster reification, or by prohibiting the type of introspection that
	discovers shrinkage. </p>
    </emu-note>

  </emu-clause> <!-- agent cluster -->

  <emu-clause id="ExecutableCodeAndContexts.AgentCommunication">
    <h1>Inter-Agent Communication (NEW)</h1>

    <p> Programs within different agents may communicate by unspecified means.
      With the exception of the backing memory for ~SharedArrayBuffer~ objects
      this communication cannot cause any ECMAScript object memory that is
      mutable in any agent to become shared between agents, and the ECMAScript
      implementation is not required to preserve object identity if an object
      value is sent from one agent to another and back. </p>

    <p> A program within an agent may communicate an ArrayBuffer to a program
      within another agent and in doing so cause the ArrayBuffer to become
      detached in the sending agent. </p>

    <p> An agent may at any time send a communication to another agent.  If the
      receiving agent needs to create a job to handle that communication it will
      add the job to its job queues at an implementation-specific time. </p>

    <emu-note>
      <p> (Spec draft note) Some overlap here with prose in ES6 8.4.  The
	purpose of the preceding paragraph is to give job execution the chance
	to take priority over handling external events. </p>
    </emu-note>

  </emu-clause> <!-- inter-agent communication -->

  <emu-clause id="ExecutableCodeAndContexts.ExternalSuspension">
    <h1>External suspension of agents (NEW)</h1>

    <p> An embedding may suspend and wake agents without the agents' knowledge.  If it does that, then: </p>
    <ul>
      <li> This must not be detectable to the agents and
      <li> All agents within the agent cluster of any suspended agent must be suspended together
    </ul>

    <emu-note>
      <p> (Spec draft note) The purpose of that point is to avoid deadlocks as
	pages are pushed into the window history, for example.  It creates an
	interesting conundrum for shared workers and service workers, since
	they would be part of the agent cluster if memory can be shared with
	them but would normally not be suspended when the page goes into the
	history.  However, this is one of the several good reasons not to
	allow memory to be shared with shared workers and service workers, see
	the SAB spec for more. </p>
    </emu-note>

  </emu-clause> <!-- external suspension -->

  <emu-clause id="ExecutableCodeAndContexts.ExternalTermination">
    <h1>External termination of agents (NEW)</h1>

    <p> An embedding may terminate agents without the agents' knowledge.  If it does that, then: </p>

    <p> <b>TODO</b> </p>

    <emu-note>
      <p> The reasons for termination include resource exhaustion and embedding-specific agent management. </p>
    </emu-note>
    
  </emu-clause> <!-- external termination -->

</emu-clause> <!-- executable code and contexts -->

<emu-clause id="StructuredData">
  <h1>Structured Data (ES6 24)</h1>

  <emu-clause id="StructuredData.ArrayBuffer">
    <h1>ArrayBuffer Objects (ES6 24.1)</h1>

    <emu-clause id="StructuredData.ArrayBuffer.abstract">
      <h1>Abstract Operations for ArrayBuffer (ES6 24.1.1)</h1>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" aoid="GetValueFromBuffer">
        <h1>GetValueFromBuffer( arrayBuffer, byteIndex, type [, isLittleEndian] ) (ES6 24.1.1.5)</h1>
        <p> Replace step 7 of this algorithm with the following:</p>
        <ul>
	  <li>  if _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the <b>isLittleEndian</b> attribute of
	    the <em>surrounding agent</em>.
        </ul>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.SetValueInBuffer" aoid="SetValueInBuffer">
        <h1>SetValueInBuffer( arrayBuffer, byteIndex, type, value [, isLittleEndian] ) (ES6 24.1.1.6)</h1>
        <p> Replace step 8 of this algorithm with the following:</p>
        <ul>
	  <li>  if _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the <b>isLittleEndian</b> attribute of
	    the <em>surrounding agent</em>.
        </ul>
      </emu-clause>
      
    </emu-clause> <!-- abstract ops -->
  </emu-clause> <!-- ArrayBuffer -->
</emu-clause> <!-- structured data -->

<emu-clause id="WebBrowserEmbedding">
  <h1>Web browser embedding (for the HTML/DOM spec)</h1>

  <emu-clause id="WebBrowserEmbedding.Agents">
    <h1>Agent mapping</h1>
    <p> In a web browser setting, the <em>agents</em> comprise a document's main
      thread environment and worker thread environments. </p>

    <p> Browsers will typically let main-thread agents
      have <b>canBlock</b>=false.  Browsers that support several tabs within the
      same content process may share a single agent execution thread across all
      the tabs in that case (Firefox does). </p>

    <p> Agents are represented to ES programs as Worker objects.  There is no
      representation of agent clusters.  Agents communicate (in the sense of the
      Inter-Agent Communication section) by messages on message channels,
      including on the implicit channel created between a parent and its
      child.  </p>

  </emu-clause> <!-- agents -->
  
  <emu-clause id="WebBrowserEmbedding.WorkerSemantics">
    <h1>Clarifications and changes to Web Worker semantics</h1>

    <emu-note>
      <p> Several of these issues have been reported as bugs against the WHATWG
      spec, <a href='https://www.w3.org/Bugs/Public/show_bug.cgi?id=29039'>see
      this bug report</a>. </p>
    </emu-note>

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Start">
      <h1>Actions to start a worker</h1>
      <p> (Clarification) The only action required to start a worker is to call
	"new Worker()". </p>

      <emu-note>
	<p> (Spec draft note) Firefox requires a trip through the event loop
	  to start the worker.  I'm told this won't be fixed, spec or no spec. </p>

	<p> The current state is a deadlock hazard.  If one worker creates
	  another and then blocks on a futex waiting for the new worker to
	  unblock it, the workers may deadlock since the new one may not have
	  been created.  The hazard is reduced by (a) prohibiting blocking on
	  the main thread and (b) either disallowing nested workers or not
	  requiring workers to return to their event loops to get a nested
	  worker started. </p>
      </emu-note>

      <p> (Compatible change) If a worker cannot be started for reasons of
	resource exhaustion (notably, no threads available, including arbitrary
	implementation limits on the number of threads) then an error must be
	reported in some manner TBD (TODO). </p>

      <emu-note>
        <p> (Spec draft note) In current Firefox, there is a per-domain limit on
          the number of workers.  An attempt to create a worker will silently
          not start the worker if the limit has been reached; the worker will be
          queued and started when another worker has terminated.  Again, this
          creates deadlock hazards. </p>

        <p> There are other error situations during worker startup that can't
          necessarily be signaled synchronously, notably, a load error on the
          URL.  Those have to be signaled via an event callback, or the creating
          agent must poll the state of the worker to see if it enters an error
          state (see more below on the state).  A callback is probably cleanest,
          but we'll want the state variable anyway, so maybe both. </p>
      </emu-note>
    </emu-clause> <!-- start -->

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Jobs">
      <h1>Workers are agents</h1>
      <p> (Clarification) Every worker implements an independent agent as defined above. </p>
      <emu-note>
        <p> Thus the forward-progress guarantee of jobs also applies to workers. </p>
      </emu-note>
    </emu-clause> <!-- jobs -->

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.LicenseToKill">
      <h1>Curtail the license to kill</h1>

      <p> (Compatible change) Workers may be killed by the browser only for
	specific reasons.  These reasons are TBD (TODO) but include evicting the owning
	page from the history and closing the owning page.  These reasons do not
	include workers that 'run too long'. </p>

      <emu-note>
        <p> Currently the WHATWG spec allows the browser to kill any worker at
          any time.  The purpose of the rule is probably a combination of the
          need to stop runaway scripts (without the normal slow-script dialog)
          and the need to remove workers once a page is evicted from the browser
          cache or a tab is closed.  However, the wording is overly broad.
          Also, common uses of workers for computation conflict with the ability
          to detect "runaway" agents:</p>

        <ul>
          <li> The worker may perform a genuinely long-running computation
          <li> The worker will have its own user-implemented "event" loop,
            communicating synchronously through shared memory; it will not use the
            browser's event loop
        </ul>
      </emu-note>
    </emu-clause> <!-- license to kill -->

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Introspection">
      <h1>Termination detection</h1>
      <p> (Compatible(?) change) The worker object should have a read-only
	property called "state" whose value represents the state of the worker (eg
	a string naming the state).  One state might be "terminated", indicating
	the worker is dead. </p>

      <emu-note>
        <p> There appears to be no way at present to directly determine whether
        a Worker has terminated. </p>
      </emu-note>

      <emu-note>
        <p> Possible complementary mechanisms include throwing an exception when
          a message is sent to a terminated worker, and to send an error event to
          the creating agent when a worker is killed. </p>
      </emu-note>

      <emu-note>
	<p> The spec here can be related back to the agent attributes, specified
	  earlier. </p>
      </emu-note>
    </emu-clause> <!-- introspection -->
  </emu-clause> <!-- worker semantics -->
  
  <emu-clause id="WebBrowserEmbedding.Termination">
    <h1>Agent termination</h1>

    <p>If a worker is terminated by a call to its terminate method while it is
      blocked in then the worker is first woken and then immediately terminated
      (the wakeup is not observable to code running in the worker). </p>

    <emu-note>
      <p> (Spec draft note) Firefox supports close handlers that could in
	principle be used to clean up inconsistent state, but I think that's not in
	the HTML5 spec. </p>
    </emu-note>

    <p>If a worker is terminated for any other reason, such as the user agent
      reloading or closing the window or frame, and the worker is blocked in a
      call to futexWait when it is terminated, then the worker is first woken
      and then immediately terminated (the wakeup is not observable to code
      running in the worker).</p>

    <emu-note>
      <p> (Spec draft note) After the running script has been terminated the
	worker's close handler(s) will be run as if the wait had not been
	aborted.</p>
    </emu-note>
  </emu-clause> <!-- termination -->

</emu-clause> <!-- browser embedding -->


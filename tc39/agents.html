<!-- -*- indent-tabs-mode: nil -*-

     Process this file with ../format.sh to produce shmem.html.  See comments in that file.
-->
<!doctype html>
<meta charset="utf8">
<title>DOM/ECMAScript "Agents"</title>
<script src="https://bterlson.github.io/ecmarkup/ecmarkup.js"></script>
<link rel="stylesheet" href="https://bterlson.github.io/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">

<h1>DOM/ECMAScript "Agents"</h1>

<p> Second draft.  Revised: 2016-03-09.  lhansen@mozilla.com </p>

<emu-intro id="intro">
<h1>Introduction</h1>

<p> This is a companion spec to the Shared memory and Atomics specification
  ("SAB spec", for short).  The purpose of the present specification is to
  formalize what the SAB spec means when it refers to "agent", to place the
  runtime semantic operations that the SAB spec depends on on solid ground, and
  to hook "agent" into the ES6 spec at appropriate points (not very many). </p>

<p> This companion spec has two parts, one for the ECMAScript spec and one for
  the DOM/HTML spec.  The latter is a secondary concern to this spec's author. </p>

<p> Terminology: I'm going to use "agent" for the time being since that is what
  the SAB spec uses; C++ uses it too, for its similar concept.  "Vat" and
  "continent" would be OK too, I suggest we bikeshed a name later. </p>

<p> Obvious discussion items: </p>
<ul>
  <li> Is it OK to expose the <em>surrounding agent</em> in the way I've done
    here as an implicit container for the execution context machinery of the
    existing spec?  I don't think there's much room for confusion.

  <li> Do we need to expose semantic operations on agents, or is what we
    have good enough?  Operations could be: adding a job to an agent's
    queue; message send and receive (abstractly); introspection on the
    agent's state.

  <li> SharedArrayBuffer leaks a little bit into this spec but I've tried to
    keep that spec separate from this.  I could separate them even more if
    desired.

  <li> Also search for "TODO".
</ul>

<p> Relevant links: </p>
<ul>
  <li> <a href="https://github.com/tc39/ecmascript_sharedmem/issues/27">SAB spec Issue #27, overall issue bringing up realms, job queues, the appropriateness of any name, and other things</a>
  <li> <a href="https://github.com/tc39/ecmascript_sharedmem/issues/28">SAB spec Issue #28, about forward progress</a>
  <li> <a href="https://github.com/tc39/ecmascript_sharedmem/issues/55">SAB spec Issue #55, about partial failure</a>
  <li> <a href="https://github.com/tc39/ecma262/pull/226">Ecma 262 Issue #226, Domenic's "continents" proposal and discussion around it</a>
  <li> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4439.pdf">C++ paper on forward progress, not sure yet if this is the latest</a>
  <li> <a href="https://mail.mozilla.org/pipermail/es-discuss/2014-October/039985.html">Allen's explanation of how things hang together, and useful followups</a>
  <li> <a href="https://esdiscuss.org/topic/holy-mixed-metaphors-batman-was-event-loops-in-navigated-away-from-windows#content-2">More discussion of the name, notably the origin of "continent"</a>
</ul>

<p>Changelog:</p>
<ul>
  <li> 2016-03-09 -- Agent termination semantics clarified.  Clarified that an Agent is an HTML event loop, removed some redundant prose.
  <li> 2016-03-04 -- Changed the definition of agent clusters back to the old one where a cluster is monotonically growing.  Integrated several comments and cleaned up.  Removed the contents of the section on agent suspension (by moving it into other sections).
  <li> 2016-03-04 -- Removed the contents of the section on inter-agent communication because it was not relevant to this spec.
  <li> 2016-03-04 -- Removed wording about the kinds of objects that agents and agent clusters could be reified as.
  <li> 2016-03-03 -- Added reference to Issue 39
</ul>

</emu-intro>

<!--
<emu-clause id="Overview">
  <h1>Overview (ES6 4)</h1>
  <emu-clause id="Overview.Overview">
    <h1>ECMAScript Overview (ES6 4.2)</h1>
    <p>In the third paragraph, include <b>SharedArrayBuffer</b> after <b>ArrayBuffer</b>.</p>
  </emu-clause>
  <emu-clause id="Overview.Terms">
    <h1>Terms and Definitions (ES6 4.3)</h1>
    <emu-clause id="Overview.Terms.Agent">
      <h1>Agent</h1>
      <p> The combination of an instance of an ECMAScript execution environment and the ECMAScript programs running within that environment. </p>
      <emu-note>
        <p> (Issue 27) This should be worded in terms of running 'jobs', and it needs to be broken out of Terms and Definitions and given a proper section, probably within ES6 section 8. </p>
      </emu-note>
    </emu-clause>
    <emu-clause id="Overview.Terms.AgentComm">
      <h1>Agent communication</h1>
      <p> Two agents are said to be able to communicate through shared
      memory if there can exist a Shared Data Block that can come to
      be referenced from both agents, not necessarily at the same
      time.  (Note this does not require the agents to have
      overlapping lifetimes.) </p>
    </emu-clause>
    <emu-clause id="Overview.Terms.Cluster">
      <h1>Agent cluster</h1>
      <p> A maximal set of agents that are able to communicate through shared memory. </p>
    </emu-clause>
    <emu-clause id="Overview.Terms.AgentEvent">
      <h1>Agent event</h1>
      <p> (TBD, but we're looking for something that captures an agent's observation of an external effect, or the causing of such observation in another agent.  In the Sharedmem spec these events are things like sending and receiving messages.) </p>
    </emu-clause>
    <emu-clause id="Overview.Terms.ProgramOrder">
      <h1>Program order</h1>
      <p> The order of steps within a single agent as determined by the language semantics </p>
    </emu-clause>
  </emu-clause>
</emu-clause>
-->

<emu-clause id="ExecutableCodeAndContexts">
  <h1>Executable Code and Execution Contexts (ES6 8)</h1>

  <emu-clause id="ExecutableCodeAndContexts.ExecutionContexts">
    <h1>Execution contexts (ES6 8.3)</h1>
    <p> Paragraph one: Change the last two sentences to the following (changes bolded): </p>
    <blockquote>
      At any point in time, there is at most one execution context <b>per
      agent</b> that is actually executing code. This is known as
      the <b>agent's</b> <em>running execution context</em>.  <b>All references
      to the <em>running execution context</em> in this specification 
      reference the running execution context of the <em>surrounding agent</em>.</b>
    </blockquote>
  </emu-clause> <!-- execution contexts -->

  <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues">
    <h1>Jobs and Job Queues (ES6 8.4)</h1>

    <p> In the paragraph between tables 25 and table 26, append the following
      sentence: </p>

    <blockquote>
      <b> Each agent has its own set of named job queues.  All references to a
	named job queue in this specification, such as within the EnqueueJob and NextJob semantic
	functions, reference the named queue in the <em>surrounding agent</em>.</b>
    </blockquote>

    <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues.Progress">
      <h1>Forward Progress Guarantees</h1>

      <p>Implementations must ensure that all unblocked jobs eventually make
	progress. </p>

      <emu-note>
        <p>(Issue 28) This section may be formalized at least partly in the
          terms of the C++ working paper on forward progress, see the referenced
          issue, or it may be left as-is.  An ES6 execution thread is most plausibly a
          'Concurrent agent' in the terms of that paper. </p>
      </emu-note>
    </emu-clause> <!-- progress -->
  </emu-clause> <!-- jobs and job queues -->

  <emu-clause id="ExecutableCodeAndContexts.Agent">
    <h1>Agents (NEW)</h1>

    <p> An <em>agent</em> comprises a set of ECMAScript execution contexts, an
      execution context stack, a running execution context, a set of named job
      queues, a set of attributes, and an executing thread.  Except for the
      executing thread, the constituents of an agent belong exclusively to that
      agent. </p>

    <p> An agent's executing thread executes the jobs in the agent's job queues
      on the agent's execution contexts independently of other agents.  An
      execution thread may be used as the execution thread by multiple agents
      only if none of the agents sharing the thread have a <b>canBlock</b>
      attribute that is ~true~. </p>

    <emu-note>
      <p> This is a case of bowing to reality, since browsers do share the main
	thread across tabs in the same process and will prohibit main-thread
	code from blocking.  Forward progress is guaranteed by implementations
	that set a time limit on how long the main thread can execute in a tab
	without returning to its event loop. </p>
    </emu-note>

    <p> While an agent's executing thread executes the jobs in the agent's job
      queues, the agent is the <em>surrounding agent</em> for the code in those
      jobs.  The code uses the surrounding agent to access the specification
      level execution objects held within the agent: the <em>running execution
      context</em>, the execution context stack, the named job queues, and the
      agent attributes. </p>

    <p> The set of per-agent attributes is at least this:</p>
    <ul>
      <li> <b> littleEndian </b>: the default value computed for
	the <em>isLittleEndian</em> parameter when it is needed by E262
	algorithms GetValueFromBuffer and SetValueInBuffer.  The choice is
	implementation dependent and should be the alternative that is most
	efficient for the implementation.  Set at agent creation time; constant.
      <li> <b> canBlock </b>: determines whether the agent can block (to wait for an
	external unblock event) or not.  Set at agent creation time; constant.
      <li> <b> state </b>: the state of the agent.  It can take on the following symbolic
	values:
	<ul>
	  <li> <b> Creating </b>: agent is in the process of being created
	  <li> <b> Waiting </b>: agent is waiting for work to appear in a queue
	  <li> <b> Running </b>: agent is processing a job
	  <li> <b> Blocked </b>: agent has put itself to sleep
	  <li> <b> Destroying </b>: agent is in the process of being destroyed
	  <li> <b> Destroyed </b>: agent has been destroyed
	</ul>
      <li> <b>signifier</b>: an identifier for the agent.
      <li> <b>lockFree1</b> determines whether atomic operations on shared memory with one-byte granularity are lock-free.
      <li> <b>lockFree2</b> determines whether atomic operations on shared memory with two-byte granularity are lock-free.
      <li> <b>lockFree4</b> determines whether atomic operations on shared memory with four-byte granularity are lock-free.
    </ul>

    <emu-note>
      <p> (Spec draft note) The <b>state</b> values are not yet being used, but will
	be used by to-be-drafted semantic functions in the SAB spec, and may be used
	here to discuss agent termination. </p>
    </emu-note>

    <p> An agent is a specification mechanism and need not correspond to any
      particular artefact of an ECMAScript implementation. </p>

    <emu-note>
      <p> There are several ways in which agents could be meaningful
        without having a direct representation. </p>

      <p> The standalone shell for Firefox's JS engine allows workers
	to be created but has no JS representation for those workers.
	SharedArrayBuffers are shared not through messages but through
	a global mailbox mechanism. </p>

      <p> The MessagePort mechanism in HTML5 allows workers to be
	passed around implicitly; it is possible to communicate with a
	worker without having a direct representation for the worker,
	only for a channel that the worker listens on. </p>
    </emu-note>

  </emu-clause> <!-- agent -->

  <emu-clause id="ExecutableCodeAndContexts.AgentCluster">
    <h1>Agent Clusters (NEW)</h1>

    <p> An <em>agent cluster</em> is a maximal set of agents that can
      communicate by operating on shared memory. </p>

    <emu-note>
      <p> Programs within different agents may share memory by
        unspecified means.  At a minimum, the backing memory for
        ~SharedArrayBuffer~ objects can be shared among the agents in
        the cluster. </p>

      <p> There may be agents that can communicate by message passing
	that cannot share memory; they are never in the same
	cluster. </p>
    </emu-note>

    <p> Every agent belongs to exactly one agent cluster. </p>

    <emu-note>
      <p> The agents in a cluster need not all be alive at some
	particular point in time.  If agent <b>A</b> creates another
	agent <b>B</b>, after which <b>A</b> terminates and <b>B</b>
	creates agent <b>C</b>, the three agents are in the same
	cluster if <b>A</b> could share some memory with <b>B</b>
	and <b>B</b> could share some memory with <b>C</b>. </p>
    </emu-note>

    <p> All agents within a cluster must have the same value for
      their <b>littleEndian</b> attributes. </p>

    <emu-note>
      <p> (Spec draft note) Is the restriction on <b>littleEndian</b> overreach?
	It seemed reasonable at the time, but on some architectures it's
	possible for different processes to have different endianness.  The rule
	precludes sharing memory among such processes, in any ECMAScript
	implementation. </p>
    </emu-note>

    <p> All agents within a cluster must have the same values for
      their <b>lockFree1</b> attributes; the same values for
      their <b>lockFree2</b> attributes; and the same values for
      their <b>lockFree4</b> attributes. </p>

    <p> All agents within a cluster must have different values for
      their <b>signifier</b> attributes. </p>

    <p> An agent cluster is a specification mechanism and need not correspond to
      any particular artefact of an ECMAScript implementation. </p>

    <p> An embedding may suspend and wake an agent without the agent's
      knowledge or cooperation.  If the embedding does so, it must
      suspend and wake all agents in an agent cluster together. </p>

    <emu-note>
      <p> The purpose of that restriction is to avoid a situation
        where a worker deadlocks or starves because another agent has
        been suspended.  For example, if a DOM SharedWorker shares
        memory with a regular worker, and the regular worker is
        suspended while it holds a lock (because the web page the
        regular worker is in is pushed into the window history), and
        the SharedWorker tries to acquire the lock, then the
        SharedWorker will be blocked until the regular worker wakes up
        again, if ever.  Meanwhile other workers trying to access the
        SharedWorker from other web pages will starve. </p>

      <p> The implication of the restriction is that it will not be
        possible to share memory between agents that don't belong to
        the same suspend/wake collective within the embedding. </p>

      <p> (<a href="https://github.com/tc39/ecmascript_sharedmem/issues/39">Issue 39</a>) That, in
        turn, places interesting demands on the structured clone algorithm in web browsers. </p>
    </emu-note>
        
    <p> An embedding may terminate an agent without any
      of the agent's cluster's other agents' prior knowledge or cooperation.  If the
      embedding terminates an agent it must make it possible for any other agents
      in the terminated agent's cluster that continue to run to discover the
      termination. </p>

    <emu-note>
      <p> Examples of that type of termination are: operating systems
        or users terminating agents that are running in separate
        processes; the embedding itself terminating an agent that is
        running in-process with the other agents when per-agent
        resource accounting indicates that the agent is runaway. </p>
    </emu-note>

    <emu-note>
      <p> (Spec draft note) The requirement that the embedding must
        make the termination known to other agents is actually very
        soft.  The shared memory spec will require that detecing
        termination creates the necessary happens-before edge in the
        memory ordering, which is a tougher requirement.  The web
        platform provides nothing at the moment to detect
        termination. </p>

      <p> In current browsers, given that dedicated workers are
        in-process, an agent cluster will normally terminate en masse,
        so the requirement is trivially satisfied for now. </p>
    </emu-note>

  </emu-clause> <!-- agent cluster -->

  <emu-clause id="ExecutableCodeAndContexts.AgentCommunication">
    <h1>Inter-Agent Communication (NEW)</h1>

    <p> (Removed; section kept to avoid changing the numbering) </p>

  </emu-clause> <!-- inter-agent communication -->

  <emu-clause id="ExecutableCodeAndContexts.ExternalSuspension">
    <h1>External suspension of agents (NEW)</h1>

    <p> (Integrated into the Agent Clusters section; section kept to avoid changing the numbering) </p>

  </emu-clause> <!-- external suspension -->

  <emu-clause id="ExecutableCodeAndContexts.ExternalTermination">
    <h1>External termination of agents (NEW)</h1>

    <p> (Integrated into the Agent Clusters section; section kept to avoid changing the numbering) </p>
    
  </emu-clause> <!-- external termination -->

</emu-clause> <!-- executable code and contexts -->

<emu-clause id="StructuredData">
  <h1>Structured Data (ES6 24)</h1>

  <emu-clause id="StructuredData.ArrayBuffer">
    <h1>ArrayBuffer Objects (ES6 24.1)</h1>

    <emu-clause id="StructuredData.ArrayBuffer.abstract">
      <h1>Abstract Operations for ArrayBuffer (ES6 24.1.1)</h1>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" aoid="GetValueFromBuffer">
        <h1>GetValueFromBuffer( arrayBuffer, byteIndex, type [, isLittleEndian] ) (ES6 24.1.1.5)</h1>
        <p> Replace step 7 of this algorithm with the following:</p>
        <ul>
	  <li>  if _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the <b>isLittleEndian</b> attribute of
	    the <em>surrounding agent</em>.
        </ul>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.SetValueInBuffer" aoid="SetValueInBuffer">
        <h1>SetValueInBuffer( arrayBuffer, byteIndex, type, value [, isLittleEndian] ) (ES6 24.1.1.6)</h1>
        <p> Replace step 8 of this algorithm with the following:</p>
        <ul>
	  <li>  if _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the <b>isLittleEndian</b> attribute of
	    the <em>surrounding agent</em>.
        </ul>
      </emu-clause>
      
    </emu-clause> <!-- abstract ops -->
  </emu-clause> <!-- ArrayBuffer -->
</emu-clause> <!-- structured data -->

<emu-clause id="WebBrowserEmbedding">
  <h1>Web browser embedding (for the HTML/DOM spec)</h1>

  <emu-clause id="WebBrowserEmbedding.Agents">
    <h1>Agent mapping</h1>

    <p> In a web browser an <em>agent</em> is an
      HTML <em>event loop</em> <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">[here]</a>.  </p>

    <p> Browsers will typically let agents that run on the browser's main thread 
      have <b>canBlock</b>=false.  Browsers that support several tabs within the
      same content process may share a single agent execution thread across all
      the tabs in that case (Firefox does). </p>

  </emu-clause> <!-- agents -->
  
  <emu-clause id="WebBrowserEmbedding.WorkerSemantics">
    <h1>Clarifications and changes to Web Worker semantics</h1>

    <emu-note>
      <p> Several of these issues have been reported as bugs against the WHATWG
      spec, <a href='https://www.w3.org/Bugs/Public/show_bug.cgi?id=29039'>see
      this bug report</a>. </p>
    </emu-note>

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Start">
      <h1>Actions to start a worker</h1>
      <p> (Clarification) The only action required to start a worker is to call
	"new Worker()". </p>

      <emu-note>
	<p> (Spec draft note) Firefox requires a trip through the event loop
	  to start the worker.  I'm told this won't be fixed, spec or no spec. </p>

	<p> The current state is a deadlock hazard.  If one worker creates
	  another and then blocks on a futex waiting for the new worker to
	  unblock it, the workers may deadlock since the new one may not have
	  been created.  The hazard is reduced by (a) prohibiting blocking on
	  the main thread and (b) either disallowing nested workers or not
	  requiring workers to return to their event loops to get a nested
	  worker started. </p>
      </emu-note>

      <p> (Compatible change) If a worker cannot be started for reasons of
	resource exhaustion (notably, no threads available, including arbitrary
	implementation limits on the number of threads) then an error must be
	reported in some manner TBD (TODO). </p>

      <emu-note>
        <p> (Spec draft note) In current Firefox, there is a per-domain limit on
          the number of workers.  An attempt to create a worker will silently
          not start the worker if the limit has been reached; the worker will be
          queued and started when another worker has terminated.  Again, this
          creates deadlock hazards. </p>

        <p> There are other error situations during worker startup that can't
          necessarily be signaled synchronously, notably, a load error on the
          URL.  Those have to be signaled via an event callback, or the creating
          agent must poll the state of the worker to see if it enters an error
          state (see more below on the state).  A callback is probably cleanest,
          but we'll want the state variable anyway, so maybe both. </p>
      </emu-note>
    </emu-clause> <!-- start -->

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Jobs">
      <h1>Workers are agents</h1>
      <p> (Clarification) Every worker implements an independent agent as defined above. </p>
      <emu-note>
        <p> Thus the forward-progress guarantee of jobs also applies to workers. </p>
      </emu-note>
    </emu-clause> <!-- jobs -->

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.LicenseToKill">
      <h1>Curtail the license to kill</h1>

      <p> (Compatible change) Workers may be killed by the browser only for
	specific reasons.  These reasons are TBD (TODO) but include evicting the owning
	page from the history and closing the owning page.  These reasons do not
	include workers that 'run too long'. </p>

      <emu-note>
        <p> Currently the WHATWG spec allows the browser to kill any worker at
          any time.  The purpose of the rule is probably a combination of the
          need to stop runaway scripts (without the normal slow-script dialog)
          and the need to remove workers once a page is evicted from the browser
          cache or a tab is closed.  However, the wording is overly broad.
          Also, common uses of workers for computation conflict with the ability
          to detect "runaway" agents:</p>

        <ul>
          <li> The worker may perform a genuinely long-running computation
          <li> The worker will have its own user-implemented "event" loop,
            communicating synchronously through shared memory; it will not use the
            browser's event loop
        </ul>
      </emu-note>

      <p> FIXME: Here and/or in termination detection below we want to
      reference the discussion on partial failure in Issue#55 </p>

    </emu-clause> <!-- license to kill -->

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Introspection">
      <h1>Termination detection</h1>
      <p> (Compatible(?) change) The worker object should have a read-only
	property called "state" whose value represents the state of the worker (eg
	a string naming the state).  One state might be "terminated", indicating
	the worker is dead. </p>

      <emu-note>
        <p> There appears to be no way at present to directly determine whether
        a Worker has terminated. </p>
      </emu-note>

      <emu-note>
        <p> Possible complementary mechanisms include throwing an exception when
          a message is sent to a terminated worker, and to send an error event to
          the creating agent when a worker is killed. </p>
      </emu-note>

      <emu-note>
	<p> The spec here can be related back to the agent attributes, specified
	  earlier. </p>
      </emu-note>
    </emu-clause> <!-- introspection -->
  </emu-clause> <!-- worker semantics -->
  
  <emu-clause id="WebBrowserEmbedding.Termination">
    <h1>Agent termination</h1>

    <p>If a worker is terminated by a call to its terminate method while it is
      blocked in then the worker is first woken and then immediately terminated
      (the wakeup is not observable to code running in the worker). </p>

    <emu-note>
      <p> (Spec draft note) Firefox supports close handlers that could in
	principle be used to clean up inconsistent state, but I think that's not in
	the HTML5 spec. </p>
    </emu-note>

    <p>If a worker is terminated for any other reason, such as the user agent
      reloading or closing the window or frame, and the worker is blocked in a
      call to futexWait when it is terminated, then the worker is first woken
      and then immediately terminated (the wakeup is not observable to code
      running in the worker).</p>

    <emu-note>
      <p> (Spec draft note) After the running script has been terminated the
	worker's close handler(s) will be run as if the wait had not been
	aborted.</p>
    </emu-note>
  </emu-clause> <!-- termination -->

</emu-clause> <!-- browser embedding -->

